<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Network - 分类 - TechKoala - Input/Output </title>
        <link>https://www.techkoala.top/categories/network/</link>
        <description>Network - 分类 - TechKoala - Input/Output </description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.top (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.top (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 29 Apr 2021 20:42:25 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/categories/network/" rel="self" type="application/rss+xml" /><item>
    <title>Windows 网络连接优先级设置</title>
    <link>https://www.techkoala.top/windows_10_network_priority/</link>
    <pubDate>Thu, 29 Apr 2021 20:42:25 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/windows_10_network_priority/</guid>
    <description><![CDATA[<blockquote>
<p>Windows10 默认优先使用有线连接，但是如需优先使用无线连接，除了拔网线/禁用有线网卡外，还可以通过修改接口跃点数，实现不同网络连接的优先级。</p>
</blockquote>
<h2 id="优先级设置方法">优先级设置方法</h2>
<h3 id="方法一控制面板中修改">方法一：控制面板中修改</h3>
<p>接口跃点数通过以下步骤找到：</p>
<p>首先打开<code>控制面板 &gt; 网络和 Internet &gt; 网络连接</code></p>
<p>找到想要修改的网络连接，右键打开<code>属性</code></p>
<p>接下来打开<code>Internet 协议版本 4 属性 &gt; 高级</code></p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/Network_Priority/GUI.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/Network_Priority/GUI.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/Network_Priority/GUI.webp" data-sub-html="<h2>控制面板设置界面</h2>">
        
    </a><figcaption class="image-caption">控制面板设置界面</figcaption>
    </figure>
<p>取消勾选<code>自动跃点</code>，填入需要设置的数值即可，有关数值设置的注意事项将在后续说明。</p>
<h3 id="方法二powershell-中修改">方法二：Powershell 中修改</h3>
<p>更便捷的方式是通过 Powershell 进行修改。</p>
<p>首先以管理员身份运行 Windows PowerShell，并使用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="nb">PS </span><span class="n">C:</span><span class="p">\</span><span class="n">Users</span><span class="p">\</span><span class="n">xxxx</span><span class="p">&gt;</span> <span class="nb">Get-NetIPInterface</span>
</code></pre></td></tr></table>
</div>
</div><p>获得当前所有的网络连接，其中<code>InterfaceMetric</code>即为接口跃点数的值。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/Network_Priority/powershell.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/Network_Priority/powershell.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/Network_Priority/powershell.webp" data-sub-html="<h2>Powershell 设置界面</h2>">
        
    </a><figcaption class="image-caption">Powershell 设置界面</figcaption>
    </figure>
<p>找到想要修改的网络连接以及它的 ifIndex (接口索引)值，例如 x，使用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="nb">PS </span><span class="n">C:</span><span class="p">\</span><span class="n">Users</span><span class="p">\</span><span class="n">xxxx</span><span class="p">&gt;</span> <span class="nb">Set-NetIPInterface</span> <span class="n">-InterfaceIndex</span> <span class="n">x</span> <span class="n">-InterfaceMetric</span> <span class="n">10</span>
</code></pre></td></tr></table>
</div>
</div><p>即可将其跃点数设置为 10。</p>
<p>想要恢复跃点数的话，运行以下命令即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="nb">PS </span><span class="n">C:</span><span class="p">\</span><span class="n">Users</span><span class="p">\</span><span class="n">xxxx</span><span class="p">&gt;</span> <span class="nb">Set-NetIPInterface</span> <span class="n">-InterfaceIndex</span> <span class="n">x</span> <span class="n">-AutomaticMetric</span> <span class="n">enabled</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="跃点数的设置范围">跃点数的设置范围</h3>
<p>跃点数越小，网络优先级越高。</p>
<p>跃点数的理论范围是 1 ~ 999，但跃点数低于 10 ，可能会导致某些网络访问失败，同时，合理的跃点数值也要参考网络带宽。</p>
<h2 id="分流方法">分流方法</h2>
<p>在同时使用 Wi-Fi 和有线网络的环境下可以用 route 命令实现特定网段使用特定接口。</p>
<p>举例：</p>
<p>可以连接到互联网的 Wi-Fi 网关地址是 <code>192.168.0.1</code>，有线网网关 IP 是 <code>10.0.0.1</code>。
分流：需要访问的内网资源都位于 <code>10.0.0.0/8</code> 段，其他流量都走 Wi-Fi。</p>
<ol>
<li>首先打开管理员身份的命令提示符，输入以下命令删除默认的路由表。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">route delete 0.0.0.0
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>添加一个默认路由，指定所有流量走 Wi-Fi。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">route add 0.0.0.0 mask 0.0.0.0 192.168.0.1
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>添加另一个路由，指定 <code>10.0.0.1~10.255.255.254</code> 流量走有线网络。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">route add 10.0.0.0 mask 255.0.0.0 10.0.0.1
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://windows10.pro/set-netipinterface-interfaceindex-interfacemetric/" target="_blank" rel="noopener noreferrer">修改接口跃点数，让 Win10 优先使用无线网络连接</a></p>
</li>
<li>
<p>[2] <a href="https://www.appinn.com/wi-fi-or-lan/" target="_blank" rel="noopener noreferrer">同时连接网线和 Wi-Fi，如何优先使用 Wi-Fi？试试接口跃点数</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>使用 Nginx 实现多服务复用端口</title>
    <link>https://www.techkoala.top/nginx_port_reuse/</link>
    <pubDate>Tue, 20 Apr 2021 14:17:01 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nginx_port_reuse/</guid>
    <description><![CDATA[<blockquote>
<p>利用 Nginx 在单一服务器上搭建多个同端口的服务</p>
</blockquote>
<h2 id="说明">说明</h2>
<p>目前服务器上运行了一个 <code>Trojan</code> 实例以及通过 <code>frp</code> 与本地的服务器通信以实现 <code>Bitwarden</code> 的内网穿透访问。</p>
<p>两个服务使用了不同域名进行区分，但为了便捷，都使用 <code>443</code> 端口。</p>
<h2 id="流程概览">流程概览</h2>
<ol>
<li>采用 <code>Docker</code> 在本地服务器上搭建 <code>Bitwarden</code>，配置并运行 <code>frpc</code> 指向服务器上的 <code>frps</code></li>
<li>在服务器上搭建其他网站或者需要使用 <code>443</code> 端口的服务（如:<code>Trojan</code>)，配置运行 <code>frps</code></li>
<li>安装 <code>Nginx</code>，这里需要利用 <code>Nginx</code> 的 <code>stream_ssl_preread</code> 模块，使用<code>nginx -V</code>查看是否包含该模块。（该模块在 <code>Nginx 1.19.2</code> 已默认包含，但 <code>Ubuntu</code> 等发行版还在使用更老的 <code>stable</code> 版本，需要手动添加 <code>mainline</code> 版本源，并更新 <code>Nginx</code> 到最新版本）</li>
</ol>
<h2 id="本地配置文件">本地配置文件</h2>
<h3 id="frpcini">frpc.ini</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[common]
server_addr = xxx.xxx.xxx.xxx           # 服务器地址
server_port = xxx                       # 与服务器 frps 通信的端口
token = xxxxxx                          # frp 验证密钥

[bitwarden_https]
type = https
local_port = 443
custom_domains = xxx.xxx.xxx            # Bitwarden 域名
</code></pre></td></tr></table>
</div>
</div><h3 id="本地-nginxcof">本地 nginx.cof</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">user www www;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;
worker_rlimit_nofile 8192;
events {
    worker_connections 4096;
}
http {
    include mime.types;
    default_type application/octet-stream;

    client_max_body_size 0;
    client_body_buffer_size 512k;

    sendfile on;
    sendfile_max_chunk 1m;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;

    types_hash_max_size 4096;

    proxy_cache_path /var/run/nginx-proxy-cache levels=1:2 keys_zone=cache_one:20m inactive=1d max_size=500m;
    proxy_cache cache_one;
    proxy_temp_path /var/run/proxy_temp_dir;
    proxy_temp_file_write_size 128k;
    proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;
    proxy_buffer_size 16k;
    proxy_busy_buffers_size 24k;
    proxy_buffers 64 4k;

    gzip on;
    gzip_min_length 1k;
    gzip_buffers 4 16k;
    gzip_http_version 1.1;
    gzip_comp_level 2;
    gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml;
    gzip_vary on;
    gzip_proxied expired no-cache no-store private auth;
    gzip_disable &#34;MSIE [1-6]\.&#34;;

    server_tokens off;

    server {
        listen 443 ssl http2;
        server_name xxx.xxx.xxx;                        # 域名

        ssl_certificate /xxx/cert/fullchain.pem;        # 证书路径
        ssl_certificate_key /xxx/cert/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 1d;

        location / {
            proxy_pass http://127.0.0.1:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /notifications/hub {
            proxy_pass http://127.0.0.1:3012;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &#34;upgrade&#34;;
        }

        location /notifications/hub/negotiate {
            proxy_pass http://127.0.0.1:8080;
        }
    }
}
</code></pre></td></tr></table>
</div>
</div><h2 id="服务器配置文件">服务器配置文件</h2>
<h3 id="frpsini">frps.ini</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[common]
bind_port = xxxx                # 与本地 frpc 通信的端口
vhost_https_port = xxxx         # 虚拟 https 端口，需要和 nginx.conf 内一致
authentication_method = token
token = xxxxxx                  # frp 验证密钥
</code></pre></td></tr></table>
</div>
</div><h3 id="服务器-nginxcof">服务器 nginx.cof</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">user www-data;
worker_processes auto;
pid /var/run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
	worker_connections 768;
	# multi_accept on;
}

stream {
    map $ssl_preread_server_name $name {
        xxx.xxx.xxx frps-bitwarden;   # Bitwarden 域名
        xxx.xxx.xxx trojan;           # Trojan 域名
    }
    upstream frps-bitwarden {
        server 127.0.0.1:8080;        # Bitwarden的 frps 端口
    }
    upstream trojan {
        server 127.0.0.1:4443;        # Trojan 本地监听端口
    }
    server {
        listen 443 reuseport;
        listen [::]:443 reuseport;
        proxy_pass	$name;
        ssl_preread on;               # 开启 ssl_preread
    }
}

http {
	##
	# Basic Settings
	##

	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	keepalive_timeout 65;
	types_hash_max_size 2048;
	# server_tokens off;

	# server_names_hash_bucket_size 64;
	# server_name_in_redirect off;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##

	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	##
	# Gzip Settings
	##

	gzip on;

	# gzip_vary on;
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;     # 启用的网站配置放置在此文件夹下
}

</code></pre></td></tr></table>
</div>
</div><h3 id="bitwarden-nginx-配置">Bitwarden Nginx 配置</h3>
<p>放置在<code>/etc/nginx/sites-enabled/</code>下，与域名同名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">## Bitwarden 配置。只负责只将 http 重定向至 https
## Bitwarden 的 SSL 握手交给本地服务器端的 Nginx 处理
server {
        listen 80;
        listen [::]:80;
        server_name xxx.xxx.xxx;                    # Bitwarden 域名
        return 301 https://xxx.xxx.xxx$request_uri; # Bitwarden 域名
}

</code></pre></td></tr></table>
</div>
</div><p>链接配置文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ln -s /etc/nginx/sites-available/xxx.xxx.xxx /etc/nginx/sites-enabled/
</code></pre></td></tr></table>
</div>
</div><h3 id="trojan-nginx-配置">Trojan Nginx 配置</h3>
<p>放置在<code>/etc/nginx/sites-enabled/</code>下，与域名同名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">server {
    listen 127.0.0.1:80 default_server;
    server_name xxx.xxx.xxx;                   # 自己的域名
    location / {
        proxy_pass https://www.aliexpress.com; # 伪装的网站，这里是阿里速卖通
    }
}
server {
    listen 127.0.0.1:80;
    server_name xxx.xxx.xxx.xxx;                 # 自己服务器的 IP
    return 301 https://xxx.xxx.xxx$request_uri;  # 自己的域名
}
server {
    listen 0.0.0.0:80;
    listen [::]:80;
    server_name _;
    return 301 https://$host$request_uri;
}

</code></pre></td></tr></table>
</div>
</div><p>链接配置文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ln -s /etc/nginx/sites-available/xxx.xxx.xxx /etc/nginx/sites-enabled/
</code></pre></td></tr></table>
</div>
</div><h3 id="trojan-配置">Trojan 配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">{
    &#34;run_type&#34;: &#34;server&#34;,
    &#34;local_addr&#34;: &#34;0.0.0.0&#34;,
    &#34;local_port&#34;: 4443,             # 本地监听端口，与 nginx.conf 保持一致
    &#34;remote_addr&#34;: &#34;127.0.0.1&#34;,
    &#34;remote_port&#34;: 80,              # 伪装站点的端口
    &#34;password&#34;: [
        &#34;xxxxxx&#34;                    # 密钥
    ],
    &#34;log_level&#34;: 1,
    &#34;ssl&#34;: {
        &#34;cert&#34;: &#34;/usr/local/etc/ssl/certificate.crt&#34;,
        &#34;key&#34;: &#34;/usr/local/etc/ssl/private.key&#34;,
        &#34;key_password&#34;: &#34;&#34;,
        &#34;cipher&#34;: &#34;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&#34;,
        &#34;cipher_tls13&#34;: &#34;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&#34;,
        &#34;prefer_server_cipher&#34;: true,
        &#34;alpn&#34;: [
            &#34;http/1.1&#34;
        ],
        &#34;alpn_port_override&#34;: {
            &#34;h2&#34;: 81
        },
        &#34;reuse_session&#34;: true,
        &#34;session_ticket&#34;: false,
        &#34;session_timeout&#34;: 600,
        &#34;plain_http_response&#34;: &#34;&#34;,
        &#34;curves&#34;: &#34;&#34;,
        &#34;dhparam&#34;: &#34;&#34;
    },
    &#34;tcp&#34;: {
        &#34;prefer_ipv4&#34;: false,
        &#34;no_delay&#34;: true,
        &#34;keep_alive&#34;: true,
        &#34;reuse_port&#34;: false,
        &#34;fast_open&#34;: false,
        &#34;fast_open_qlen&#34;: 20
    },
    &#34;mysql&#34;: {
        &#34;enabled&#34;: false,
        &#34;server_addr&#34;: &#34;127.0.0.1&#34;,
        &#34;server_port&#34;: 3306,
        &#34;database&#34;: &#34;trojan&#34;,
        &#34;username&#34;: &#34;trojan&#34;,
        &#34;password&#34;: &#34;&#34;,
        &#34;key&#34;: &#34;&#34;,
        &#34;cert&#34;: &#34;&#34;,
        &#34;ca&#34;: &#34;&#34;
    }
}
</code></pre></td></tr></table>
</div>
</div><h2 id="防火墙设置">防火墙设置</h2>
<p>上述操作后，服务器需要打开<code>80</code>,<code>443</code>,<code>xxx</code>（frp 通信端口）</p>]]></description>
</item><item>
    <title>OpenWRT 使用 dnscrypt-proxy2 实现 DoH 查询及分流</title>
    <link>https://www.techkoala.top/openwrt_doh/</link>
    <pubDate>Fri, 29 Jan 2021 20:36:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_doh/</guid>
    <description><![CDATA[<blockquote>
<p>OpenWRT 原始并不支持 DoH 或 DoT，会有 DNS 泄露问题</p>
</blockquote>
<h2 id="安裝-dnscrypt-proxy2">安裝 dnscrypt-proxy2</h2>
<p>如果使用 OpenWrt 19.07+版本，那么直接使用 opkg 即可完成安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">opkg update
opkg install dnscrypt-proxy2
</code></pre></td></tr></table>
</div>
</div><p>不过，版本可能不是最新，如果需要最新版本可以自行编译。</p>
<h2 id="配置">配置</h2>
<p>基本使用只需要</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">vim /etc/dnscrypt-proxy2/dnscrypt-proxy.toml
</code></pre></td></tr></table>
</div>
</div><p>修改</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">listen_addresses = [&#39;127.0.0.1:5335&#39;]
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">server_names = [&#39;google&#39;, &#39;cloudflare&#39;]
</code></pre></td></tr></table>
</div>
</div><p>即可</p>
<p>软件已经内置了常见的 DoH/DoT 服务器了，因此只需要填入名称即可</p>
<p>然后</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/etc/init.d/dnscrypt-proxy restart
</code></pre></td></tr></table>
</div>
</div><p>重启软件，dnscrypt-proxy2 就会监听在 5335 这个端口了。</p>
<h2 id="分流搭配-ssr">分流（搭配 SSR+）</h2>
<ol>
<li>SSR+ 使用大陆 IP 白名单 并使用 5335 的 DNS 解析的方式</li>
<li>dnscyrpt-proxy2 配置监听在 5335，仅使用 DoH 协议向 <code>Cloudflare/Google</code> 服务器查询（这些 <code>Https</code> 的查询请求全部会被 SSR+ 代理转发）</li>
<li>iptables 劫持所有目标为 53 端口的流量到路由器的 53 端口（默认）</li>
<li>53 端口使用默认的 <code>masq</code> 作为 <code>DNS</code> 服务，上游设置为 127.0.0.1#5335，配置文件<code>/etc/dnsmasq.conf</code>最后添加 <code>conf-dir=/etc/dnsmasq.d</code></li>
<li>在<code>/etc/dnsmasq.d/</code>(如无则新建）中放入<code>https://github.com/felixonmars/dnsmasq-china-list/blob/master/accelerated-domains.china.conf</code></li>
</ol>
<p>这样实现了凡是大陆的和在大陆有 cdn 的以及返回 AAAA 记录的域名全部直连查询并直连访问，其余的全部走代理查询，且结果在大陆以外的走代理访问（IP+域名的双白名单机制）</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://github.com/coolsnowwolf/lede/issues/2551" target="_blank" rel="noopener noreferrer">lede</a></p>
</li>
<li>
<p>[2] <a href="https://github.com/DNSCrypt/dnscrypt-proxy/wiki/Installation-on-OpenWrt" target="_blank" rel="noopener noreferrer">Installation on OpenWrt</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>告知你不为人知的 UDP —— 疑难杂症和使用</title>
    <link>https://www.techkoala.top/udp_intractable_diseases/</link>
    <pubDate>Mon, 26 Oct 2020 11:06:30 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/udp_intractable_diseases/</guid>
    <description><![CDATA[<blockquote>
<p>UDP 说来简单，但是一些细节你都清楚吗？</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：贺嘉</p>
<p>链接：https://zhuanlan.zhihu.com/p/25622691</p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="udp-疑难杂症">UDP 疑难杂症</h2>
<h3 id="udp-的传输方式面向报文">UDP 的传输方式：面向报文</h3>
<p>面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么 UDP 的报文大小由哪些影响因素呢？UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？</p>
<h4 id="udp-报文大小的影响因素主要有以下-3-个">UDP 报文大小的影响因素，主要有以下 3 个</h4>
<ul>
<li>UDP 协议本身，UDP 协议中有 16 位的 UDP 报文长度，那么 UDP 报文长度不能超过 $2^{16}=65536$.</li>
<li>以太网(Ethernet)数据帧的长度，数据链路层的 MTU(最大传输单元)。</li>
<li>socket 的 UDP 发送缓存区大小</li>
</ul>
<h4 id="udp-数据包最大长度">UDP 数据包最大长度</h4>
<p>根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 $2^{16}$ 的个字节。由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的<strong>最大理论长度</strong>是 $2^{16} - 1 - 8 - 20 = 65507$ 字节。</p>
<p>如果发送的数据包超过 65507 字节，send 或 sendto 函数会错误码 1(Operation not permitted，Message too long)，当然啦，一个数据包能否发送 65507 字节，还和 UDP 发送缓冲区大小（Linux 下 UDP 发送缓冲区大小为：<code>cat /proc/sys/net/core/wmem_default</code>）相关，如果发送缓冲区小于 65507 字节，在发送一个数据包为 65507 字节的时候，send 或 sendto 函数会错误码 1(Operation not permitted，No buffer space available)。</p>
<h4 id="udp-数据包理想长度">UDP 数据包理想长度</h4>
<p>理论上 UDP 报文最大长度是 <strong>65507</strong> 字节，实际上发送这么大的数据包效果最好吗？</p>
<ul>
<li>
<p>我们知道 UDP 是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们<strong>最好</strong>能控制 UDP 包在下层协议的传输过程中<strong>不要被切割</strong>。</p>
<p>相信大家都知道 MTU 这个概念。MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet II 帧的结构 DMAC+SMAC+Type+Data+CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小 <strong>64</strong> 字节，最大不能超过 <strong>1518</strong> 字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是 1518 字节，除去以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes 那么剩下承载上层协议的地方也就是 Data 域最大就只能有 <strong>1500</strong> 字节这个值我们就把它称之为 MTU。</p>
<p>在下层数据链路层最大传输单元是 1500 字节的情况下，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是 1500 字节 – IP 头(20 字节) – UDP 头(8 字节) = <strong>1472</strong> 字节。不过鉴于 Internet 上的标准 MTU 值为 <strong>576</strong> 字节，所以建议在进行 Internet 的 UDP 编程时，最好将 UDP 的数据长度控制在 (576-8-20)<strong>548</strong> 字节以内。</p>
</li>
</ul>
<h3 id="udp-数据包的发送和接收问题">UDP 数据包的发送和接收问题</h3>
<h4 id="udp-的通信有界性">UDP 的通信有界性</h4>
<p>在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。</p>
<h4 id="udp-数据包的无序性和非可靠性">UDP 数据包的无序性和非可靠性</h4>
<p>Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。</p>
<h4 id="udp-数据包的接收">UDP 数据包的接收</h4>
<p>Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？</p>
<ul>
<li>由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。</li>
</ul>
<p>在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？</p>
<ul>
<li>由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。</li>
</ul>
<h4 id="udp-包分片问题">UDP 包分片问题</h4>
<p>如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？</p>
<ul>
<li>根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。</li>
</ul>
<h3 id="udp-丢包问题">UDP 丢包问题</h3>
<p>在不考虑 UDP 下层 IP 层的分片丢失，CRC 检验包不完整的情况下，造成 UDP 丢包的因素有哪些呢？</p>
<ol>
<li>UDP socket 缓冲区满造成的 UDP 丢包</li>
</ol>
<ul>
<li>通过 <code>cat /proc/sys/net/core/rmem_default</code> 和 <code>cat /proc/sys/net/core/rmem_max</code> 可以查看 socket 缓冲区的缺省值和最大值。如果 socket 缓冲区满了，应用程序没来得及处理在缓冲区中的 UDP 包，那么后续来的 UDP 包会被内核丢弃，造成丢包。在 socket 缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解 UDP 丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。</li>
</ul>
<ol>
<li>UDP socket 缓冲区过小造成的 UDP 丢包</li>
</ol>
<ul>
<li>如果 Client 发送的 UDP 报文很大，而 socket 缓冲区过小无法容下该 UDP 报文，那么该报文就会丢失。</li>
</ul>
<ol start="2">
<li>ARP 缓存过期导致 UDP 丢包</li>
</ol>
<ul>
<li>
<p>ARP 的缓存时间约 10 分钟，APR 缓存列表没有对方的 MAC 地址或缓存过期的时候，会发送 ARP 请求获取 MAC 地址，在没有获取到 MAC 地址之前，用户发送出去的 UDP 数据包会被内核缓存到 arp_queue 这个队列中，默认最多缓存 3 个包，多余的 UDP 包会被丢弃。</p>
<p>被丢弃的 UDP 包可以从 <code>/proc/net/stat/arp_cache</code> 的最后一列的 <code>unresolved_discards</code> 看到。当然我们可以通过 <code>echo 30 &gt; /proc/sys/net/ipv4/neigh/eth1/unres_qlen</code> 来增大可以缓存的 UDP 包。UDP 的丢包信息可以从 <code>cat /proc/net/udp</code> 的最后一列 drops 中得到，而倒数第四列 inode 是丢失 UDP 数据包的 socket 的全局唯一的虚拟 i 节点号，可以通过这个 inode 号结合 <code>lsof(lsof -P -n | grep 25445445)</code>来查到具体的进程。</p>
</li>
</ul>
<h3 id="udp-冗余传输">UDP 冗余传输</h3>
<p>在外网通信链路不稳定的情况下，有什么办法可以降低 UDP 的丢包率呢？</p>
<p>一个简单的办法来采用<strong>冗余传输</strong>的方式。一般采用较多的是延时双发，双发指的是将原本单发的前后连续的两个包合并成一个大包发送，这样发送的数据量是原来的两倍。这种方式提高丢包率的原理比较简单，例如本例的冗余发包方式，在偶数包全丢的情况下，依然能够还原出完整的数据，也就是在这种情况下，50% 的丢包率，依然能够达到 100% 的数据接收。</p>
<h2 id="udp-真的比-tcp-要高效吗">UDP 真的比 TCP 要高效吗</h2>
<p>相信很多同学都认为 UDP 无连接，无需重传和处理确认，UDP 比较高效。然而 UDP 在大多情况下并不一定比 TCP 高效，TCP 发展至今天，为了适应各种复杂的网络环境，其算法已经非常丰富，协议本身经过了很多优化，如果能够合理配置 TCP 的各种参数选项，那么在多数的网络环境下 TCP 是要比 UDP 更高效的。</p>
<h3 id="影响-udp-高效因素">影响 UDP 高效因素</h3>
<h4 id="无法智能利用空闲带宽导致资源利用率低">无法智能利用空闲带宽导致资源利用率低</h4>
<p>一个简单的事实是 UDP 并不会受到 MTU 的影响，MTU 只会影响下层的 IP 分片，对此 UDP 一无所知。在极端情况下，UDP 每次都是发小包，包是 MTU 的几百分之一，这样就造成 UDP 包的有效数据占比较小(UDP 头的封装成本)；或者，UDP 每次都是发巨大的 UDP 包，包大小 MTU 的几百倍，这样会造成下层 IP 层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个 UDP 包的无效。由于网络情况是动态变化的，UDP 无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而 TCP 有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP 的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。</p>
<h4 id="无法动态调整发包">无法动态调整发包</h4>
<p>由于 UDP 没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP 并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，UDP 的无秩序性和自私性，一个疯狂的 UDP 程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。</p>
<h4 id="改进-udp-的成本较高">改进 UDP 的成本较高</h4>
<p>可能有同学想到针对 UDP 的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，UDP 编程可是比 TCP 要难不少的，考虑到改造成本，为什么不直接用 TCP 呢？当然可以拿开源的一些实现来抄一下(例如：libjingle)，或者拥抱一下 Google 的 QUIC 协议，然而，这些都需要不少成本的。</p>
<p>上面说了这么多，难道真的不该用 UDP 了吗？其实也不是的，在某些场景下，我们还是必须 UDP 才行的。那么 UDP 的较为合适的使用场景是哪些呢？</p>
<h2 id="udp-的使用场合">UDP 的使用场合</h2>
<h3 id="通信实时性和持续性">通信实时性和持续性</h3>
<p>在分组交换通信当中，协议栈的成本主要表现在以下两方面：</p>
<ul>
<li>封装带来的空间复杂度</li>
<li>缓存带来的时间复杂度</li>
</ul>
<p>以上两者是对立影响的，如果想减少封装消耗，那么就必须缓存用户数据到一定量在一次性封装发送出去，这样每个协议包的有效载荷将达到最大化，这无疑是节省了带宽空间，带宽利用率较高，但是延时增大了。如果想降低延时，那么就需要将用户数据立马封装发出去，这样显然会造成消耗更多的协议头等消耗，浪费带宽空间。</p>
<p>因此，我们进行协议选择的时候，需要重点考虑一下<strong>空间复杂度</strong>和<strong>时间复杂度</strong>间的平衡。</p>
<p>通信的持续性对两者的影响比较大，根据通信的持续性有两种通信类型：</p>
<ul>
<li>短连接通信</li>
<li>长连接通信</li>
</ul>
<p>对于短连接通信，一方面如果业务只需要发一两个包并且对丢包有一定的容忍度，同时业务自己有简单的轮询或重复机制，那么采用 UDP 会较为好些。在这样的场景下，如果用 TCP，仅仅握手就需要 3 个包，这样显然有点不划算，一个典型的例子是 DNS 查询。另一方面，如果业务实时性要求非常高，并且不能忍受重传，那么首先就是 UDP 了或者只能用 UDP 了，例如 NTP 协议，重传 NTP 消息纯属添乱(为什么呢？重传一个过期的时间包过来，还不如发一个新的 UDP 包同步新的时间过来)。如果 NTP 协议采用 TCP，撇开握手消耗较多数据包交互的问题，由于 TCP 受 Nagel 算法等影响，用户数据会在一定情况下会被内核缓存延后发送出去，这样时间同步就会出现比较大的偏差，协议将不可用。</p>
<h3 id="多点通信">多点通信</h3>
<p>对于一些多点通信的场景，如果采用有连接的 TCP，那么就需要和多个通信节点建立其双向连接，然后有时在 NAT 环境下，两个通信节点建立其直接的 TCP 连接不是一个容易的事情，在涉及 NAT 穿越的时候，UDP 协议的无连接性使得穿透成功率更高(原因详见：由于 UDP 的无连接性，那么其完全可以向一个组播地址发送数据或者轮转地向多个目的地持续发送相同的数据，从而更为容易实现多点通信。)</p>
<p>一个典型的场景是多人实时音视频通信，这种场景下实时性要求比较高，可以容忍一定的丢包率。比如：对于音频，对端连续发送 p1、p2、p3 三个包，另一端收到了 p1 和 p3，在没收到 p2 的保持 p1 的最后一个音（也是为什么有时候网络丢包就会听到嗞嗞嗞嗞嗞嗞…或者卟卟卟卟卟卟卟卟…重音的原因），等到到 p3 就接着播 p3 了，不需要也不能补帧，一补就越来越大的延时。对于这样的场景就比较合适用 UDP 了，如果采用 TCP，那么在出现丢包的时候，就可能会出现比较大的延时。</p>
<h3 id="udp-使用原则">UDP 使用原则</h3>
<p>通常情况下，UDP 的使用范围是较小的，在以下的场景下，使用 UDP 才是明智的：</p>
<ul>
<li>实时性要求很高，并且几乎不能容忍重传。例子：NTP 协议，实时音视频通信，多人动作类游戏中人物动作、位置</li>
<li>TCP 实在不方便实现多点传输的情况</li>
<li>需要进行 NAT 穿越</li>
<li>对网络状态很熟悉，确保 UDP 网络中没有氓流行为，例如疯狂抢带宽</li>
<li>熟悉 UDP 编程</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="http://blog.csdn.net/dog250/article/details/6896949http://blog.csdn.net/dog250/article/details/6896949" target="_blank" rel="noopener noreferrer">Netfilter,iptables/OpenVPN/TCP guard</a></li>
</ul>]]></description>
</item><item>
    <title>DNS 报文详解</title>
    <link>https://www.techkoala.top/dns/</link>
    <pubDate>Tue, 20 Oct 2020 13:24:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns/</guid>
    <description><![CDATA[<blockquote>
<p>本文主要讲解 DNS 的报文结构</p>
</blockquote>
<h2 id="dns-简介">DNS 简介</h2>
<p>简单来说 DNS 负责将我们熟知的域名翻译成 IP 地址，其相关定义由 RFC 1034 和 RFC 1035 给出。</p>
<p>为了更加的扩展性，DNS 由大量的服务器分层次进行组织的，大致来说分为：根 DNS 服务器、顶域名（TLD）DNS 服务器和权威 DNS 服务器。他们的层次结构如下图所示：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" data-sub-html="<h2>DNS 的层次结构</h2>">
        
    </a><figcaption class="image-caption">DNS 的层次结构</figcaption>
    </figure>
<p>关于 DNS 的工作过程及相关信息参见<a href="https://www.techkoala.top/dns_update/" target="_blank" rel="noopener noreferrer">深入浅出 DNS 解析</a>，本文负责补充 DNS 报文结构。</p>
<h3 id="dns-报文结构">DNS 报文结构</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" data-sub-html="<h2>DNS 的报文结构</h2>">
        
    </a><figcaption class="image-caption">DNS 的报文结构</figcaption>
    </figure>
<ul>
<li>
<p>前 12 个字节为<strong>首部</strong>，包含：</p>
<ul>
<li>
<p><strong>标识符</strong>（2 字节），用于标识请求及其响应报文，区分不同的查询</p>
</li>
<li>
<p><strong>标志</strong>（2 字节），其中：</p>
<ul>
<li><strong>QR</strong>（1bit）：查询/响应标志，<code>0</code> 为查询，<code>1</code> 为响应</li>
<li><strong>opcode</strong>（4bit）：<code>0</code> 表示标准查询，<code>1</code> 表示反向查询，<code>2</code> 表示服务器状态请求，<code>[3,15]</code>为保留值</li>
<li><strong>AA</strong>（1bit）：表示授权回答，这个比特位在应答的时候才有意义，指出给出应答的服务器是查询域名的授权解析服务器</li>
<li><strong>TC</strong>（1bit）：表示可截断的，用来指出报文比允许的长度还要长，导致被截断;</li>
<li><strong>RD</strong>（1bit）：表示期望递归，这个比特位被<strong>请求</strong>设置，应答的时候使用的相同的值返回。如果设置了 RD，就建议域名服务器进行递归解析，递归查询的支持是可选的;</li>
<li><strong>RA</strong>（1bit）：表示可用递归，这个比特位在<strong>应答</strong>中设置或取消，用来代表服务器是否支持递归查询;</li>
<li><strong>rcode</strong>（4bit）：表示返回码
<ul>
<li><code>0</code> : 没有错误</li>
<li><code>1</code> : 报文格式错误(Format error) - 服务器不能理解请求的报文</li>
<li><code>2</code> : 服务器失败(Server failure) - 因为服务器的原因导致没办法处理这个请求</li>
<li><code>3</code> : 名字错误(Name Error) - 只有对授权域名解析服务器有意义，指出解析的域名不存在</li>
<li><code>4</code> : 没有实现(Not Implemented) - 域名服务器不支持查询类型</li>
<li><code>5</code> : 拒绝(Refused) - 服务器由于设置的策略拒绝给出应答.比如，服务器不希望对某些请求者给出应答，或者服务器不希望进行某些操作（比如区域传送 zone transfer）</li>
<li><code>[6,15]</code> : 保留值，暂未使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数量字段</strong>（8 字节）：每个区域 2 字节</p>
<ul>
<li><strong>Questions</strong> 表示查询问题区域节的数量</li>
<li><strong>Answers</strong> 表示回答区域的数量</li>
<li><strong>Authoritative namesversers</strong> 表示授权区域的数量</li>
<li><strong>Additional recoreds</strong> 表示附加区域的数量</li>
</ul>
</li>
<li>
<p><strong>问题</strong>（Questions）部分包括：</p>
<ul>
<li>查询的域名 8bit 为单位，长度不受限</li>
<li>查询的协议类型 16bit</li>
<li>查询的类 16bit</li>
</ul>
</li>
<li>
<p><strong>回答</strong>（Answers）/<strong>权威</strong>（Authoritys）/<strong>附加</strong>（Additionals）部分格式相同：</p>
<ul>
<li><strong>NAME</strong> 资源记录包含的域名.</li>
<li><strong>TYPE</strong> 表示 DNS 协议的类型.</li>
<li><strong>CLASS</strong> 表示 RDATA 的类.</li>
<li><strong>TTL</strong> 4 字节无符号整数表示资源记录可以缓存的时间。0 代表只能被传输，但是不能被缓存。</li>
<li><strong>RDLENGTH</strong> 2 个字节无符号整数表示 RDATA 的长度</li>
<li><strong>RDATA</strong> 不定长字符串来表示记录，格式根 TYPE 和 CLASS 有关。比如，TYPE 是 A，CLASS 是 IN，那么 RDATA 就是一个 4 个字节的 ARPA 网络地址。</li>
</ul>
</li>
</ul>
<h2 id="rrs-说明">RRs 说明</h2>
<p>每个 DNS 响应报文包含一条或者多条资源记录（resource records ，RRs），资源记录包含下列字段的 4 元组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">（Name，Value，Type，TTL）
</code></pre></td></tr></table>
</div>
</div><p>其中 TTL 表示生存时间，决定了资源记录应该从缓存中删除的时间。</p>
<ul>
<li>如果是 Type=A，Name 为主机名，Value 是对应的 IP 地址（如 bar.foo.com，xxx.xxx.xxx.xxx，A）</li>
<li>如果是 Type=NS，Name 为一个域（如 foo.com），Value 是知道如何获取该域中的主机 IP 地址的权威 DNS 服务器的主机名（如 foo.com，dns.foo.com，NS）</li>
<li>如果是 Type=CNAME，Value 是别名为 Name 的主机对应的规范主机名。（如 foo.com，relay1.bar.foo.com，CNAME）</li>
<li>如果是 Type=MX，Value 是别名为 Name 的邮件服务器对应的规范主机名。（如 foo.com，mail.bar.foo.com，MX）</li>
</ul>
<h2 id="实例">实例</h2>
<p>这里我们使用 WireShark 抓包实际看看，启动 WireShark 时可以设置捕获过滤器为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">udp port 53
</code></pre></td></tr></table>
</div>
</div><p>这样我们只抓取通过 UDP 53 端口的 DNS 请求，此外如果需要仅仅显示特定的 DNS 查询，还可以进一步应用显示过滤器，例如这里我们仅查看<code>www.techkoala.top</code>的查询记录，则显示过滤器设置为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dns.qry.name==www.techkoala.top
</code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" data-sub-html="<h2>16 进制表示</h2>">
        
    </a><figcaption class="image-caption">16 进制表示</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" data-sub-html="<h2>WireShark 中 DNS 请求报文及其结构</h2>">
        
    </a><figcaption class="image-caption">WireShark 中 DNS 请求报文及其结构</figcaption>
    </figure>
<p>可以看出</p>
<ul>
<li>标识为：0x0000cd13</li>
<li>这是一个请求报文，仅在 Questions 部分有值</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" data-sub-html="<h2>标志部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">标志部分各个字段的值</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" data-sub-html="<h2>查询部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">查询部分各个字段的值</figcaption>
    </figure>
<p>同时 WireShark 还贴心的告诉我们，响应报文的在总抓取包的编号为 10，方便我们快速找到请求报文对应的响应报文。</p>
<p><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" data-sub-html="<h2>16进制表示</h2>">
        
    </a><figcaption class="image-caption">16进制表示</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" data-sub-html="<h2>WireShark 中 DNS 响应报文及其结构</h2>">
        
    </a><figcaption class="image-caption">WireShark 中 DNS 响应报文及其结构</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" data-sub-html="<h2>标志部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">标志部分各个字段的值</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" data-sub-html="<h2>查询部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">查询部分各个字段的值</figcaption>
    </figure></p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] Computer Networking A Top-Down Approach</li>
<li>[2] <a href="https://juejin.im/post/6844903582441963527" target="_blank" rel="noopener noreferrer">DNS 请求报文详解</a></li>
</ul>]]></description>
</item><item>
    <title>ARP &amp; RARP 详解</title>
    <link>https://www.techkoala.top/arp_rarp/</link>
    <pubDate>Fri, 16 Oct 2020 15:56:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/arp_rarp/</guid>
    <description><![CDATA[<blockquote>
<p>ARP 以及 RARP 如何工作？</p>
</blockquote>
<h2 id="为什么要有-mac-地址">为什么要有 MAC 地址？</h2>
<p>在说明 ARP 以及 RARP 之前，有必要首先说一下 MAC 地址的必要性。</p>
<p>引用《Computer Networking A Top-Down Approach》中的描述：</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>KEEPING THE LAYERS INDEPENDENT<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">There are several reasons why hosts and router interfaces have MAC addresses in addition to network-layer addresses. First, LANs are designed for arbitrary network-layer protocols, not just for IP and the Internet. If adapters were assigned IP addresses rather than “neutral” MAC addresses, then adapters would not easily be able to support other network-layer protocols (for example, IPX or DECnet). Second, if adapters were to use network-layer addresses instead of MAC addresses, the network-layer address would have to be stored in the adapter RAM and reconfigured every time the adapter was moved (or powered up). Another option is to not use any addresses in the adapters and have each adapter pass the data (typically, an IP datagram) of each frame it receives up the protocol stack. The network layer could then check for a matching network-layer address. One problem with this option is that the host would be interrupted by every frame sent on the LAN, including by frames that were destined for other hosts on the same broadcast LAN. In summary, in order for the layers to be largely independent building blocks in a network architecture, different layers need to have their own addressing scheme. We have now seen three types of addresses: host names for the application layer, IP addresses for the network layer, and
MAC addresses for the link layer.</div>
        </div>
    </div>
<p>简单来说：</p>
<ul>
<li>局域网不仅仅为 IP 和因特网设计，MAC 地址的“中立性”为各种网络层协议（比如 IPX 或者 DECnet)提供了灵活的施展空间</li>
<li>网络层地址往往是动态的，每次更换网络或者重启都需要对适配器进行重新配置</li>
<li>如果取消 MAC 地址，让适配器把收到的每帧都往上层传递，就会带来一个问题：主机会去处理局域网中的每个帧，即使这个帧不属于自己，这就带来了不必要的消耗。</li>
</ul>
<h2 id="arp">ARP</h2>
<p>一句话概括 ARP（Address Resolution Protocol，地址解析协议）的目的就是：负责将<strong>网络层地址</strong>（最常见的就是 IP 地址）解析为/映射到<strong>链路层地址</strong>（MAC 地址）。</p>
<h3 id="报文结构">报文结构</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" data-sub-html="<h2>ARP 包结构</h2>">
        
    </a><figcaption class="image-caption">ARP 包结构</figcaption>
    </figure>
<p>一般我们讨论以太网中的 ARP 报文时候，ARP 数据会被封装在以太网报文中，其中：</p>
<ul>
<li>
<p>以太网报文：</p>
<ul>
<li><strong>目标以太网地址</strong>：目标 MAC 地址，FF:FF:FF:FF:FF:FF （二进制全 1）为广播地址</li>
<li><strong>源以太网地址</strong>：发送方 MAC 地址</li>
<li><strong>帧类型</strong>：以太类型，<strong>ARP 为 0x0806</strong></li>
</ul>
</li>
<li>
<p>ARP 报文数据：</p>
<ul>
<li><strong>硬件类型</strong>：如以太网（0x0001）、分组无线网</li>
<li><strong>协议类型</strong>：如网际协议(IP)（0x0800）、IPv6（0x86DD）</li>
<li><strong>硬件地址长度</strong>：每种硬件地址的字节长度，一般为 6（以太网）</li>
<li><strong>协议地址长度</strong>：每种协议地址的字节长度，一般为 4（IPv4）</li>
<li><strong>操作码 OP</strong>：1 为 ARP 请求，2 为 ARP 应答，3 为 RARP 请求，4 为 RARP 应答</li>
<li><strong>源硬件地址</strong>：n 个字节，n 由硬件地址长度得到，一般为发送方 MAC 地址</li>
<li><strong>源协议地址</strong>：m 个字节，m 由协议地址长度得到，一般为发送方 IP 地址</li>
<li><strong>目标硬件地址</strong>：n 个字节，n 由硬件地址长度得到，一般为目标 MAC 地址</li>
<li><strong>目标协议地址</strong>：m 个字节，m 由协议地址长度得到，一般为目标 IP 地址</li>
</ul>
</li>
</ul>
<h3 id="工作原理">工作原理</h3>
<ol>
<li>每台主机都会在自己的 ARP 缓冲区 (ARP Cache)中建立一个 ARP 列表，表示 IP 地址和 MAC 地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址，如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的<strong>广播包</strong>（即将目的硬件地址设置为全 1），查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</li>
<li>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP <strong>单播</strong>响应数据包，告诉对方自己是它需要查找的 MAC 地址；</li>
<li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ol>
<h3 id="代理-arp">代理 ARP</h3>
<p>代理 ARP 是指当 ARP 目标不在同一网段时，网关会拦截该 ARP 请求，然后把自己的 MAC 地址回复给请求者：</p>
<p><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
但是需要网关需要满足：</p>
<ul>
<li>开启代理 ARP 功能</li>
<li>有目标的路由信息</li>
</ul>
<p>假如不存在网关但使用代理 ARP，则情况如下：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
<p>存在网关的情况下，使用正常 ARP，则情况如下：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
<p>总结而言：</p>
<ul>
<li>没有网关（采用代理 ARP）时：跨网段访问谁，就问谁的 MAC</li>
<li>有网关（采用正常 ARP）时：跨网段访问谁，都问网关的 MAC</li>
<li>无论使用哪种 ARP，跨网段通信时，发送方请求得到的目标 MAC 地址都是网关 MAC</li>
</ul>
<h2 id="rarp">RARP</h2>
<p>RARP（Reverse Address Resolution Protocol，逆地址解析协议），顾名思义，用于将 MAC 地址映射为网络层地址（例如 IP 地址），用于给 MAC 地址分配 IP 地址（通常在需要远程启动(类似无盘工作站)的系统中使用）。其因为较限于 IP 地址的运用以及其他的一些缺点，因此渐为更新的 BOOTP 或 DHCP 所取代。</p>
<p>RARP 使用与 ARP 相同的报头结构，只是其中的操作码有所区别，见上文。</p>
<h3 id="工作原理-1">工作原理</h3>
<ol>
<li>发送主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址；</li>
<li>本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址；</li>
<li>如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用；</li>
<li>如果不存在，RARP 服务器对此不做任何的响应；</li>
<li>源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。</li>
</ol>
<h2 id="安全问题">安全问题</h2>
<h3 id="arp-欺骗">ARP 欺骗</h3>
<p>源主机通过 ARP 协议在局域网内发送广播请求包，按照 ARP 协议的设想应该是对应主机回复，但如果攻击者进行回复，源主机依然会选择相信。这是由 ARP 协议的不验证引起的，它不验证对方是否是所声称 IP 地址的主机。同时，由于 ARP 协议是一种无状态协议，既不验证应答者的身份，也不判断是否发送过 ARP 请求，当收到一条 ARP 应答报文时，它就会更新 ARP 应答缓存表。因此，攻击者甚至可以<strong>主动</strong>向源主机发送 ARP 响应包，迫使源主机更新其 ARP 缓存表。</p>
<p>对此，一个简单的方法是使用静态绑定地址，但是此方法维护起来较为麻烦。</p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] Computer Networking A Top-Down Approach</li>
<li>[2] <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">地址解析协议</a></li>
<li>[3] <a href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">逆地址解析协议</a></li>
<li>[4] <a href="https://www.jianshu.com/p/782f3b60eb19" target="_blank" rel="noopener noreferrer">网络协议补完计划&ndash;ARP 协议和 RARP 协议</a></li>
</ul>]]></description>
</item><item>
    <title>OpenWRT overlay 空间扩容</title>
    <link>https://www.techkoala.top/openwrt_resize/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_resize/</guid>
    <description><![CDATA[<blockquote>
<p>安装 AdguardHome 运行几天后，可怜的剩余空间被日志耗尽，不得不对 OpenWRT overlay 进行扩容，记录一下</p>
</blockquote>
<h2 id="什么是-overlay">什么是 overlay</h2>
<p><code>OpenWRT</code> 一般使用的文件系统是 <code>SquashFS</code> ，这个文件系统的特点就是：<strong>只读</strong>。</p>
<p>一个只读的文件系统要怎么做到保存设置和安装软件的呢？这里就是使用 <code>/overlay</code> 的分区，<code>overlay</code> 顾名思义就是覆盖在上面一层的意思。虽然原来的文件不能修改，但把修改的部分放在 <code>overlay</code> 分区上，然后映射到原来的位置，读取的时候就可以读到修改过的文件了。</p>
<p>为什么要用这么复杂的方法呢？ <code>OpenWRT</code> 当然也可以使用 <code>EXT4</code> 文件系统，但使用 <code>SquashFS + overlay</code> 的方式有一定的优点。</p>
<ul>
<li><code>SquashFS</code> 是经过压缩的，在路由器这种小型 <code>ROM</code> 的设备可以放下更多的东西。</li>
<li><code>OpenWRT</code> 的恢复出厂设置也要依赖于这个方式。在你重置的时候，它只需要把 <code>overlay</code> 分区清空就可以了，一切都回到了刚刷进去的样子。</li>
</ul>
<p>如果是 <code>EXT4</code> 文件系统，就只能够备份每个修改的文件，在恢复出厂设置的时候复制回来，十分复杂。</p>
<p>当然，<code>SquashFS + overlay</code> 也有它的缺点：</p>
<ul>
<li>修改文件的时候会占用更多的空间。首先你不能够删除文件，因为删除文件实际上是在 <code>overlay</code> 分区中写入一个删除的标识，反而占用更多的空间。</li>
<li>另外在修改文件的时候相当于增加了一份文件的副本，占用了双份的空间。</li>
</ul>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/overlay.webp" title="/images/Network/OpenWRT_overlay/overlay.webp" data-thumbnail="/images/Network/OpenWRT_overlay/overlay.webp" data-sub-html="<h2>overlay 示意图</h2>">
        
    </a><figcaption class="image-caption">overlay 示意图</figcaption>
    </figure>
<h2 id="创建新分区">创建新分区</h2>
<p>首先，需要创建一个新的分区，这里使用的是 <code>cfdisk</code></p>
<p>如果此前没有安装，首先使用下列命令进行安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ opkg update
$ opkg install cfdisk
</code></pre></td></tr></table>
</div>
</div><p>然后输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cfdisk
</code></pre></td></tr></table>
</div>
</div><p>打开磁盘管理界面：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/cfdisk.webp" title="/images/Network/OpenWRT_overlay/cfdisk.webp" data-thumbnail="/images/Network/OpenWRT_overlay/cfdisk.webp" data-sub-html="<h2>磁盘界面</h2>">
        
    </a><figcaption class="image-caption">磁盘界面</figcaption>
    </figure>
<p>这里可以看到，目前一共有两个已有分区，现在新建一个分区：</p>
<p>选中 <code>Free Space</code>，再选中 <code>New</code>，输入需要的大小，比如 5G。</p>
<p>接着选择 <code>primary</code></p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/primary.webp" title="/images/Network/OpenWRT_overlay/primary.webp" data-thumbnail="/images/Network/OpenWRT_overlay/primary.webp" data-sub-html="<h2>选择主分区</h2>">
        
    </a><figcaption class="image-caption">选择主分区</figcaption>
    </figure>
<p>选择 <code>Write</code>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/write.webp" title="/images/Network/OpenWRT_overlay/write.webp" data-thumbnail="/images/Network/OpenWRT_overlay/write.webp" data-sub-html="<h2>写入更改</h2>">
        
    </a><figcaption class="image-caption">写入更改</figcaption>
    </figure></p>
<p>输入 <code>yes</code>，完成新分区的创建</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/yes.webp" title="/images/Network/OpenWRT_overlay/yes.webp" data-thumbnail="/images/Network/OpenWRT_overlay/yes.webp" data-sub-html="<h2>确认</h2>">
        
    </a><figcaption class="image-caption">确认</figcaption>
    </figure>
<h2 id="格式化分区">格式化分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkfs.ext4 /dev/sda3
</code></pre></td></tr></table>
</div>
</div><p>格式化分区</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/format.webp" title="/images/Network/OpenWRT_overlay/format.webp" data-thumbnail="/images/Network/OpenWRT_overlay/format.webp" data-sub-html="<h2>格式化分区</h2>">
        
    </a><figcaption class="image-caption">格式化分区</figcaption>
    </figure>
<h2 id="挂载新分区">挂载新分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mount /dev/sda3 /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><p>挂载分区</p>
<h2 id="转移到新分区">转移到新分区</h2>
<p>然后将原来 <code>upper</code> 层中的数据复制到新的分区中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">cp -r /overlay/* /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><h2 id="web-界面配置修改">Web 界面配置修改</h2>
<p>进入 <code>OpenWRT</code> Web 界面的<code>挂载点</code>对配置进行修改：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/openwrt.webp" title="/images/Network/OpenWRT_overlay/openwrt.webp" data-thumbnail="/images/Network/OpenWRT_overlay/openwrt.webp" data-sub-html="<h2>Web 界面</h2>">
        
    </a><figcaption class="image-caption">Web 界面</figcaption>
    </figure>
<p>在挂载点处点击添加然后配置如下：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/mountpoint.webp" title="/images/Network/OpenWRT_overlay/mountpoint.webp" data-thumbnail="/images/Network/OpenWRT_overlay/mountpoint.webp" data-sub-html="<h2>挂载点配置</h2>">
        
    </a><figcaption class="image-caption">挂载点配置</figcaption>
    </figure>
<h2 id="完成">完成</h2>
<p>到这一步，只需要重启 <code>OpenWRT</code> 即可成功扩容。到 <code>系统 -&gt; 软件包</code> 可以看到变大后的空间容量。</p>
<h2 id="自动挂载">自动挂载</h2>
<p>分区默认会在 <code>OpenWRT</code> 重启后会自动挂载，如果遇到没有挂载的情况，需要编辑 <code>/etc/rc.local</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ vim /etc/rc.local
</code></pre></td></tr></table>
</div>
</div><p>在 <code>exit 0</code> 之前加入一行 <code>mount /dev/sda3 /overlay</code> 即可。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://blog.msm.moe/mount-sd-card-to-overlay-on-openwrt/" target="_blank" rel="noopener noreferrer">OpenWrt 下把 SD 卡挂载到 /overlay ，扩大软件空间</a></p>
</li>
<li>
<p>[2] <a href="https://www.jianshu.com/p/8179b19cfa6d" target="_blank" rel="noopener noreferrer">软路由 LEDE 折腾 overlay 分区扩容之路</a></p>
</li>
<li>
<p>[3] <a href="https://www.vediotalk.com/archives/13889" target="_blank" rel="noopener noreferrer">ESXI 下 OpenWrt 扩容 Overlay,增加安装插件空间</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>单独编译 OpenWRT ipk 插件</title>
    <link>https://www.techkoala.top/openwrt_compile_single_ipk/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_compile_single_ipk/</guid>
    <description><![CDATA[<blockquote>
<p>为 OpenWRT 编译单独的 ipk 插件</p>
</blockquote>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">必须先完整编译一次固件才能单独编译 ipk</div>
        </div>
    </div>
<p>当需要单独更新 OpenWRT 某个插件或者需要增加安装某个插件的时候，可以单独编译对应的 ipk 插件进行安装，而不必编译整个系统。</p>
<h3 id="下载源码">下载源码</h3>
<p>使用 <code>git clone</code> 对应的源码插件到下面的文件夹中</p>
<h3 id="存放路径">存放路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/package
</code></pre></td></tr></table>
</div>
</div><h3 id="配置">配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make menuconfig
</code></pre></td></tr></table>
</div>
</div><p>然后进入对应的子菜单中找到对应插件按 <M> 表示选中插件，但不编译进固件。</p>
<h3 id="编译">编译</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make package/xxxxx/compile <span class="nv">V</span><span class="o">=</span><span class="m">99</span>
</code></pre></td></tr></table>
</div>
</div><p>xxxxx 就是你需要单独编译的程序。</p>
<h3 id="ipk-生成路径">ipk 生成路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/bin/packages/x86_64/xxxx
</code></pre></td></tr></table>
</div>
</div><h3 id="上传-ipk-至路由器">上传 ipk 至路由器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scp xxxxxxx.ipk root@192.168.1.1:/tmp
</code></pre></td></tr></table>
</div>
</div><h3 id="安装">安装</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">opkg install /tmp/xxxxx.ipk
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>常用 DNS 服务器</title>
    <link>https://www.techkoala.top/dns_list/</link>
    <pubDate>Fri, 21 Aug 2020 18:44:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_list/</guid>
    <description><![CDATA[<blockquote>
<p>列举国内外常见的 DNS，方便替换使用</p>
</blockquote>
<h2 id="ipv4">IPv4</h2>
<h3 id="国内">国内</h3>
<h4 id="知名-dns-服务">知名 DNS 服务</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>114 常规 DNS</td>
<td>114.114.114.114</td>
<td>114.114.115.115</td>
</tr>
<tr>
<td>114 拦截钓鱼病毒木马网站</td>
<td>114.114.114.119</td>
<td>114.114.115.119</td>
</tr>
<tr>
<td>114 拦截色情网站</td>
<td>114.114.114.110</td>
<td>114.114.115.110</td>
</tr>
<tr>
<td>阿里 AliDNS</td>
<td>223.5.5.5</td>
<td>223.6.6.6</td>
</tr>
<tr>
<td>百度 BaiduDNS</td>
<td>180.76.76.76</td>
<td></td>
</tr>
<tr>
<td>DNSPod DNS+</td>
<td>119.29.29.29</td>
<td>182.254.116.116</td>
</tr>
<tr>
<td>CNNIC SDNS</td>
<td>1.2.4.8</td>
<td>210.2.4.8</td>
</tr>
<tr>
<td>oneDNS</td>
<td>117.50.11.11</td>
<td>52.80.66.66</td>
</tr>
<tr>
<td>DNS 派电信/移动/铁通</td>
<td>101.226.4.6</td>
<td>218.30.118.6</td>
</tr>
<tr>
<td>DNS 派联通</td>
<td>123.125.81.6</td>
<td>140.207.198.6</td>
</tr>
</tbody>
</table>
<h4 id="全国各地电信-dns-服务器-ip-地址">全国各地电信 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>安徽电信 DNS</td>
<td>61.132.163.68</td>
<td>202.102.213.68</td>
</tr>
<tr>
<td>北京电信 DNS</td>
<td>219.141.136.10</td>
<td>219.141.140.10</td>
</tr>
<tr>
<td>重庆电信 DNS</td>
<td>61.128.192.68</td>
<td>61.128.128.68</td>
</tr>
<tr>
<td>福建电信 DNS</td>
<td>218.85.152.99</td>
<td>218.85.157.99</td>
</tr>
<tr>
<td>甘肃电信 DNS</td>
<td>202.100.64.68</td>
<td>61.178.0.93</td>
</tr>
<tr>
<td>广东电信 DNS</td>
<td>202.96.128.86</td>
<td>202.96.128.166</td>
</tr>
<tr>
<td></td>
<td>202.96.134.33</td>
<td>202.96.128.68</td>
</tr>
<tr>
<td>广西电信 DNS</td>
<td>202.103.225.68</td>
<td>202.103.224.68</td>
</tr>
<tr>
<td>贵州电信 DNS</td>
<td>202.98.192.67</td>
<td>202.98.198.167</td>
</tr>
<tr>
<td>河南电信 DNS</td>
<td>222.88.88.88</td>
<td>222.85.85.85</td>
</tr>
<tr>
<td>黑龙江电信</td>
<td>219.147.198.230</td>
<td>219.147.198.242</td>
</tr>
<tr>
<td>湖北电信 DNS</td>
<td>202.103.24.68</td>
<td>202.103.0.68</td>
</tr>
<tr>
<td>湖南电信 DNS</td>
<td>222.246.129.80</td>
<td>59.51.78.211</td>
</tr>
<tr>
<td>江苏电信 DNS</td>
<td>218.2.2.2</td>
<td>218.4.4.4</td>
</tr>
<tr>
<td></td>
<td>61.147.37.1</td>
<td>218.2.135.1</td>
</tr>
<tr>
<td>江西电信 DNS</td>
<td>202.101.224.69</td>
<td>202.101.226.68</td>
</tr>
<tr>
<td>内蒙古电信</td>
<td>219.148.162.31</td>
<td>222.74.39.50</td>
</tr>
<tr>
<td>山东电信 DNS</td>
<td>219.146.1.66</td>
<td>219.147.1.66</td>
</tr>
<tr>
<td>陕西电信 DNS</td>
<td>218.30.19.40</td>
<td>61.134.1.4</td>
</tr>
<tr>
<td>上海电信 DNS</td>
<td>202.96.209.133</td>
<td>116.228.111.118</td>
</tr>
<tr>
<td></td>
<td>202.96.209.5</td>
<td>180.168.255.118</td>
</tr>
<tr>
<td>四川电信 DNS</td>
<td>61.139.2.69</td>
<td>218.6.200.139</td>
</tr>
<tr>
<td>天津电信 DNS</td>
<td>219.150.32.132</td>
<td>219.146.0.132</td>
</tr>
<tr>
<td>云南电信 DNS</td>
<td>222.172.200.68</td>
<td>61.166.150.123</td>
</tr>
<tr>
<td>浙江电信 DNS</td>
<td>202.101.172.35</td>
<td>61.153.177.196</td>
</tr>
<tr>
<td></td>
<td>61.153.81.75</td>
<td>60.191.244.5</td>
</tr>
</tbody>
</table>
<h4 id="全国各地联通-dns-服务器-ip-地址">全国各地联通 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京联通 DNS</td>
<td>123.123.123.123</td>
<td>123.123.123.124</td>
</tr>
<tr>
<td></td>
<td>202.106.0.20</td>
<td>202.106.195.68</td>
</tr>
<tr>
<td>重庆联通 DNS</td>
<td>221.5.203.98</td>
<td>221.7.92.98</td>
</tr>
<tr>
<td>广东联通 DNS</td>
<td>210.21.196.6</td>
<td>221.5.88.88</td>
</tr>
<tr>
<td>河北联通 DNS</td>
<td>202.99.160.68</td>
<td>202.99.166.4</td>
</tr>
<tr>
<td>河南联通 DNS</td>
<td>202.102.224.68</td>
<td>202.102.227.68</td>
</tr>
<tr>
<td>黑龙江联通</td>
<td>202.97.224.69</td>
<td>202.97.224.68</td>
</tr>
<tr>
<td>吉林联通 DNS</td>
<td>202.98.0.68</td>
<td>202.98.5.68</td>
</tr>
<tr>
<td>江苏联通 DNS</td>
<td>221.6.4.66</td>
<td>221.6.4.67</td>
</tr>
<tr>
<td>内蒙古联通</td>
<td>202.99.224.68</td>
<td>202.99.224.8</td>
</tr>
<tr>
<td>山东联通 DNS</td>
<td>202.102.128.68</td>
<td>202.102.152.3</td>
</tr>
<tr>
<td></td>
<td>202.102.134.68</td>
<td>202.102.154.3</td>
</tr>
<tr>
<td>山西联通 DNS</td>
<td>202.99.192.66</td>
<td>202.99.192.68</td>
</tr>
<tr>
<td>陕西联通 DNS</td>
<td>221.11.1.67</td>
<td>221.11.1.68</td>
</tr>
<tr>
<td>上海联通 DNS</td>
<td>210.22.70.3</td>
<td>210.22.84.3</td>
</tr>
<tr>
<td>四川联通 DNS</td>
<td>119.6.6.6</td>
<td>124.161.87.155</td>
</tr>
<tr>
<td>天津联通 DNS</td>
<td>202.99.104.68</td>
<td>202.99.96.68</td>
</tr>
<tr>
<td>浙江联通 DNS</td>
<td>221.12.1.227</td>
<td>221.12.33.227</td>
</tr>
<tr>
<td>辽宁联通 DNS</td>
<td>202.96.69.38</td>
<td>202.96.64.68</td>
</tr>
</tbody>
</table>
<h4 id="全国各地移动-dns-服务器-ip-地址">全国各地移动 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>江苏移动 DNS</td>
<td>221.131.143.69</td>
<td>112.4.0.55</td>
</tr>
<tr>
<td>安徽移动 DNS</td>
<td>211.138.180.2</td>
<td>211.138.180.3</td>
</tr>
<tr>
<td>山东移动 DNS</td>
<td>218.201.96.130</td>
<td>211.137.191.26</td>
</tr>
</tbody>
</table>
<h3 id="香港地区">香港地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>香港宽频 DNS</td>
<td>203.80.96.10</td>
<td></td>
</tr>
<tr>
<td>和记环球电讯 DNS</td>
<td>202.45.84.58</td>
<td>202.45.84.59</td>
</tr>
<tr>
<td>Pacific SuperNet DNS</td>
<td>202.14.67.4</td>
<td>202.14.67.14</td>
</tr>
</tbody>
</table>
<h3 id="台湾地区">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信 DNS</td>
<td>168.95.1.1</td>
<td>168.95.192.1</td>
</tr>
<tr>
<td>数位联合电信 DNS</td>
<td>139.175.252.16</td>
<td>139.175.55.244</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>101.101.101.101</td>
<td>101.102.103.104</td>
</tr>
</tbody>
</table>
<h3 id="韩国">韩国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>KT olleh DNS</td>
<td>168.126.63.1</td>
<td>168.126.63.2</td>
</tr>
<tr>
<td>SK Broadband DNS</td>
<td>210.220.163.82</td>
<td>219.250.36.130</td>
</tr>
<tr>
<td>LG U+ DNS</td>
<td>164.124.101.2</td>
<td>203.248.252.2</td>
</tr>
<tr>
<td></td>
<td>164.124.107.9</td>
<td>203.248.242.2</td>
</tr>
</tbody>
</table>
<h3 id="美国">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cloudflare DNS</td>
<td>1.1.1.1</td>
<td>1.0.0.1</td>
</tr>
<tr>
<td>Google DNS</td>
<td>8.8.8.8</td>
<td>8.8.4.4</td>
</tr>
<tr>
<td>IBM Quad9</td>
<td>9.9.9.9</td>
<td>149.112.112.112</td>
</tr>
<tr>
<td>DNS.SB</td>
<td>185.222.222.222</td>
<td>185.184.222.222</td>
</tr>
<tr>
<td>OpenDNS</td>
<td>208.67.222.222</td>
<td>208.67.220.220</td>
</tr>
<tr>
<td>V2EX DNS</td>
<td>199.91.73.222</td>
<td>178.79.131.110</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>74.82.42.42</td>
<td>66.220.18.42</td>
</tr>
</tbody>
</table>
<h3 id="其他地区">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>77.88.8.8</td>
<td>77.88.8.1</td>
</tr>
<tr>
<td>俄罗斯 SafeDNS</td>
<td>195.46.39.39</td>
<td>195.46.39.40</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>84.200.69.80</td>
<td>84.200.70.40</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>77.109.148.136</td>
<td>77.109.148.137</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>91.239.100.100</td>
<td>89.233.43.71</td>
</tr>
<tr>
<td>荷兰 Freenom World Public DNS</td>
<td>80.80.80.80</td>
<td>80.80.81.81</td>
</tr>
</tbody>
</table>
<h2 id="ipv6">IPv6</h2>
<h3 id="国内-1">国内</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>百度</td>
<td>2400:da00::6666</td>
<td></td>
</tr>
<tr>
<td>阿里</td>
<td>2400:3200::1</td>
<td>2400:3200:baba::1</td>
</tr>
<tr>
<td>CNNIC</td>
<td>2001:dc7:1000::1</td>
<td></td>
</tr>
<tr>
<td>下一代互联网北京研究中心</td>
<td>240C::6666</td>
<td>240C::6644</td>
</tr>
</tbody>
</table>
<h4 id="高校">高校</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京邮电大学</td>
<td>2001:da8:202:10::36</td>
<td>2001:da8:202:10::37</td>
</tr>
<tr>
<td>上海交通大学</td>
<td>2001:da8:8000:1:202:120:2:100</td>
<td>2001:da8:8000:1:202:120:2:101</td>
</tr>
<tr>
<td>中科院网络信息中心</td>
<td>2001:cc0:2fff:1::6666</td>
<td></td>
</tr>
<tr>
<td>北京交通大学</td>
<td>2001:da8:205:2060::188</td>
<td></td>
</tr>
<tr>
<td>清华大学</td>
<td>2001:da8:ff:305:20c:29ff:fe1f:a92a</td>
<td></td>
</tr>
<tr>
<td>清华大学 TUNA 协会</td>
<td>2001:da8::666</td>
<td></td>
</tr>
<tr>
<td>北京科技大学</td>
<td>2001:da8:208:10::6</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="台湾地区-1">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信</td>
<td>2001:b000:168::1</td>
<td>2001:b000:168::2</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>2001:de4::101</td>
<td>2001:de4::102</td>
</tr>
</tbody>
</table>
<h3 id="美国-1">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GOOGLE</td>
<td>2001:4860:4860::8888</td>
<td>2001:4860:4860::8844</td>
</tr>
<tr>
<td>CloudFlare DNS</td>
<td>2606:4700:4700::1111</td>
<td>2606:4700:4700::1001</td>
</tr>
<tr>
<td>IBM</td>
<td>2620:fe::fe</td>
<td>2620:fe::9</td>
</tr>
<tr>
<td>Cisco OpenDNS</td>
<td>2620:0:ccc::2</td>
<td>2620:0:ccd::2</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>2001:470:20::2</td>
<td>2001:470:0:9d::2</td>
</tr>
<tr>
<td>Verisign Public DNS</td>
<td>2620:74:1b::1:1</td>
<td>2620:74:1c::2:2</td>
</tr>
<tr>
<td>Neustar Recursive DNS</td>
<td>2610:a1:1018::1</td>
<td>2610:a1:1019::1</td>
</tr>
</tbody>
</table>
<h3 id="其他地区-1">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>2a02:6b8::feed:0ff</td>
<td>2a02:6b8:0:1::feed:0ff</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>2001:1608:10:25::1c04:b12f</td>
<td>2001:1608:10:25::9249:d69b</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>2001:1620:2078:136::</td>
<td>2001:1620:2078:137::</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>2001:67c:28a4::</td>
<td>2a01:3a0:53:53::</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://www.iplaysoft.com/public-dns.html" target="_blank" rel="noopener noreferrer">全球免费公共 dns 解析服务器 ip 地址列表推荐 (解决无法上网/加速/防劫持)</a></p>
</li>
<li>
<p>[2] <a href="http://ip.cn/dns.html" target="_blank" rel="noopener noreferrer">公共 dns 服务器 ip 地址</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>网络分析工具：NetCat</title>
    <link>https://www.techkoala.top/netcat/</link>
    <pubDate>Wed, 19 Aug 2020 23:15:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/netcat/</guid>
    <description><![CDATA[<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-sub-html="<h2>网络瑞士军刀 —— NetCat</h2>">
        
    </a><figcaption class="image-caption">网络瑞士军刀 —— NetCat</figcaption>
    </figure>
<h2 id="什么是-netcat">什么是 NetCat</h2>
<p>简单来说，NetCat (nc) 是一个命令行工具，能够让你很方便、很灵活地操纵 <code>传输层协议</code>（TCP ＆ UDP）</p>
<p>nc 可以在两台设备上面相互交互，即<code>侦听模式</code>/<code>传输模式</code></p>
<p>nc 包含以下主要功能：</p>
<ul>
<li>Telnet 功能</li>
<li>获取 banner 信息</li>
<li>传输文本信息</li>
<li>传输文件 / 目录</li>
<li>加密传输文件，默认不加密</li>
<li>远程控制</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆硬盘</li>
</ul>
<h2 id="使用-netcat">使用 NetCat</h2>
<p>一般来说，nc 的命令行包括如下几个部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc 命令选项 主机 端口
</code></pre></td></tr></table>
</div>
</div><h3 id="命令选项">命令选项</h3>
<blockquote>
<p>本文内容基于 OpenBSD 社区的变种（也叫 OpenBSD netcat，部分命令与原版有差异。 ）</p>
</blockquote>
<p>下面列举了一些常用选项，更多选项参见 <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreferrer">OpenBSD manual page</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">选项	   是否有 “选项值”	   说明
-h	   NO	           输出 nc 的帮助
-v	   NO	           在网络通讯时，显示详细的输出信息
-n	   NO	           对命令行中的主机，不进行域名解析，如果主机是 IP 地址，需要用该选项
-p	  YES	           指定端口号
-l	  NO	           开启监听模式，nc 作为服务端，如不加，nc 默认作为客户端
-u	  NO	           使用 UDP 协，如不加该选项，默认是 TCP 协议
-w	  YES	           设置连接的超时间隔（N 秒）
-q	  YES	           让 nc 延时（N 秒）再退出
-z	  NO	           开启 zero-I/O 模式，该选项仅用于端口扫描
-k	  NO	           配合 -l 选项使用，可以重复接受客户端连接
-X	  YES	           指定代理的类型
-x	  YES	           以 IP:port 的格式指定代理
-d    NO               后台模式
</code></pre></td></tr></table>
</div>
</div><h3 id="主机">主机</h3>
<p>这部分可以没有，可以以 <code>IP 地址</code> 形式表示，也可以以 <code>域名</code> 形式表示。</p>
<h3 id="端口">端口</h3>
<p>这部分可以没有，可以是单个端口，可以是端口范围。</p>
<h2 id="常用使用场景示例">常用使用场景示例</h2>
<h3 id="测试某个远程主机的监听端口是否可达">测试某个远程主机的监听端口是否可达</h3>
<p>经常有这种需求，要判断某个主机的监听端口是否能连上。导致监听端口无法连接，通常有两种原因：</p>
<ol>
<li>监听端口没开启</li>
<li>监听端口虽然开启，但是被防火墙阻拦了</li>
</ol>
<p>对第 1 个原因，（如果你能在该主机上运行命令）可以直接用 <code>netstat</code> 这个命令查看监听端口是否开启；但对于第 2 个原因，<code>netstat</code> 就用不上了，这时候就可以用 nc 来帮你搞定。</p>
<p>用如下命令可以测试某个 IP 地址上的某个监听端口是否开启:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv ip port
</code></pre></td></tr></table>
</div>
</div><p><strong>注：</strong>　默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加 <code>-w</code> 选项，设置一个比较小的超时值。在下面的例子中，超时值设为 3 秒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv -w <span class="m">3</span> ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="判断防火墙是否允许-or-禁止某个端口">判断防火墙是否允许 or 禁止某个端口</h3>
<p>假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何验证自己的配置生效？</p>
<p>为了叙述方便，设想如下场景：
有两台主机 ——<code>主机 C</code> 充当客户端，<code>主机 S</code> 充当服务端。
然后要判断<code>主机 S</code> 上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。</p>
<p>在<code>主机 S</code> 上运行 nc，让它在 8080 端口，命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -lv -p <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 “主机 C” 上运行 nc，测试 “主机 S” 上的 8080 端口是否可达</p>
<p><strong>注：</strong>　在默认情况下，nc 开启 listen 模式充当服务端，在接受<strong>第一次</strong>客户端连接之后，就会把监听端口关闭。如果你想要让 nc 始终监听模式，使之能<strong>重复</strong>接受客户端发起的连接，可以追加 <code>-k</code> 选项。</p>
<h3 id="端口扫描">端口扫描</h3>
<p>下面这个命令，用来扫描的端口范围从 1 到 1024</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024
</code></pre></td></tr></table>
</div>
</div><p>选项 -z
是指开启 <code>zero-I/O 模式</code>。该模式 nc 只判断某个监听端口是否能连上，连上后<strong>不</strong>与对端进行数据通讯。</p>
<p>**注：**端口扫描的时候，<code>-v</code> 选项会把成功/失败的结果统统打印出来。通常关注的都是 “扫描成功” 的那些端口。因此，可以用可以配合使用 <code>grep</code> 过滤一下，只打印扫出来的端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024  2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> grep succeeded
</code></pre></td></tr></table>
</div>
</div><p>此外，由于 <code>-v</code> 选项产生的输出位于 <code>stderr</code>，上述命令中的 <code>2&gt;&amp;1</code> 用来把 <code>stderr</code> 合并到 <code>stdout</code>。</p>
<p><strong>另：</strong> nc 默认超时较大，导致扫描速度较慢。建议根据网络情况合理设置超时值，加快扫描速度。</p>
<h3 id="探测服务器类型和软件版本">探测服务器类型和软件版本</h3>
<p>如果某个服务器运行了 SSH 服务端，那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> -n ip <span class="m">22</span>
OR
<span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> domain <span class="m">22</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="端口转发">端口转发</h3>
<p>用 nc 进行端口转发，需要运行两个 nc 进程，一个充当<code>服务端</code>，另一个是<code>客户端</code>，然后用管道让把两个进程的<code>标准输入输出``交叉配对</code>。所谓的<code>交叉配对</code>就是——每一个 nc 进程的<code>标准输出</code>都对接到另一个 nc 进程的<code>标准输入</code>。如此一来，就可以完美地建立双向通讯。</p>
<p>步骤 1：创建命名管道</p>
<p>用下面这个简单的命令创建一个 “命名管道”，其名称叫做 nc_pipe</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mkfifo nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>步骤 2：同时启动两个 nc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p <span class="m">1234</span> &lt; nc_pipe <span class="p">|</span> nc 127.0.0.1 <span class="m">5678</span> &gt; nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。</p>
<h3 id="传输文件">传输文件</h3>
<p>为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端 B 主机运行如下命令
nc -l -p port &gt; file2

然后在发送端 A 主机运行如下命令
nc ip port &lt; file1
</code></pre></td></tr></table>
</div>
</div><p>两者端口号要相同</p>
<h3 id="远程备份整个磁盘">远程备份整个磁盘</h3>
<p>假设你要把 A 主机 <code>/dev/sda</code> 磁盘的原始数据整个复制到 B 主机的 <code>/dev/sdb</code> 磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端（B 主机）运行如下命令
nc -lp port <span class="p">|</span> dd <span class="nv">of</span><span class="o">=</span>/dev/sdb

然后在发送端 A 主机运行如下命令
dd <span class="k">if</span><span class="o">=</span>/dev/sda <span class="p">|</span> nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="远程控制">远程控制</h3>
<p>将 A 主机的 <code>bash</code> 发给 B 主机</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
nc -lp port -c bash

B:
nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="流媒体服务">流媒体服务</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
cat test.mp4 <span class="p">|</span> nc -lp port

B:
nc -nv ip port <span class="p">|</span> mplayer -vo x11 -cache <span class="m">4000</span>
</code></pre></td></tr></table>
</div>
</div><p>A 让 test.MP4 这个文件成为<code>流</code>的形式发送到 B，B 用 mplayer 播放，接收多少播放多少，指定缓存 4000bytes。</p>
<h3 id="信息收集">信息收集</h3>
<p>收集目标机上的进程信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p port &gt; ps.txt
将远程发送过来的内容保存在本地

Ps aux <span class="p">|</span>nc -nv ip port -q <span class="m">1</span>
标准输入完成后 delay 一秒钟，会发送到侦听端

</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreferrer">netcat manual page</a></p>
</li>
<li>
<p>[2] <a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html#head-15" target="_blank" rel="noopener noreferrer">扫盲 netcat（网猫）的 N 种用法 —— 从 “网络诊断” 到 “系统入侵”</a></p>
</li>
<li>
<p>[3] <a href="https://www.jianshu.com/p/cb26a0f6c622" target="_blank" rel="noopener noreferrer">NetCat 使用指南</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
