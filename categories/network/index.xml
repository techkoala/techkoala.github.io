<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Network - 分类 - TechKoala - Input/Output </title>
        <link>https://www.techkoala.top/categories/network/</link>
        <description>Network - 分类 - TechKoala - Input/Output </description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.top (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.top (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 20 Oct 2020 13:24:18 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/categories/network/" rel="self" type="application/rss+xml" /><item>
    <title>DNS 报文详解</title>
    <link>https://www.techkoala.top/dns/</link>
    <pubDate>Tue, 20 Oct 2020 13:24:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns/</guid>
    <description><![CDATA[<blockquote>
<p>本文主要讲解 DNS 的报文结构</p>
</blockquote>
<h2 id="dns-简介">DNS 简介</h2>
<p>简单来说 DNS 负责将我们熟知的域名翻译成 IP 地址，其相关定义由 RFC 1034 和 RFC 1035 给出。</p>
<p>为了更加的扩展性，DNS 由大量的服务器分层次进行组织的，大致来说分为：根 DNS 服务器、顶域名（TLD）DNS 服务器和权威 DNS 服务器。他们的层次结构如下图所示：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" data-sub-html="<h2>DNS 的层次结构</h2>">
        
    </a><figcaption class="image-caption">DNS 的层次结构</figcaption>
    </figure>
<p>关于 DNS 的工作过程及相关信息参见<a href="https://www.techkoala.top/dns_update/" target="_blank" rel="noopener noreffer">深入浅出 DNS 解析</a>，本文负责补充 DNS 报文结构。</p>
<h3 id="dns-报文结构">DNS 报文结构</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" data-sub-html="<h2>DNS 的报文结构</h2>">
        
    </a><figcaption class="image-caption">DNS 的报文结构</figcaption>
    </figure>
<ul>
<li>
<p>前 12 个字节为<strong>首部</strong>，包含：</p>
<ul>
<li>
<p><strong>标识符</strong>（2 字节），用于标识请求及其响应报文，区分不同的查询</p>
</li>
<li>
<p><strong>标志</strong>（2 字节），其中：</p>
<ul>
<li><strong>QR</strong>（1bit）：查询/响应标志，<code>0</code> 为查询，<code>1</code> 为响应</li>
<li><strong>opcode</strong>（4bit）：<code>0</code> 表示标准查询，<code>1</code> 表示反向查询，<code>2</code> 表示服务器状态请求，<code>[3,15]</code>为保留值</li>
<li><strong>AA</strong>（1bit）：表示授权回答，这个比特位在应答的时候才有意义，指出给出应答的服务器是查询域名的授权解析服务器</li>
<li><strong>TC</strong>（1bit）：表示可截断的，用来指出报文比允许的长度还要长，导致被截断;</li>
<li><strong>RD</strong>（1bit）：表示期望递归，这个比特位被<strong>请求</strong>设置，应答的时候使用的相同的值返回。如果设置了 RD，就建议域名服务器进行递归解析，递归查询的支持是可选的;</li>
<li><strong>RA</strong>（1bit）：表示可用递归，这个比特位在<strong>应答</strong>中设置或取消，用来代表服务器是否支持递归查询;</li>
<li><strong>rcode</strong>（4bit）：表示返回码
<ul>
<li><code>0</code> : 没有错误</li>
<li><code>1</code> : 报文格式错误(Format error) - 服务器不能理解请求的报文</li>
<li><code>2</code> : 服务器失败(Server failure) - 因为服务器的原因导致没办法处理这个请求</li>
<li><code>3</code> : 名字错误(Name Error) - 只有对授权域名解析服务器有意义，指出解析的域名不存在</li>
<li><code>4</code> : 没有实现(Not Implemented) - 域名服务器不支持查询类型</li>
<li><code>5</code> : 拒绝(Refused) - 服务器由于设置的策略拒绝给出应答.比如，服务器不希望对某些请求者给出应答，或者服务器不希望进行某些操作（比如区域传送 zone transfer）</li>
<li><code>[6,15]</code> : 保留值，暂未使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数量字段</strong>（8 字节）：每个区域 2 字节</p>
<ul>
<li><strong>Questions</strong> 表示查询问题区域节的数量</li>
<li><strong>Answers</strong> 表示回答区域的数量</li>
<li><strong>Authoritative namesversers</strong> 表示授权区域的数量</li>
<li><strong>Additional recoreds</strong> 表示附加区域的数量</li>
</ul>
</li>
<li>
<p><strong>问题</strong>（Questions）部分包括：</p>
<ul>
<li>查询的域名 8bit 为单位，长度不受限</li>
<li>查询的协议类型 16bit</li>
<li>查询的类 16bit</li>
</ul>
</li>
<li>
<p><strong>回答</strong>（Answers）/<strong>权威</strong>（Authoritys）/<strong>附加</strong>（Additionals）部分格式相同：</p>
<ul>
<li><strong>NAME</strong> 资源记录包含的域名.</li>
<li><strong>TYPE</strong> 表示 DNS 协议的类型.</li>
<li><strong>CLASS</strong> 表示 RDATA 的类.</li>
<li><strong>TTL</strong> 4 字节无符号整数表示资源记录可以缓存的时间。0 代表只能被传输，但是不能被缓存。</li>
<li><strong>RDLENGTH</strong> 2 个字节无符号整数表示 RDATA 的长度</li>
<li><strong>RDATA</strong> 不定长字符串来表示记录，格式根 TYPE 和 CLASS 有关。比如，TYPE 是 A，CLASS 是 IN，那么 RDATA 就是一个 4 个字节的 ARPA 网络地址。</li>
</ul>
</li>
</ul>
<h2 id="rrs-说明">RRs 说明</h2>
<p>每个 DNS 响应报文包含一条或者多条资源记录（resource records ，RRs），资源记录包含下列字段的 4 元组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">（Name，Value，Type，TTL）
</code></pre></td></tr></table>
</div>
</div><p>其中 TTL 表示生存时间，决定了资源记录应该从缓存中删除的时间。</p>
<ul>
<li>如果是 Type=A，Name 为主机名，Value 是对应的 IP 地址（如 bar.foo.com，xxx.xxx.xxx.xxx，A）</li>
<li>如果是 Type=NS，Name 为一个域（如 foo.com），Value 是知道如何获取该域中的主机 IP 地址的权威 DNS 服务器的主机名（如 foo.com，dns.foo.com，NS）</li>
<li>如果是 Type=CNAME，Value 是别名为 Name 的主机对应的规范主机名。（如 foo.com，relay1.bar.foo.com，CNAME）</li>
<li>如果是 Type=MX，Value 是别名为 Name 的邮件服务器对应的规范主机名。（如 foo.com，mail.bar.foo.com，MX）</li>
</ul>
<h2 id="实例">实例</h2>
<p>这里我们使用 WireShark 抓包实际看看，启动 WireShark 时可以设置捕获过滤器为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">udp port 53
</code></pre></td></tr></table>
</div>
</div><p>这样我们只抓取通过 UDP 53 端口的 DNS 请求，此外如果需要仅仅显示特定的 DNS 查询，还可以进一步应用显示过滤器，例如这里我们仅查看<code>www.techkoala.top</code>的查询记录，则显示过滤器设置为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dns.qry.name==www.techkoala.top
</code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" data-sub-html="<h2>16 进制表示</h2>">
        
    </a><figcaption class="image-caption">16 进制表示</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" data-sub-html="<h2>WireShark 中 DNS 请求报文及其结构</h2>">
        
    </a><figcaption class="image-caption">WireShark 中 DNS 请求报文及其结构</figcaption>
    </figure>
<p>可以看出</p>
<ul>
<li>标识为：0x0000cd13</li>
<li>这是一个请求报文，仅在 Questions 部分有值</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" data-sub-html="<h2>标志部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">标志部分各个字段的值</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" data-sub-html="<h2>查询部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">查询部分各个字段的值</figcaption>
    </figure>
<p>同时 WireShark 还贴心的告诉我们，响应报文的在总抓取包的编号为 10，方便我们快速找到请求报文对应的响应报文。</p>
<p><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" data-sub-html="<h2>16进制表示</h2>">
        
    </a><figcaption class="image-caption">16进制表示</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" data-sub-html="<h2>WireShark 中 DNS 响应报文及其结构</h2>">
        
    </a><figcaption class="image-caption">WireShark 中 DNS 响应报文及其结构</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" data-sub-html="<h2>标志部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">标志部分各个字段的值</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" data-sub-html="<h2>查询部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">查询部分各个字段的值</figcaption>
    </figure></p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] Computer Networking A Top-Down Approach</li>
<li>[2] <a href="https://juejin.im/post/6844903582441963527" target="_blank" rel="noopener noreffer">DNS 请求报文详解</a></li>
</ul>]]></description>
</item><item>
    <title>ARP &amp; RARP 详解</title>
    <link>https://www.techkoala.top/arp_rarp/</link>
    <pubDate>Fri, 16 Oct 2020 15:56:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/arp_rarp/</guid>
    <description><![CDATA[<blockquote>
<p>ARP 以及 RARP 如何工作？</p>
</blockquote>
<h2 id="为什么要有-mac-地址">为什么要有 MAC 地址？</h2>
<p>在说明 ARP 以及 RARP 之前，有必要首先说一下 MAC 地址的必要性。</p>
<p>引用《Computer Networking A Top-Down Approach》中的描述：</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>KEEPING THE LAYERS INDEPENDENT<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">There are several reasons why hosts and router interfaces have MAC addresses in addition to network-layer addresses. First, LANs are designed for arbitrary network-layer protocols, not just for IP and the Internet. If adapters were assigned IP addresses rather than “neutral” MAC addresses, then adapters would not easily be able to support other network-layer protocols (for example, IPX or DECnet). Second, if adapters were to use network-layer addresses instead of MAC addresses, the network-layer address would have to be stored in the adapter RAM and reconfigured every time the adapter was moved (or powered up). Another option is to not use any addresses in the adapters and have each adapter pass the data (typically, an IP datagram) of each frame it receives up the protocol stack. The network layer could then check for a matching network-layer address. One problem with this option is that the host would be interrupted by every frame sent on the LAN, including by frames that were destined for other hosts on the same broadcast LAN. In summary, in order for the layers to be largely independent building blocks in a network architecture, different layers need to have their own addressing scheme. We have now seen three types of addresses: host names for the application layer, IP addresses for the network layer, and
MAC addresses for the link layer.</div>
        </div>
    </div>
<p>简单来说：</p>
<ul>
<li>局域网不仅仅为 IP 和因特网设计，MAC 地址的“中立性”为各种网络层协议（比如 IPX 或者 DECnet)提供了灵活的施展空间</li>
<li>网络层地址往往是动态的，每次更换网络或者重启都需要对适配器进行重新配置</li>
<li>如果取消 MAC 地址，让适配器把收到的每帧都往上层传递，就会带来一个问题：主机会去处理局域网中的每个帧，即使这个帧不属于自己，这就带来了不必要的消耗。</li>
</ul>
<h2 id="arp">ARP</h2>
<p>一句话概括 ARP（Address Resolution Protocol，地址解析协议）的目的就是：负责将<strong>网络层地址</strong>（最常见的就是 IP 地址）解析为/映射到<strong>链路层地址</strong>（MAC 地址）。</p>
<h3 id="报文结构">报文结构</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" data-sub-html="<h2>ARP 包结构</h2>">
        
    </a><figcaption class="image-caption">ARP 包结构</figcaption>
    </figure>
<p>一般我们讨论以太网中的 ARP 报文时候，ARP 数据会被封装在以太网报文中，其中：</p>
<ul>
<li>
<p>以太网报文：</p>
<ul>
<li><strong>目标以太网地址</strong>：目标 MAC 地址，FF:FF:FF:FF:FF:FF （二进制全 1）为广播地址</li>
<li><strong>源以太网地址</strong>：发送方 MAC 地址</li>
<li><strong>帧类型</strong>：以太类型，<strong>ARP 为 0x0806</strong></li>
</ul>
</li>
<li>
<p>ARP 报文数据：</p>
<ul>
<li><strong>硬件类型</strong>：如以太网（0x0001）、分组无线网</li>
<li><strong>协议类型</strong>：如网际协议(IP)（0x0800）、IPv6（0x86DD）</li>
<li><strong>硬件地址长度</strong>：每种硬件地址的字节长度，一般为 6（以太网）</li>
<li><strong>协议地址长度</strong>：每种协议地址的字节长度，一般为 4（IPv4）</li>
<li><strong>操作码 OP</strong>：1 为 ARP 请求，2 为 ARP 应答，3 为 RARP 请求，4 为 RARP 应答</li>
<li><strong>源硬件地址</strong>：n 个字节，n 由硬件地址长度得到，一般为发送方 MAC 地址</li>
<li><strong>源协议地址</strong>：m 个字节，m 由协议地址长度得到，一般为发送方 IP 地址</li>
<li><strong>目标硬件地址</strong>：n 个字节，n 由硬件地址长度得到，一般为目标 MAC 地址</li>
<li><strong>目标协议地址</strong>：m 个字节，m 由协议地址长度得到，一般为目标 IP 地址</li>
</ul>
</li>
</ul>
<h3 id="工作原理">工作原理</h3>
<ol>
<li>每台主机都会在自己的 ARP 缓冲区 (ARP Cache)中建立一个 ARP 列表，表示 IP 地址和 MAC 地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址，如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的<strong>广播包</strong>（即将目的硬件地址设置为全 1），查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</li>
<li>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP <strong>单播</strong>响应数据包，告诉对方自己是它需要查找的 MAC 地址；</li>
<li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ol>
<h3 id="代理-arp">代理 ARP</h3>
<p>代理 ARP 是指当 ARP 目标不在同一网段时，网关会拦截该 ARP 请求，然后把自己的 MAC 地址回复给请求者：</p>
<p><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
但是需要网关需要满足：</p>
<ul>
<li>开启代理 ARP 功能</li>
<li>有目标的路由信息</li>
</ul>
<p>假如不存在网关但使用代理 ARP，则情况如下：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
<p>存在网关的情况下，使用正常 ARP，则情况如下：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
<p>总结而言：</p>
<ul>
<li>没有网关（采用代理 ARP）时：跨网段访问谁，就问谁的 MAC</li>
<li>有网关（采用正常 ARP）时：跨网段访问谁，都问网关的 MAC</li>
<li>无论使用哪种 ARP，跨网段通信时，发送方请求得到的目标 MAC 地址都是网关 MAC</li>
</ul>
<h2 id="rarp">RARP</h2>
<p>RARP（Reverse Address Resolution Protocol，逆地址解析协议），顾名思义，用于将 MAC 地址映射为网络层地址（例如 IP 地址），用于给 MAC 地址分配 IP 地址（通常在需要远程启动(类似无盘工作站)的系统中使用）。其因为较限于 IP 地址的运用以及其他的一些缺点，因此渐为更新的 BOOTP 或 DHCP 所取代。</p>
<p>RARP 使用与 ARP 相同的报头结构，只是其中的操作码有所区别，见上文。</p>
<h3 id="工作原理-1">工作原理</h3>
<ol>
<li>发送主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址；</li>
<li>本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址；</li>
<li>如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用；</li>
<li>如果不存在，RARP 服务器对此不做任何的响应；</li>
<li>源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。</li>
</ol>
<h2 id="安全问题">安全问题</h2>
<h3 id="arp-欺骗">ARP 欺骗</h3>
<p>源主机通过 ARP 协议在局域网内发送广播请求包，按照 ARP 协议的设想应该是对应主机回复，但如果攻击者进行回复，源主机依然会选择相信。这是由 ARP 协议的不验证引起的，它不验证对方是否是所声称 IP 地址的主机。同时，由于 ARP 协议是一种无状态协议，既不验证应答者的身份，也不判断是否发送过 ARP 请求，当收到一条 ARP 应答报文时，它就会更新 ARP 应答缓存表。因此，攻击者甚至可以<strong>主动</strong>向源主机发送 ARP 响应包，迫使源主机更新其 ARP 缓存表。</p>
<p>对此，一个简单的方法是使用静态绑定地址，但是此方法维护起来较为麻烦。</p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] Computer Networking A Top-Down Approach</li>
<li>[2] <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreffer">地址解析协议</a></li>
<li>[3] <a href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreffer">逆地址解析协议</a></li>
<li>[4] <a href="https://www.jianshu.com/p/782f3b60eb19" target="_blank" rel="noopener noreffer">网络协议补完计划&ndash;ARP 协议和 RARP 协议</a></li>
</ul>]]></description>
</item><item>
    <title>OpenWRT overlay 空间扩容</title>
    <link>https://www.techkoala.top/openwrt_resize/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_resize/</guid>
    <description><![CDATA[<blockquote>
<p>安装 AdguardHome 运行几天后，可怜的剩余空间被日志耗尽，不得不对 OpenWRT overlay 进行扩容，记录一下</p>
</blockquote>
<h2 id="什么是-overlay">什么是 overlay</h2>
<p><code>OpenWRT</code> 一般使用的文件系统是 <code>SquashFS</code> ，这个文件系统的特点就是：<strong>只读</strong>。</p>
<p>一个只读的文件系统要怎么做到保存设置和安装软件的呢？这里就是使用 <code>/overlay</code> 的分区，<code>overlay</code> 顾名思义就是覆盖在上面一层的意思。虽然原来的文件不能修改，但把修改的部分放在 <code>overlay</code> 分区上，然后映射到原来的位置，读取的时候就可以读到修改过的文件了。</p>
<p>为什么要用这么复杂的方法呢？ <code>OpenWRT</code> 当然也可以使用 <code>EXT4</code> 文件系统，但使用 <code>SquashFS + overlay</code> 的方式有一定的优点。</p>
<ul>
<li><code>SquashFS</code> 是经过压缩的，在路由器这种小型 <code>ROM</code> 的设备可以放下更多的东西。</li>
<li><code>OpenWRT</code> 的恢复出厂设置也要依赖于这个方式。在你重置的时候，它只需要把 <code>overlay</code> 分区清空就可以了，一切都回到了刚刷进去的样子。</li>
</ul>
<p>如果是 <code>EXT4</code> 文件系统，就只能够备份每个修改的文件，在恢复出厂设置的时候复制回来，十分复杂。</p>
<p>当然，<code>SquashFS + overlay</code> 也有它的缺点：</p>
<ul>
<li>修改文件的时候会占用更多的空间。首先你不能够删除文件，因为删除文件实际上是在 <code>overlay</code> 分区中写入一个删除的标识，反而占用更多的空间。</li>
<li>另外在修改文件的时候相当于增加了一份文件的副本，占用了双份的空间。</li>
</ul>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/overlay.webp" title="/images/Network/OpenWRT_overlay/overlay.webp" data-thumbnail="/images/Network/OpenWRT_overlay/overlay.webp" data-sub-html="<h2>overlay 示意图</h2>">
        
    </a><figcaption class="image-caption">overlay 示意图</figcaption>
    </figure>
<h2 id="创建新分区">创建新分区</h2>
<p>首先，需要创建一个新的分区，这里使用的是 <code>cfdisk</code></p>
<p>如果没有，首先使用下列命令进行安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ opkg install cfdisk
</code></pre></td></tr></table>
</div>
</div><p>输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cfdisk
</code></pre></td></tr></table>
</div>
</div><p>打开磁盘管理界面：</p>
<p><figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/cfdisk.webp" title="/images/Network/OpenWRT_overlay/cfdisk.webp" data-thumbnail="/images/Network/OpenWRT_overlay/cfdisk.webp" data-sub-html="<h2>磁盘界面</h2>">
        
    </a><figcaption class="image-caption">磁盘界面</figcaption>
    </figure>
这里可以看到，一共有两个已有分区，现在新建一个分区：</p>
<p>选中 <code>Free Space</code>，再选中 <code>New</code>，输入需要的大小，比如 5G。</p>
<p>接着选择 <code>primary</code></p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/primary.webp" title="/images/Network/OpenWRT_overlay/primary.webp" data-thumbnail="/images/Network/OpenWRT_overlay/primary.webp" data-sub-html="<h2>选择主分区</h2>">
        
    </a><figcaption class="image-caption">选择主分区</figcaption>
    </figure>
<p>选择 <code>Write</code>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/write.webp" title="/images/Network/OpenWRT_overlay/write.webp" data-thumbnail="/images/Network/OpenWRT_overlay/write.webp" data-sub-html="<h2>写入更改</h2>">
        
    </a><figcaption class="image-caption">写入更改</figcaption>
    </figure></p>
<p>输入 <code>yes</code>，完成新分区的创建</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/yes.webp" title="/images/Network/OpenWRT_overlay/yes.webp" data-thumbnail="/images/Network/OpenWRT_overlay/yes.webp" data-sub-html="<h2>确认</h2>">
        
    </a><figcaption class="image-caption">确认</figcaption>
    </figure>
<h2 id="格式化分区">格式化分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkfs.ext4 /dev/sda3
</code></pre></td></tr></table>
</div>
</div><p>格式化分区</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/format.webp" title="/images/Network/OpenWRT_overlay/format.webp" data-thumbnail="/images/Network/OpenWRT_overlay/format.webp" data-sub-html="<h2>格式化分区</h2>">
        
    </a><figcaption class="image-caption">格式化分区</figcaption>
    </figure>
<h2 id="挂载新分区">挂载新分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mount /dev/sda3 /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><p>挂载分区</p>
<h2 id="转移到新分区">转移到新分区</h2>
<p>然后将原来 upper 层中的数据复制到新的分区中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">cp -r /overlay/* /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><h2 id="web-界面配置修改">Web 界面配置修改</h2>
<p>进入 <code>OpenWRT</code> Web 界面的<code>挂载点</code>对配置进行修改：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/openwrt.webp" title="/images/Network/OpenWRT_overlay/openwrt.webp" data-thumbnail="/images/Network/OpenWRT_overlay/openwrt.webp" data-sub-html="<h2>Web 界面</h2>">
        
    </a><figcaption class="image-caption">Web 界面</figcaption>
    </figure>
<p>再挂载点处点击添加然后配置如下：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/mountpoint.webp" title="/images/Network/OpenWRT_overlay/mountpoint.webp" data-thumbnail="/images/Network/OpenWRT_overlay/mountpoint.webp" data-sub-html="<h2>挂载点配置</h2>">
        
    </a><figcaption class="image-caption">挂载点配置</figcaption>
    </figure>
<h2 id="完成">完成</h2>
<p>到这一步，只需要重启 <code>OpenWRT</code> 即可成功扩容。到 系统 -&gt; 软件包 可以看到空间变大后的容量。</p>
<h2 id="自动挂载">自动挂载</h2>
<p>默认情况下分区再重启后会自动挂载，如果遇到没有挂载的情况，需要编辑 <code>/etc/rc.local</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ vim /etc/rc.local
</code></pre></td></tr></table>
</div>
</div><p>在 <code>exit 0</code> 之前加入一行 <code>mount /dev/sda3 /overlay</code> 即可。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://blog.msm.moe/mount-sd-card-to-overlay-on-openwrt/" target="_blank" rel="noopener noreffer">OpenWrt 下把 SD 卡挂载到 /overlay ，扩大软件空间</a></p>
</li>
<li>
<p>[2] <a href="https://www.jianshu.com/p/8179b19cfa6d" target="_blank" rel="noopener noreffer">软路由 LEDE 折腾 overlay 分区扩容之路</a></p>
</li>
<li>
<p>[3] <a href="https://www.vediotalk.com/archives/13889" target="_blank" rel="noopener noreffer">ESXI 下 OpenWrt 扩容 Overlay,增加安装插件空间</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>单独编译 OpenWRT ipk 插件</title>
    <link>https://www.techkoala.top/openwrt_compile_single_ipk/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_compile_single_ipk/</guid>
    <description><![CDATA[<blockquote>
<p>为 OpenWRT 编译单独的 ipk 插件</p>
</blockquote>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">必须先完整编译一次固件才能单独编译 ipk</div>
        </div>
    </div>
<p>当需要单独更新 OpenWRT 某个插件或者需要增加安装某个插件的时候，可以单独编译对应的 ipk 插件进行安装，而不必编译整个系统。</p>
<h3 id="下载源码">下载源码</h3>
<p>使用 <code>git clone</code> 对应的源码插件到下面的文件夹中</p>
<h3 id="存放路径">存放路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/package
</code></pre></td></tr></table>
</div>
</div><h3 id="配置">配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make menuconfig
</code></pre></td></tr></table>
</div>
</div><p>然后进入对应的子菜单中找到对应插件按 <M> 表示选中插件，但不编译进固件。</p>
<h3 id="编译">编译</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make package/xxxxx/compile <span class="nv">V</span><span class="o">=</span><span class="m">99</span>
</code></pre></td></tr></table>
</div>
</div><p>xxxxx 就是你需要单独编译的程序。</p>
<h3 id="ipk-生成路径">ipk 生成路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/bin/packages/x86_64/xxxx
</code></pre></td></tr></table>
</div>
</div><h3 id="上传-ipk-至路由器">上传 ipk 至路由器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scp xxxxxxx.ipk root@192.168.1.1:/tmp
</code></pre></td></tr></table>
</div>
</div><h3 id="安装">安装</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">opkg install /tmp/xxxxx.ipk
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>常用 DNS 服务器</title>
    <link>https://www.techkoala.top/dns_list/</link>
    <pubDate>Fri, 21 Aug 2020 18:44:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_list/</guid>
    <description><![CDATA[<blockquote>
<p>列举国内外常见的 DNS，方便替换使用</p>
</blockquote>
<h2 id="ipv4">IPv4</h2>
<h3 id="国内">国内</h3>
<h4 id="知名-dns-服务">知名 DNS 服务</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>114 常规 DNS</td>
<td>114.114.114.114</td>
<td>114.114.115.115</td>
</tr>
<tr>
<td>114 拦截钓鱼病毒木马网站</td>
<td>114.114.114.119</td>
<td>114.114.115.119</td>
</tr>
<tr>
<td>114 拦截色情网站</td>
<td>114.114.114.110</td>
<td>114.114.115.110</td>
</tr>
<tr>
<td>阿里 AliDNS</td>
<td>223.5.5.5</td>
<td>223.6.6.6</td>
</tr>
<tr>
<td>百度 BaiduDNS</td>
<td>180.76.76.76</td>
<td></td>
</tr>
<tr>
<td>DNSPod DNS+</td>
<td>119.29.29.29</td>
<td>182.254.116.116</td>
</tr>
<tr>
<td>CNNIC SDNS</td>
<td>1.2.4.8</td>
<td>210.2.4.8</td>
</tr>
<tr>
<td>oneDNS</td>
<td>117.50.11.11</td>
<td>52.80.66.66</td>
</tr>
<tr>
<td>DNS 派电信/移动/铁通</td>
<td>101.226.4.6</td>
<td>218.30.118.6</td>
</tr>
<tr>
<td>DNS 派联通</td>
<td>123.125.81.6</td>
<td>140.207.198.6</td>
</tr>
</tbody>
</table>
<h4 id="全国各地电信-dns-服务器-ip-地址">全国各地电信 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>安徽电信 DNS</td>
<td>61.132.163.68</td>
<td>202.102.213.68</td>
</tr>
<tr>
<td>北京电信 DNS</td>
<td>219.141.136.10</td>
<td>219.141.140.10</td>
</tr>
<tr>
<td>重庆电信 DNS</td>
<td>61.128.192.68</td>
<td>61.128.128.68</td>
</tr>
<tr>
<td>福建电信 DNS</td>
<td>218.85.152.99</td>
<td>218.85.157.99</td>
</tr>
<tr>
<td>甘肃电信 DNS</td>
<td>202.100.64.68</td>
<td>61.178.0.93</td>
</tr>
<tr>
<td>广东电信 DNS</td>
<td>202.96.128.86</td>
<td>202.96.128.166</td>
</tr>
<tr>
<td></td>
<td>202.96.134.33</td>
<td>202.96.128.68</td>
</tr>
<tr>
<td>广西电信 DNS</td>
<td>202.103.225.68</td>
<td>202.103.224.68</td>
</tr>
<tr>
<td>贵州电信 DNS</td>
<td>202.98.192.67</td>
<td>202.98.198.167</td>
</tr>
<tr>
<td>河南电信 DNS</td>
<td>222.88.88.88</td>
<td>222.85.85.85</td>
</tr>
<tr>
<td>黑龙江电信</td>
<td>219.147.198.230</td>
<td>219.147.198.242</td>
</tr>
<tr>
<td>湖北电信 DNS</td>
<td>202.103.24.68</td>
<td>202.103.0.68</td>
</tr>
<tr>
<td>湖南电信 DNS</td>
<td>222.246.129.80</td>
<td>59.51.78.211</td>
</tr>
<tr>
<td>江苏电信 DNS</td>
<td>218.2.2.2</td>
<td>218.4.4.4</td>
</tr>
<tr>
<td></td>
<td>61.147.37.1</td>
<td>218.2.135.1</td>
</tr>
<tr>
<td>江西电信 DNS</td>
<td>202.101.224.69</td>
<td>202.101.226.68</td>
</tr>
<tr>
<td>内蒙古电信</td>
<td>219.148.162.31</td>
<td>222.74.39.50</td>
</tr>
<tr>
<td>山东电信 DNS</td>
<td>219.146.1.66</td>
<td>219.147.1.66</td>
</tr>
<tr>
<td>陕西电信 DNS</td>
<td>218.30.19.40</td>
<td>61.134.1.4</td>
</tr>
<tr>
<td>上海电信 DNS</td>
<td>202.96.209.133</td>
<td>116.228.111.118</td>
</tr>
<tr>
<td></td>
<td>202.96.209.5</td>
<td>180.168.255.118</td>
</tr>
<tr>
<td>四川电信 DNS</td>
<td>61.139.2.69</td>
<td>218.6.200.139</td>
</tr>
<tr>
<td>天津电信 DNS</td>
<td>219.150.32.132</td>
<td>219.146.0.132</td>
</tr>
<tr>
<td>云南电信 DNS</td>
<td>222.172.200.68</td>
<td>61.166.150.123</td>
</tr>
<tr>
<td>浙江电信 DNS</td>
<td>202.101.172.35</td>
<td>61.153.177.196</td>
</tr>
<tr>
<td></td>
<td>61.153.81.75</td>
<td>60.191.244.5</td>
</tr>
</tbody>
</table>
<h4 id="全国各地联通-dns-服务器-ip-地址">全国各地联通 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京联通 DNS</td>
<td>123.123.123.123</td>
<td>123.123.123.124</td>
</tr>
<tr>
<td></td>
<td>202.106.0.20</td>
<td>202.106.195.68</td>
</tr>
<tr>
<td>重庆联通 DNS</td>
<td>221.5.203.98</td>
<td>221.7.92.98</td>
</tr>
<tr>
<td>广东联通 DNS</td>
<td>210.21.196.6</td>
<td>221.5.88.88</td>
</tr>
<tr>
<td>河北联通 DNS</td>
<td>202.99.160.68</td>
<td>202.99.166.4</td>
</tr>
<tr>
<td>河南联通 DNS</td>
<td>202.102.224.68</td>
<td>202.102.227.68</td>
</tr>
<tr>
<td>黑龙江联通</td>
<td>202.97.224.69</td>
<td>202.97.224.68</td>
</tr>
<tr>
<td>吉林联通 DNS</td>
<td>202.98.0.68</td>
<td>202.98.5.68</td>
</tr>
<tr>
<td>江苏联通 DNS</td>
<td>221.6.4.66</td>
<td>221.6.4.67</td>
</tr>
<tr>
<td>内蒙古联通</td>
<td>202.99.224.68</td>
<td>202.99.224.8</td>
</tr>
<tr>
<td>山东联通 DNS</td>
<td>202.102.128.68</td>
<td>202.102.152.3</td>
</tr>
<tr>
<td></td>
<td>202.102.134.68</td>
<td>202.102.154.3</td>
</tr>
<tr>
<td>山西联通 DNS</td>
<td>202.99.192.66</td>
<td>202.99.192.68</td>
</tr>
<tr>
<td>陕西联通 DNS</td>
<td>221.11.1.67</td>
<td>221.11.1.68</td>
</tr>
<tr>
<td>上海联通 DNS</td>
<td>210.22.70.3</td>
<td>210.22.84.3</td>
</tr>
<tr>
<td>四川联通 DNS</td>
<td>119.6.6.6</td>
<td>124.161.87.155</td>
</tr>
<tr>
<td>天津联通 DNS</td>
<td>202.99.104.68</td>
<td>202.99.96.68</td>
</tr>
<tr>
<td>浙江联通 DNS</td>
<td>221.12.1.227</td>
<td>221.12.33.227</td>
</tr>
<tr>
<td>辽宁联通 DNS</td>
<td>202.96.69.38</td>
<td>202.96.64.68</td>
</tr>
</tbody>
</table>
<h4 id="全国各地移动-dns-服务器-ip-地址">全国各地移动 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>江苏移动 DNS</td>
<td>221.131.143.69</td>
<td>112.4.0.55</td>
</tr>
<tr>
<td>安徽移动 DNS</td>
<td>211.138.180.2</td>
<td>211.138.180.3</td>
</tr>
<tr>
<td>山东移动 DNS</td>
<td>218.201.96.130</td>
<td>211.137.191.26</td>
</tr>
</tbody>
</table>
<h3 id="香港地区">香港地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>香港宽频 DNS</td>
<td>203.80.96.10</td>
<td></td>
</tr>
<tr>
<td>和记环球电讯 DNS</td>
<td>202.45.84.58</td>
<td>202.45.84.59</td>
</tr>
<tr>
<td>Pacific SuperNet DNS</td>
<td>202.14.67.4</td>
<td>202.14.67.14</td>
</tr>
</tbody>
</table>
<h3 id="台湾地区">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信 DNS</td>
<td>168.95.1.1</td>
<td>168.95.192.1</td>
</tr>
<tr>
<td>数位联合电信 DNS</td>
<td>139.175.252.16</td>
<td>139.175.55.244</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>101.101.101.101</td>
<td>101.102.103.104</td>
</tr>
</tbody>
</table>
<h3 id="韩国">韩国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>KT olleh DNS</td>
<td>168.126.63.1</td>
<td>168.126.63.2</td>
</tr>
<tr>
<td>SK Broadband DNS</td>
<td>210.220.163.82</td>
<td>219.250.36.130</td>
</tr>
<tr>
<td>LG U+ DNS</td>
<td>164.124.101.2</td>
<td>203.248.252.2</td>
</tr>
<tr>
<td></td>
<td>164.124.107.9</td>
<td>203.248.242.2</td>
</tr>
</tbody>
</table>
<h3 id="美国">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cloudflare DNS</td>
<td>1.1.1.1</td>
<td>1.0.0.1</td>
</tr>
<tr>
<td>Google DNS</td>
<td>8.8.8.8</td>
<td>8.8.4.4</td>
</tr>
<tr>
<td>IBM Quad9</td>
<td>9.9.9.9</td>
<td>149.112.112.112</td>
</tr>
<tr>
<td>DNS.SB</td>
<td>185.222.222.222</td>
<td>185.184.222.222</td>
</tr>
<tr>
<td>OpenDNS</td>
<td>208.67.222.222</td>
<td>208.67.220.220</td>
</tr>
<tr>
<td>V2EX DNS</td>
<td>199.91.73.222</td>
<td>178.79.131.110</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>74.82.42.42</td>
<td>66.220.18.42</td>
</tr>
</tbody>
</table>
<h3 id="其他地区">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>77.88.8.8</td>
<td>77.88.8.1</td>
</tr>
<tr>
<td>俄罗斯 SafeDNS</td>
<td>195.46.39.39</td>
<td>195.46.39.40</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>84.200.69.80</td>
<td>84.200.70.40</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>77.109.148.136</td>
<td>77.109.148.137</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>91.239.100.100</td>
<td>89.233.43.71</td>
</tr>
<tr>
<td>荷兰 Freenom World Public DNS</td>
<td>80.80.80.80</td>
<td>80.80.81.81</td>
</tr>
</tbody>
</table>
<h2 id="ipv6">IPv6</h2>
<h3 id="国内-1">国内</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>百度</td>
<td>2400:da00::6666</td>
<td></td>
</tr>
<tr>
<td>阿里</td>
<td>2400:3200::1</td>
<td>2400:3200:baba::1</td>
</tr>
<tr>
<td>CNNIC</td>
<td>2001:dc7:1000::1</td>
<td></td>
</tr>
<tr>
<td>下一代互联网北京研究中心</td>
<td>240C::6666</td>
<td>240C::6644</td>
</tr>
</tbody>
</table>
<h4 id="高校">高校</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京邮电大学</td>
<td>2001:da8:202:10::36</td>
<td>2001:da8:202:10::37</td>
</tr>
<tr>
<td>上海交通大学</td>
<td>2001:da8:8000:1:202:120:2:100</td>
<td>2001:da8:8000:1:202:120:2:101</td>
</tr>
<tr>
<td>中科院网络信息中心</td>
<td>2001:cc0:2fff:1::6666</td>
<td></td>
</tr>
<tr>
<td>北京交通大学</td>
<td>2001:da8:205:2060::188</td>
<td></td>
</tr>
<tr>
<td>清华大学</td>
<td>2001:da8:ff:305:20c:29ff:fe1f:a92a</td>
<td></td>
</tr>
<tr>
<td>清华大学 TUNA 协会</td>
<td>2001:da8::666</td>
<td></td>
</tr>
<tr>
<td>北京科技大学</td>
<td>2001:da8:208:10::6</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="台湾地区-1">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信</td>
<td>2001:b000:168::1</td>
<td>2001:b000:168::2</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>2001:de4::101</td>
<td>2001:de4::102</td>
</tr>
</tbody>
</table>
<h3 id="美国-1">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GOOGLE</td>
<td>2001:4860:4860::8888</td>
<td>2001:4860:4860::8844</td>
</tr>
<tr>
<td>CloudFlare DNS</td>
<td>2606:4700:4700::1111</td>
<td>2606:4700:4700::1001</td>
</tr>
<tr>
<td>IBM</td>
<td>2620:fe::fe</td>
<td>2620:fe::9</td>
</tr>
<tr>
<td>Cisco OpenDNS</td>
<td>2620:0:ccc::2</td>
<td>2620:0:ccd::2</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>2001:470:20::2</td>
<td>2001:470:0:9d::2</td>
</tr>
<tr>
<td>Verisign Public DNS</td>
<td>2620:74:1b::1:1</td>
<td>2620:74:1c::2:2</td>
</tr>
<tr>
<td>Neustar Recursive DNS</td>
<td>2610:a1:1018::1</td>
<td>2610:a1:1019::1</td>
</tr>
</tbody>
</table>
<h3 id="其他地区-1">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>2a02:6b8::feed:0ff</td>
<td>2a02:6b8:0:1::feed:0ff</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>2001:1608:10:25::1c04:b12f</td>
<td>2001:1608:10:25::9249:d69b</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>2001:1620:2078:136::</td>
<td>2001:1620:2078:137::</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>2001:67c:28a4::</td>
<td>2a01:3a0:53:53::</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://www.iplaysoft.com/public-dns.html" target="_blank" rel="noopener noreffer">全球免费公共 dns 解析服务器 ip 地址列表推荐 (解决无法上网/加速/防劫持)</a></p>
</li>
<li>
<p>[2] <a href="http://ip.cn/dns.html" target="_blank" rel="noopener noreffer">公共 dns 服务器 ip 地址</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>网络分析工具：NetCat</title>
    <link>https://www.techkoala.top/netcat/</link>
    <pubDate>Wed, 19 Aug 2020 23:15:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/netcat/</guid>
    <description><![CDATA[<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-sub-html="<h2>网络瑞士军刀 —— NetCat</h2>">
        
    </a><figcaption class="image-caption">网络瑞士军刀 —— NetCat</figcaption>
    </figure>
<h2 id="什么是-netcat">什么是 NetCat</h2>
<p>简单来说，NetCat (nc) 是一个命令行工具，能够让你很方便、很灵活地操纵 <code>传输层协议</code>（TCP ＆ UDP）</p>
<p>nc 可以在两台设备上面相互交互，即<code>侦听模式</code>/<code>传输模式</code></p>
<p>nc 包含以下主要功能：</p>
<ul>
<li>Telnet 功能</li>
<li>获取 banner 信息</li>
<li>传输文本信息</li>
<li>传输文件 / 目录</li>
<li>加密传输文件，默认不加密</li>
<li>远程控制</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆硬盘</li>
</ul>
<h2 id="使用-netcat">使用 NetCat</h2>
<p>一般来说，nc 的命令行包括如下几个部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc 命令选项 主机 端口
</code></pre></td></tr></table>
</div>
</div><h3 id="命令选项">命令选项</h3>
<blockquote>
<p>本文内容基于 OpenBSD 社区的变种（也叫 OpenBSD netcat，部分命令与原版有差异。 ）</p>
</blockquote>
<p>下面列举了一些常用选项，更多选项参见 <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreffer">OpenBSD manual page</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">选项	   是否有 “选项值”	   说明
-h	   NO	           输出 nc 的帮助
-v	   NO	           在网络通讯时，显示详细的输出信息
-n	   NO	           对命令行中的主机，不进行域名解析，如果主机是 IP 地址，需要用该选项
-p	  YES	           指定端口号
-l	  NO	           开启监听模式，nc 作为服务端，如不加，nc 默认作为客户端
-u	  NO	           使用 UDP 协，如不加该选项，默认是 TCP 协议
-w	  YES	           设置连接的超时间隔（N 秒）
-q	  YES	           让 nc 延时（N 秒）再退出
-z	  NO	           开启 zero-I/O 模式，该选项仅用于端口扫描
-k	  NO	           配合 -l 选项使用，可以重复接受客户端连接
-X	  YES	           指定代理的类型
-x	  YES	           以 IP:port 的格式指定代理
-d    NO               后台模式
</code></pre></td></tr></table>
</div>
</div><h3 id="主机">主机</h3>
<p>这部分可以没有，可以以 <code>IP 地址</code> 形式表示，也可以以 <code>域名</code> 形式表示。</p>
<h3 id="端口">端口</h3>
<p>这部分可以没有，可以是单个端口，可以是端口范围。</p>
<h2 id="常用使用场景示例">常用使用场景示例</h2>
<h3 id="测试某个远程主机的监听端口是否可达">测试某个远程主机的监听端口是否可达</h3>
<p>经常有这种需求，要判断某个主机的监听端口是否能连上。导致监听端口无法连接，通常有两种原因：</p>
<ol>
<li>监听端口没开启</li>
<li>监听端口虽然开启，但是被防火墙阻拦了</li>
</ol>
<p>对第 1 个原因，（如果你能在该主机上运行命令）可以直接用 <code>netstat</code> 这个命令查看监听端口是否开启；但对于第 2 个原因，<code>netstat</code> 就用不上了，这时候就可以用 nc 来帮你搞定。</p>
<p>用如下命令可以测试某个 IP 地址上的某个监听端口是否开启:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv ip port
</code></pre></td></tr></table>
</div>
</div><p><strong>注：</strong>　默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加 <code>-w</code> 选项，设置一个比较小的超时值。在下面的例子中，超时值设为 3 秒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv -w <span class="m">3</span> ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="判断防火墙是否允许-or-禁止某个端口">判断防火墙是否允许 or 禁止某个端口</h3>
<p>假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何验证自己的配置生效？</p>
<p>为了叙述方便，设想如下场景：
有两台主机 ——<code>主机 C</code> 充当客户端，<code>主机 S</code> 充当服务端。
然后要判断<code>主机 S</code> 上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。</p>
<p>在<code>主机 S</code> 上运行 nc，让它在 8080 端口，命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -lv -p <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 “主机 C” 上运行 nc，测试 “主机 S” 上的 8080 端口是否可达</p>
<p><strong>注：</strong>　在默认情况下，nc 开启 listen 模式充当服务端，在接受<strong>第一次</strong>客户端连接之后，就会把监听端口关闭。如果你想要让 nc 始终监听模式，使之能<strong>重复</strong>接受客户端发起的连接，可以追加 <code>-k</code> 选项。</p>
<h3 id="端口扫描">端口扫描</h3>
<p>下面这个命令，用来扫描的端口范围从 1 到 1024</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024
</code></pre></td></tr></table>
</div>
</div><p>选项 -z
是指开启 <code>zero-I/O 模式</code>。该模式 nc 只判断某个监听端口是否能连上，连上后<strong>不</strong>与对端进行数据通讯。</p>
<p>**注：**端口扫描的时候，<code>-v</code> 选项会把成功/失败的结果统统打印出来。通常关注的都是 “扫描成功” 的那些端口。因此，可以用可以配合使用 <code>grep</code> 过滤一下，只打印扫出来的端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024  2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> grep succeeded
</code></pre></td></tr></table>
</div>
</div><p>此外，由于 <code>-v</code> 选项产生的输出位于 <code>stderr</code>，上述命令中的 <code>2&gt;&amp;1</code> 用来把 <code>stderr</code> 合并到 <code>stdout</code>。</p>
<p><strong>另：</strong> nc 默认超时较大，导致扫描速度较慢。建议根据网络情况合理设置超时值，加快扫描速度。</p>
<h3 id="探测服务器类型和软件版本">探测服务器类型和软件版本</h3>
<p>如果某个服务器运行了 SSH 服务端，那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> -n ip <span class="m">22</span>
OR
<span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> domain <span class="m">22</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="端口转发">端口转发</h3>
<p>用 nc 进行端口转发，需要运行两个 nc 进程，一个充当<code>服务端</code>，另一个是<code>客户端</code>，然后用管道让把两个进程的<code>标准输入输出``交叉配对</code>。所谓的<code>交叉配对</code>就是——每一个 nc 进程的<code>标准输出</code>都对接到另一个 nc 进程的<code>标准输入</code>。如此一来，就可以完美地建立双向通讯。</p>
<p>步骤 1：创建命名管道</p>
<p>用下面这个简单的命令创建一个 “命名管道”，其名称叫做 nc_pipe</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mkfifo nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>步骤 2：同时启动两个 nc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p <span class="m">1234</span> &lt; nc_pipe <span class="p">|</span> nc 127.0.0.1 <span class="m">5678</span> &gt; nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。</p>
<h3 id="传输文件">传输文件</h3>
<p>为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端 B 主机运行如下命令
nc -l -p port &gt; file2

然后在发送端 A 主机运行如下命令
nc ip port &lt; file1
</code></pre></td></tr></table>
</div>
</div><p>两者端口号要相同</p>
<h3 id="远程备份整个磁盘">远程备份整个磁盘</h3>
<p>假设你要把 A 主机 <code>/dev/sda</code> 磁盘的原始数据整个复制到 B 主机的 <code>/dev/sdb</code> 磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端（B 主机）运行如下命令
nc -lp port <span class="p">|</span> dd <span class="nv">of</span><span class="o">=</span>/dev/sdb

然后在发送端 A 主机运行如下命令
dd <span class="k">if</span><span class="o">=</span>/dev/sda <span class="p">|</span> nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="远程控制">远程控制</h3>
<p>将 A 主机的 <code>bash</code> 发给 B 主机</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
nc -lp port -c bash

B:
nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="流媒体服务">流媒体服务</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
cat test.mp4 <span class="p">|</span> nc -lp port

B:
nc -nv ip port <span class="p">|</span> mplayer -vo x11 -cache <span class="m">4000</span>
</code></pre></td></tr></table>
</div>
</div><p>A 让 test.MP4 这个文件成为<code>流</code>的形式发送到 B，B 用 mplayer 播放，接收多少播放多少，指定缓存 4000bytes。</p>
<h3 id="信息收集">信息收集</h3>
<p>收集目标机上的进程信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p port &gt; ps.txt
将远程发送过来的内容保存在本地

Ps aux <span class="p">|</span>nc -nv ip port -q <span class="m">1</span>
标准输入完成后 delay 一秒钟，会发送到侦听端

</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreffer">netcat manual page</a></p>
</li>
<li>
<p>[2] <a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html#head-15" target="_blank" rel="noopener noreffer">扫盲 netcat（网猫）的 N 种用法 —— 从 “网络诊断” 到 “系统入侵”</a></p>
</li>
<li>
<p>[3] <a href="https://www.jianshu.com/p/cb26a0f6c622" target="_blank" rel="noopener noreffer">NetCat 使用指南</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>HTTPS 工作原理</title>
    <link>https://www.techkoala.top/how_https_works/</link>
    <pubDate>Sun, 16 Aug 2020 21:52:26 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/how_https_works/</guid>
    <description><![CDATA[<blockquote>
<p>理解 HTTP 协议，对称和非对称加密，了解 HTTPS 协议的工作原理</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：猫尾博客</p>
<p>链接：https://cattail.me/tech/2015/11/30/how-https-works.html</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>读完本文，你能明白</p>
<ul>
<li>什么是 HTTPS，TLS (SSL)，TLS 和 HTTPS 是什么关系</li>
<li>什么是证书和数字签名，它们是如何传递信任的</li>
<li>HTTPS 有什么样的功能，它是如何实现这样的功能的</li>
</ul>
<h2 id="简介">简介</h2>
<p>HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。本文着重描述 TLS 协议的 1.2 版本</p>
<p>下图描述了在 TCP/IP 协议栈中 TLS (各子协议）和 HTTP 的关系</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" data-sub-html="<h2>Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS</h2>">
        
    </a><figcaption class="image-caption">Credit: <a href="https://blogs.msdn.com/213737/ProfileUrlRedirect.ashx" target="_blank" rel="noopener noreffer">Kaushal Kumar Panday</a> From: <a href="https://blogs.msdn.com/b/kaushal/archive/2013/08/03/ssl-handshake-and-https-bindings-on-iis.aspx" target="_blank" rel="noopener noreffer">SSL Handshake and HTTPS Bindings on IIS</a></figcaption>
    </figure>
<p>其中 <code>Handshake protocol</code>，<code>Change Ciper Spec protocol</code> 和 <code>Alert protocol</code> 组成了 <code>SSL Handshaking Protocols</code>。</p>
<p>HTTPS 和 HTTP 协议相比提供了:</p>
<ol>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ol>
<p>其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。</p>
<h2 id="总览">总览</h2>
<p>使用 RSA 算法的 SSL 握手过程是这样的:</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<ol>
<li>[明文] 客户端发送随机数 client_random 和支持的加密方式列表</li>
<li>[明文] 服务器返回随机数 server_random ，选择的加密方式和服务器证书链</li>
<li>[RSA] 客户端验证服务器证书，使用证书中的公钥加密 premaster secret 发送给服务端</li>
<li>服务端使用私钥解密 premaster secret</li>
<li>两端分别通过 client_random，server_random 和 premaster secret 生成 master secret，用于对称加密后续通信内容</li>
</ol>
<h3 id="证书digital-certificate">证书（Digital certificate）</h3>
<p>那么什么是证书呢？</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" data-sub-html="<h2>证书信息</h2>">
        
    </a><figcaption class="image-caption">证书信息</figcaption>
    </figure>
<h3 id="证书中包含了以下信息">证书中包含了以下信息</h3>
<ol>
<li>证书信息：过期时间和序列号</li>
<li>所有者信息：姓名等</li>
<li>所有者公钥</li>
</ol>
<p><strong>为什么服务端要发送证书给客户端?</strong></p>
<p>互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<h3 id="客户端为什么要验证接收到的证书">客户端为什么要验证接收到的证书</h3>
<p><strong>中间人攻击</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">客户端 &lt;------------ 攻击者 &lt;------------ 服务端
        伪造证书            拦截请求
</code></pre></td></tr></table>
</div>
</div><h3 id="客户端如何验证接收到的证书">客户端如何验证接收到的证书</h3>
<p>为了回答这个问题，需要引入<code>数字签名</code> (Digital Signature)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+                +--------+
| is a mathematical   |---- 哈希 ---&gt;| 消息摘要  |--- 私钥加密 ---&gt;| 数字签名 |
|technique used       |              +---------+                +--------+
|to validate the      |
|authenticity and     |
|integrity of a       |
|message, software    |
|or digital document. |
+---------------------+
</code></pre></td></tr></table>
</div>
</div><p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p>
<p>假设消息传递在 Bob，Susan 和 Pat 三人之间发生。Susan 将消息连同数字签名一起发送给 Bob，Bob 接收到消息后，可以这样验证接收到的消息就是 Susan 发送的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+
| is a mathematical   |---- 哈希 ---&gt;|  消息摘要 |
|technique used       |              +---------+
|to validate the      |                 |
|authenticity and     |                 |
|integrity of a       |                 |
|message, software    |                 对
|or digital document. |                 比
+---------------------+                 |
                                        |
                                        |
        +---------+               +----------+
        | 数字签名 |--- 公钥解密 ---&gt;|  消息摘要 |
        +---------+               +----------+
</code></pre></td></tr></table>
</div>
</div><p>当然，这个前提是 Bob 知道 Susan 的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Bob。</p>
<p>此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener noreffer">证书颁发机构</a>（Certificate Authority，简称 CA），CA 数量并不多，Bob 客户端内置了所有受信任 CA 的证书。CA 对 Susan 的公钥（和其他信息）数字签名后生成证书。</p>
<p>Susan 将证书发送给 Bob 后，Bob 通过 CA 证书的公钥验证证书签名。</p>
<p>Bob 信任 CA，CA 信任 Susan 使得 Bob 信任 Susan，信任链（Chain Of Trust）就是这样形成的。</p>
<p>事实上，Bob 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<h2 id="tls-协议">TLS 协议</h2>
<p><code>TLS</code> 协议包括 <code>TLS Record Protocol</code> 和 <code>TLS Handshake Protocol</code>。总览中的流程图仅涉及到 <code>TLS Handshake Protocol</code>。</p>
<h3 id="tls-record-protocol">TLS Record Protocol</h3>
<p>在 <code>TLS</code> 协议中，有四种子协议运行于 <code>Record protocol</code> 之上</p>
<ul>
<li>Handshake protocol</li>
<li>Alert protocol</li>
<li>Change cipher spec protocol</li>
<li>Application data protocol</li>
</ul>
<p>Record protocol 起到了这样的作用</p>
<ul>
<li>在发送端：将数据（Record）分段，压缩，增加 MAC (Message Authentication Code) 和加密</li>
<li>在接收端：将数据（Record）解密，验证 MAC，解压并重组</li>
</ul>
<blockquote>
<p>值得一提的是，Record protocol 提供了数据完整性和隐私性保证，但 Record 类型（type）和长度（length）是公开传输的</p>
</blockquote>
<p>Record Protocol 有三个连接状态 (Connection State)，连接状态定义了压缩，加密和 MAC 算法。所有的 Record 都是被当前状态（Current State）确定的算法处理的。</p>
<p><code>TLS Handshake Protocol</code> 和 <code>Change Ciper Spec Protocol</code> 会导致 <code>Record Protocol</code> 状态切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">empty state -------------------&gt; pending state ------------------&gt; current state
             Handshake Protocol                Change Cipher Spec
</code></pre></td></tr></table>
</div>
</div><p>初始当前状态（Current State）没有指定加密，压缩和 MAC 算法，因而在完成 TLS Handshaking Protocols 一系列动作之前，客户端和服务端的数据都是<strong>明文传输</strong>的；当 TLS 完成握手过程后，客户端和服务端确定了加密，压缩和 MAC 算法及其参数，数据（Record）会通过指定算法处理。</p>
<blockquote>
<p>其中，Record 首先被加密，然后添加 MAC（message authentication code）以保证数据完整性。</p>
</blockquote>
<h3 id="tls-handshaking-protocols">TLS Handshaking Protocols</h3>
<p>Handshakeing protocols 包括 Alert Protocol，Change Ciper Spec Protocol 和 Handshake protocol。本文不会详细介绍 Alert Protocol 和 Change Ciper Spec Protocol。</p>
<p>使用 <code>RSA</code> 算法的握手过程是这样的（已在总览中提到）</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<p>客户端和服务端在握手 hello 消息中明文交换了 <code>client_random</code> 和 <code>server_random</code> ，使用 <code>RSA</code> 公钥加密传输 <code>premaster secret</code> ，最后通过算法，客户端和服务端分别计算 <code>master secret</code>。其中，不直接使用 <code>premaster secret</code> 的原因是：保证 <code>secret</code> 的随机性不受任意一方的影响。</p>
<p>除了使用 <code>RSA</code> 算法在公共信道交换密钥，还可以通过 <code>Diffie–Hellman</code> 算法。<code>Diffie–Hellman</code> 算法的原理是这样的</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-sub-html="<h2>By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</h2>">
        
    </a><figcaption class="image-caption">By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</figcaption>
    </figure>
<p>使用 <code>Diffie–Hellman</code> 算法交换 <code>premaster secret</code> 的流程</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<h2 id="小结">小结</h2>
<p><code>TLS Handshaking Protocols</code> 协商了 <code>TLS Record Protocol</code> 使用的算法和所需参数，并验证了服务端身份；</p>
<p><code>TLS Record Protocol</code> 在协商后保证应用层数据的完整性和隐私性。</p>
<p><code>TLS Handshaking Protocol</code> 的核心是在公开信道上传递 <code>premaster secret</code>。</p>
<h2 id="qa">Q&amp;A</h2>
<h3 id="为什么传输内容不直接使用非对称加密">为什么传输内容不直接使用非对称加密？</h3>
<p>因为性能限制。</p>
<h3 id="https-能保证正常连接">HTTPS 能保证正常连接？</h3>
<p>不能。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support.</div>
        </div>
    </div>
<p>攻击者甚至可以直接丢弃双方的数据包</p>
<h3 id="服务端如何验证客户端身份">服务端如何验证客户端身份？</h3>
<p>通过 <code>Client Certificate</code></p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">This message conveys the client’s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite’s key exchange algorithm, and any negotiated extensions.</div>
        </div>
    </div>
<h3 id="alert-protocol-有什么作用">Alert protocol 有什么作用？</h3>
<p><code>Closure Alerts</code>：防止 <code>Truncation Attack</code></p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">In a truncation attack, an attacker inserts into a message a TCP code indicating the message has finished, thus preventing the recipient picking up the rest of the message. To prevent this, SSL from version v3 onward has a closing handshake, so the recipient knows the message has not ended until this has been performed.</div>
        </div>
    </div>
<p>Error Alerts：错误处理</p>
<h3 id="master-secret-是如何计算的">master secret 是如何计算的</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  master_secret = PRF (pre_master_secret, &#34;master secret&#34;,
                      ClientHello.random + ServerHello.random)
                      [0..47];
</code></pre></td></tr></table>
</div>
</div><h3 id="加密压缩和-mac-算法参数是如何计算的">加密，压缩和 MAC 算法参数是如何计算的</h3>
<p><code>Handshaking Protocols</code> 使得客户端和服务端交换了三个参数：<code>client_random</code>，<code>server_random</code> 和 <code>master_secret</code>，通过以下算法生成算法所需要的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">To generate the key material, compute

  key_block = PRF (SecurityParameters.master_secret,
                  &#34;key expansion&#34;,
                  SecurityParameters.`server_random` +
                  SecurityParameters.`client_random`);

until enough output has been generated.  Then, the key_block is
partitioned as follows:

  client_write_MAC_key [SecurityParameters.mac_key_length]
  server_write_MAC_key [SecurityParameters.mac_key_length]
  client_write_key [SecurityParameters.enc_key_length]
  server_write_key [SecurityParameters.enc_key_length]
  client_write_IV [SecurityParameters.fixed_iv_length]
  server_write_IV [SecurityParameters.fixed_iv_length]
</code></pre></td></tr></table>
</div>
</div><div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key</div>
        </div>
    </div>
<p>使用 <code>Diffie-Hellman</code> 算法的 <code>TLS</code> 握手细节</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" data-sub-html="<h2>Source: https://cipherstuff.wordpress.com/</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://cipherstuff.wordpress.com/">https://cipherstuff.wordpress.com/</a></figcaption>
    </figure>
<h2 id="拓展阅读">拓展阅读</h2>
<ul>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless</a></li>
<li><a href="https://letsencrypt.org/" target="_blank" rel="noopener noreffer">Let’s Encrypt</a></li>
<li>Session resume</li>
<li>证书 Revoke</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener noreffer">TLS1.2 规范</a></p>
</li>
<li>
<p>[2] <a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener noreffer">PKI 规范</a></p>
</li>
<li>
<p>[3] <a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener noreffer">证书和数字签名</a></p>
</li>
<li>
<p>[4] <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">TLS Handshake</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>网络测试工具：iPerf</title>
    <link>https://www.techkoala.top/iperf/</link>
    <pubDate>Fri, 07 Aug 2020 17:45:55 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/iperf/</guid>
    <description><![CDATA[<blockquote>
<p>TCP、UDP 和 SCTP 的终极速度测试工具</p>
</blockquote>
<h2 id="什么是-iperf">什么是 iPerf</h2>
<p>iPerf 是一个用于测量网络最大带宽的小工具。iPerf 可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和 UDP 特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。对于每个测试，它都会报告带宽，丢包和其他参数。</p>
<p>现在的版本也称 iPerf3，这是对 NLANR/DAST 开发的原始版本的重新设计。</p>
<p><strong>注意</strong>：iPerf3 与此前版本的 iPerf 不兼容。</p>
<h2 id="安装-iperf">安装 iPerf</h2>
<p>iPerf3 官方仅支持 CentOS Linux，FreeBSD 和 macOS，但实际上，<a href="https://iperf.fr/iperf-download.php" target="_blank" rel="noopener noreffer">官网</a>提供了主流系统的预编译文件。（包括 Windows、Android、iOS、Ubuntu、Arch Linux 等）</p>
<p>类 UNIX 系统直接使用包管理进行安装即可，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo apt install iperf3
</code></pre></td></tr></table>
</div>
</div><h2 id="使用-iperf">使用 iPerf</h2>
<p>首先，介绍服务端和客户端共有的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-p, --port n      服务器用于侦听和客户端连接的服务器端口，两者应该相同，默认值为 <span class="m">5201</span>
--cport n         指定客户端端口
-f, --format      用于指定单位显示格式，支持 <span class="s1">&#39;k&#39;</span> <span class="o">=</span> Kbits/sec <span class="s1">&#39;K&#39;</span> <span class="o">=</span> KBytes/sec <span class="s1">&#39;m&#39;</span> <span class="o">=</span> Mbits/sec <span class="s1">&#39;M&#39;</span> <span class="o">=</span> MBytes/sec，默认为自适应格式
-i, --interval n  设置测试信息报告之间的间隔时间（以秒为单位）。如果为零，则不打印任何定期报告。默认值为零。
-F, --file name   客户端：从文件读取并写入网络，而不是使用随机数据；服务器端：从网络读取并写入文件，而不是丢弃数据。
-A, --affinity    如果可以，设置 CPU 关联（仅限 Linux 和 FreeBSD）。
-B, --bind host   绑定到主机。对于客户端，这将设置出站接口。对于服务器，这将设置传入接口。这只适用于具有多个网络接口的多宿主主机。
-V, --verbose     提供更详细的输出
-J, --json        以 JSON 格式输出
--logfile file    输出到日志文件
--d, --debug      发出调试输出
-v, --version     输出版本信息
-h, --help        输出帮助信息
</code></pre></td></tr></table>
</div>
</div><p>服务端特有参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-s, --server      在服务器模式下运行 iPerf（一次只允许一个 iPerf 连接）
-D, --daemon      将服务器作为守护进程在后台运行
-I, --pidfilefile 使用进程ID编写文件，这在作为守护进程运行时非常有用
</code></pre></td></tr></table>
</div>
</div><p>客户端特有参数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-c, --client host	    在客户端模式下运行 iPerf
--sctp	                使用 SCTP 而不是 TCP
-u, --udp	            使用 UDP 而不是 TCP
-b, --bandwidth      	将目标带宽设置为 nbits/sec（对于 UDP 默认为 <span class="m">1</span> Mbit/sec，对于 TCP 为无限制）。如果有多个流（-P 标志），则带宽限制将分别应用于每个流。您还可以在带宽说明符中添加一个 “/” 和一个数字。这称为 “突发模式”。 它会发送给定数量的数据包而不会暂停，即使该数据包暂时超过了指定的带宽限制
-t, --time  	        传输的时间（以秒为单位）。iPerf 通常通过在 t 时间内重复发送 len 长度的字节数组来工作。默认值为 <span class="m">10</span> 秒
-n, --num 	            要传输的缓冲区数量。通常，iPerf 只会发送 <span class="m">10</span> 秒。-n 选项覆盖此设置，并发送 len 长度字节数组 n 次，无论需要多长时间
-k, --blockcount    	要传输的块（数据包）数
-l, --length     	    读取或写入的缓冲区的长度，iPerf 通过多次写入 len 个字节的数组来工作。TCP 的默认值为 <span class="m">128</span> KB，UDP 的默认值为 <span class="m">8</span> KB。
-P, --parallel  	    与服务器同时建立的连接数，默认值为 <span class="m">1</span>
-R, --reverse	        以反向模式运行（服务器发送，客户端接收）
-w, --window    	    将套接字缓冲区大小设置为指定值。对于 TCP，这将设置 TCP 窗口大小（这将发送到服务器并在该侧使用）
-M, --set-mss  	        尝试设置 TCP 最大段大小（MSS）。MSS 通常是 MTU-TCP/IP 标头的 <span class="m">40</span> 个字节。对于以太网，MSS 为 <span class="m">1460</span> 字节（1500 字节 MTU）
-N, --no-delay	        设置 “TCP no delay” 选项，禁用 Nagle 的算法。通常，仅对交互式应用程序（如 telnet）禁用此功能
-4, --version4	        仅使用 IPv4.
-6, --version4	        仅使用 IPv6.
-S, --tos               传出数据包的服务类型。<span class="o">(</span>许多路由器会忽略TOS字段。）可以使用十六进制值（0x）作为前缀，使用八进制数（0）作为前缀，或者使用十进制来指定值。 例如，<span class="s1">&#39;0x10&#39;</span><span class="nv">十六进制</span><span class="o">=</span><span class="s1">&#39;020&#39;</span><span class="nv">八进制</span><span class="o">=</span><span class="s1">&#39;16&#39;</span>十进制。RFC 1349中指定的TOS编号为：
                        IPTOS_LOWDELAY     minimize delay        0x10
                        IPTOS_THROUGHPUT   maximize throughput   0x08
                        IPTOS_RELIABILITY  maximize reliability  0x04
                        IPTOS_LOWCOST      minimize cost         0x02
-L, --flowlabel  	    设置 IPv6 流标签（当前仅在 Linux 上受支持）
-Z, --zerocopy	        使用 “零拷贝” 方法发送数据，如 sendfile（2），而不是通常的 write（2）。这样可以占用更少的 CPU
-O, --omit  	        省略测试的前 n 秒，以跳过 TCP TCP 慢启动周期
-T, --title             为每个输出行添加此字符串前缀
-C, --linux-congestion  设置拥塞控制算法 <span class="o">(</span>仅适用于 iPerf 3.1 的 Linux 和 FreeBSD<span class="o">)</span>。
</code></pre></td></tr></table>
</div>
</div><div class="details admonition warning open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-exclamation-triangle fa-fw"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">从客户端专有选项可以看出，iPerf 默认测试的是从客户端发送到服务端，相对于客户端来说，测试就是上行链路的带宽，对于一般参考意义更大的下行链路需要加上 <code>-R</code> 选项。</div>
        </div>
    </div>
<p>常用启用参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">服务端
$ iperf3 -s -p <span class="m">12345</span> -i <span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">客户端
$ iperf3 -c 192.168.1.43 -p <span class="m">12345</span> -i <span class="m">1</span> -t <span class="m">20</span> -w 100k
</code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/iperf/iperf.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/iperf/iperf.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/iperf/iperf.webp" data-sub-html="<h2>iPerf 使用实例</h2>">
        
    </a><figcaption class="image-caption">iPerf 使用实例</figcaption>
    </figure>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://iperf.fr/iperf-doc.php" target="_blank" rel="noopener noreffer">iPerf user docs</a></p>
</li>
<li>
<p>[2] <a href="https://github.com/esnet/iperf" target="_blank" rel="noopener noreffer">iPerf Github</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>NAT 系列：问题及解决方法</title>
    <link>https://www.techkoala.top/nat_issues_solutions/</link>
    <pubDate>Wed, 15 Jul 2020 14:19:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat_issues_solutions/</guid>
    <description><![CDATA[<blockquote>
<p>NAT 引发的问题以及解决方法</p>
</blockquote>
<h2 id="问题">问题</h2>
<p>对称型 NAT（Symmetric NAT）常常在游玩联机游戏（尤其是 <code>P2P</code> 联机方式）时候给我们造成困扰。如果 <code>Xbox</code>、<code>PS</code>、<code>switch</code> 或者 <code>PC</code> 上的应用程序报告 NAT 是<code>严格</code>、<code>类型 3</code>、<code>类型 D</code>、<code>对称</code>这样的字样，那么就意味着你将会出现联机问题。</p>
<p>理解这个问题之前，首先要认识到，这些设备及软件是无法感知它们是否被 <code>NAT</code> 化的。但是，在 <code>Internet</code> 上与之通信的任何设备都应该使用公共 IP 地址，例如 <code>1.1.1.1</code>。在进行任何连接尝试时，都必须知道目标公共 IP 地址和端口。在上面的所有示例中，你应该发现了网站 IP 地址和端口均已知，这些地址是固定的，并且未曾发生更改。但是，某些程序会使用一系列动态端口。在运行游戏时，你的主机选择一个随机端口来进行游戏。由于其他主机不知道你的 IP 地址或端口，因此必须在连接之前以某种方式了解它。你的主机会将游戏的 IP 地址和端口发送到 <code>Xbox Live</code> 或 <code>PS</code> 网络，这样其他主机便可以在其中检索它，然后直接与你连接。但问题是，它发送的是内部 IP 地址 <code>192.168.0.1</code> 和端口 <code>54324</code>，而不是 Nat 后的公共 IP。它应该发送的是（例如）<code>1.1.1.1</code> 的公共 IP 地址和端口 <code>54324</code>。而且当处于对称型 NAT 时，该端口也会发生更改，因此它必须发送经过 NAT 处理的端口，例如 <code>54254</code>，而不是主机本身的内部端口（<code>54324</code>）。</p>
<p><strong>这不仅仅是游戏面对的问题，这一直是 NAT 的问题。</strong></p>
<p>那么，主机如何得知它位于 <code>NAT</code> 之后，并告诉其他主机将数据发送到 NAT 后的 IP 地址和端口而不是其自身的内部 IP 地址和端口？</p>
<h2 id="解决办法">解决办法</h2>
<h3 id="stunsession-traversal-utilities">STUN（Session Traversal Utilities）</h3>
<p>STUN 是 NAT 的 Session Traversal Utilities 的缩写，你可能已经猜到了它的名字，它是一个实用工具的集合，以帮助 NAT 设备穿越内网。简单地说，STUN 允许你的主机 / PC 或内部设备了解它的公共 NAT 的 IP 地址和端口是什么。一旦实现了这一点，你的设备现在可以发送正确的 IP 和端口，其他设备也可以连接到你。但是，它在对称型 NAT 下无法工作，在对称型 NAT 中，你的主机可以得知它的公共 IP 地址，但无法得知它的公共端口（因为，端口是 NAT 随机生成的）。</p>
<p>STUN 的工作原理很简单。你连接到一个运行 STUN 协议的服务器 (Xbox Live Servers)，它从接收的数据包中读取源 IP 地址和源端口，这些当然会是 NAT 后的（这是我们需要的）。然后 STUN 将这些信息返回给客户端，它的工作就完成了。你的主机现在知道了它的 NAT 后的 IP 和端口，并且会把这些信息发送到其他设备上。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/STUN_Algorithm.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/STUN_Algorithm.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/STUN_Algorithm.png" data-sub-html="<h2>STUN 算法</h2>">
        
    </a><figcaption class="image-caption">STUN 算法</figcaption>
    </figure>
<p>如果你还记得，除了<code>对称型 NAT</code> 之外，所有其他类型的 NAT 都不会改变源端口。这意味着当我的主机创建一个 NAT 映射时，它将对所有这种类型的连接使用它，当向互联网上的个设备发送和接收数据包时，它使用同一个映射，因此它使用相同的公共 IP 地址和端口；</p>
<p>但在对称型 NAT 的情况下，每一个连接都有一个不同的映射，有一个不同的（随机生成的）端口，意味着连接到 STUN 服务器也将有它自己独特的映射，表现的就像一个新的设备接入一样。这意味着每个映射都有不同的端口，在这种情况下，STUN 检测到的端口现在已经没有用了，因为这个映射是 STUN 服务器独有的。无论映射到其他设备的端口是什么，都是未知的，STUN 也没有办法检测到它。由于你的主机无法得知每个映射到每个主机的公共 NAT 化端口，因此无法将这些信息传递给你，也就意味着没有设备可以连接到你的游戏，这就是对称型 NAT 导致如此多游戏联机问题的原因。</p>
<h3 id="dmzdemilitarized-zone">DMZ（Demilitarized zone)</h3>
<p>路由器上的外围网络（也称 DMZ）功能用于消除对 Internet 的限制。它主要是将你的设备移到你的网络防火墙之外的区域，将部分用于提供对外服务的服务器主机划分到一个特定的子网 —— DMZ 内，在 DMZ 的主机能与同处 DMZ 内的主机和外部网络的主机通信，而同内部网络主机的通信会被受到限制。这使 DMZ 的主机能被内部网络和外部网络所访问，而内部网络又能避免外部网络所得知。</p>
<p><strong>注意</strong> 当你设置外围网络时在主机上使用静态 IP 地址十分重要。要设置静态 IP 地址，请使用路由器的 DHCP 预留功能（如果可用）。如果该功能不可用，你将需要在你的设备 上配置手动 IP 设置。</p>
<h3 id="upnpuniversal-plug-and-play">UPnP（Universal Plug and Play）</h3>
<p>UPnP（Universal Plug and Play）是帮助路由器有效通信的一个标准。如果路由器或网关支持 UPnP，则它在默认情况下可能已启用。开启 UPnP 功能后，局域网中的计算机可以请求路由器自动进行端口转换。这样，互联网上的计算机就能在需要时访问局域网计算机上的资源（如 MSN Messenger 或迅雷、BT、PPLive 等支持 UPnP 协议的应用程序）。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="www.think-like-a-computer.com/2011/09/19/symmetric-nat/" rel="">Symmetric NAT and It’s Problems | Think Like A Computer</a></p>
</li>
<li>
<p>[2] <a href="https://zh.wikipedia.org/wiki/STUN" target="_blank" rel="noopener noreffer">Wikipedia STUN</a></p>
</li>
<li>
<p>[3] <a href="https://zh.wikipedia.org/wiki/DMZ" target="_blank" rel="noopener noreffer">Wikipedia DMZ</a></p>
</li>
<li>
<p>[4] <a href="https://support.xbox.com/help/Hardware-Network/connect-network/xbox-one-nat-error" target="_blank" rel="noopener noreffer">解决 NAT 错误和多人游戏问题</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>NAT 系列：认识 NAT</title>
    <link>https://www.techkoala.top/nat/</link>
    <pubDate>Tue, 14 Jul 2020 23:25:54 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat/</guid>
    <description><![CDATA[<blockquote>
<p>一文概览 NAT</p>
</blockquote>
<h2 id="nat">NAT</h2>
<p>NAT（Network Address Translation，网络地址转换）在计算机网络中是一种在 <code>IP</code> 数据包通过路由器或防火墙时重写来源 <code>IP</code> 地址或目的 <code>IP</code> 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 <code>IP</code> 地址访问互联网的私有网络中。</p>
<p><code>NAT</code> 从大类上都可以分为两类：<code>静态 NAT</code> 和 <code>动态 NAT</code>。</p>
<p><code>静态 NAT</code> 是管理员手动创建和维护映射，通常与 <code>NAT</code> 的入站类型相关联。</p>
<p><code>动态 NAT</code> 是路由器根据需要自动创建和维护映射，通常与 <code>NAT</code> 的出站类型相关联。</p>
<p>每个 <code>TCP/IP</code> 数据包都包含一个 <code>源 IP 地址</code>、<code>源端口</code>、<code>目的 IP 地址</code> 和 <code>目的端口</code>。所有类型的 <code>NAT</code> 都会使用这些值创建 <code>NAT</code> 映射。</p>
<blockquote>
<p>例如，一个 IP 为 <code>192.168.0.1</code> 的内部客户机使用端口 <code>56876</code>，经过 NAT 转变后 IP 变为 <code>3.3.3.3</code>（翻译后的源 IP）和端口 <code>56876</code>（源端口）连接到 IP <code>2.2.2.2</code>（目的 IP 地址）的 <code>80</code> 端口（目的端口）。NAT 使用原始内部 IP 和端口、翻译后 IP 和端口这 4 个值创建一个映射。当数据包从网站返回到路由器时，使用与该映射相关值，NAT 将数据包转发到内部客户端。</p>
</blockquote>
<h2 id="nat-的四种类型">NAT 的四种类型</h2>
<h3 id="全锥型-natfull-cone-nat">全锥型 NAT（Full Cone NAT)</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Full_Cone_NAT.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Full_Cone_NAT.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Full_Cone_NAT.png" data-sub-html="<h2>全锥型 NAT</h2>">
        
    </a><figcaption class="image-caption">全锥型 NAT</figcaption>
    </figure>
<p><code>全锥型 NAT</code> 是静态 NAT，也是唯一一种永久开放端口的 <code>NAT</code>，允许从 <strong>任何外部主机</strong> 进行入站连接。<code>全锥型 NAT</code> 将一个公共 IP 地址和端口映射到 LAN IP 和端口。任何外部主机都可以通过映射的 <code>NAT </code>IP 和端口向 LAN IP 发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的 <code>NAT</code> 也被称为端口转发。这是受限制最少的 <code>NAT</code> 类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。</p>
<blockquote>
<p>例如，我的电脑有一个网站在 <code>80</code> 端口上运行，我创建了一个一对一的规则，将路由器的 WAN IP <code>1.1.1.1</code> 映射到 <code>192.168.0.1</code>，端口 <code>80</code> 映射到 <code>80</code> 端口。凡是在 <code>80</code> 端口向 <code>1.1.1.1</code> 发送数据的外部主机都会被 <code>NAT</code> 转发到 <code>192.168.0.1 80</code> 端口。</p>
</blockquote>
<p><strong>注意：</strong> 端口号不必相同；我可以在 <code>56456</code> 端口上运行我的网站，但创建 <code>NAT</code> 映射，将 <code>80</code> 端口转发到 <code>56456</code> 端口。这样，外部客户端就会认为我的网站在 <code>80</code> 端口上，而在任何其他端口上的连接尝试都会被丢弃。</p>
<h3 id="受限锥形-natrestricted-cone-nat">受限锥形 NAT（Restricted Cone NAT）</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Restricted_Cone_NAT.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Restricted_Cone_NAT.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Restricted_Cone_NAT.png" data-sub-html="<h2>受限锥形 NAT</h2>">
        
    </a><figcaption class="image-caption">受限锥形 NAT</figcaption>
    </figure>
<p><code>受限锥体 NAT</code> 是<code>动态 NAT</code>，它的工作方式与<code>全锥型 NAT</code> 相同，但会对进站的 IP 地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的 IP 地址。<strong>亦即需要内部主机首先发起连接的外部主机，才能被接受入站。</strong></p>
<blockquote>
<p>例如，我的电脑与一个网站 (<code>56.45.34.78</code>) 进行外向连接，源 <code>IP</code> 为 <code>192.168.0.1</code>，源端口为 <code>56723</code>。<code>NAT</code> 使用源端口 <code>56723</code> 创建一个（动态）映射到我的电脑。使用目的端口 <code>56723</code>（这是出站 NAT 的源端口）到达的<code>源 IP</code> 为 <code>56.45.34.78</code>（<code>网站 IP</code>）的数据包将被接受，接着网站返回数据至我的 <code>PC</code>。任何其他 IP 即使使用正确的 <code>56723</code> 端口进行连接尝试将被丢弃。同样，即使正确的 <code>IP</code> 使用 <code>56723</code> 以外的目的端口进行的连接尝试也将被丢弃。</p>
</blockquote>
<h3 id="端口受限锥型-natport-restricted-cone-nat">端口受限锥型 NAT（Port Restricted Cone NAT)</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Port_Restricted_Cone_NAT.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-sub-html="<h2>端口受限锥型 NAT</h2>">
        
    </a><figcaption class="image-caption">端口受限锥型 NAT</figcaption>
    </figure>
<p><code>端口受限锥型 NAT</code> 是<code>动态 NAT</code>，它的作用与<code>受限锥形 NAT</code> 完全相同，但同时对端口进行限制。<code>受限锥形 NAT</code> 接受来自外部主机任何源端口的连接，而<code>端口受限锥型 NAT</code> 则进一步要求外部主机的源端口是固定的。</p>
<blockquote>
<p>例如，我的电脑在 80 端口（目标端口）上向网站 IP <code>217.87.69.8</code> 建立了一个外向连接。NAT 将我的源 IP <code>192.168.0.1</code> 映射到 WAN IP <code>1.1.1.1</code> 和源端口 <code>56723</code>。当网站发回数据包时，它的源 IP 必须是 <code>217.87.69.8</code>，目的端口是 <code>56723</code>（就像一个受限锥型 NAT），但除此之外，还要求源端口必须是 <code>80</code>。如果这三者中的任何一个不一样，端口受限锥型 NAT 就会放弃连接。</p>
</blockquote>
<h3 id="对称型-natsymmetric-nat">对称型 NAT（Symmetric NAT）</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Symmetric_NAT.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Symmetric_NAT.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NAT/Symmetric_NAT.png" data-sub-html="<h2>对称型 NAT</h2>">
        
    </a><figcaption class="image-caption">对称型 NAT</figcaption>
    </figure>
<p><code>对称型 NAT</code> 是<code>动态 NAT</code>，它限制的方式与<code>端口受限锥型 NAT</code> 完全相同，但处理 NAT 转换的方式不同。目前讨论的所有类型的 <code>NAT</code> 在 <code>NAT</code> 连接时都 <strong>不会改变源端口</strong>。</p>
<blockquote>
<p>例如，当客户端使用 IP <code>192.168.0.1</code> 和源端口 <code>56723</code> 访问互联网时，<code>NAT</code> 将源 <code>IP</code> 改变为 <code>56.35.67.35</code>，但保持端口号不变，这被称为端口保留。</p>
</blockquote>
<p>而<code>对称型 NAT </code>会将端口改为 <strong>随机生成的新端口</strong>，甚至是同一客户端到不同目的地的连接也会发生。<strong>亦即为每个连接创建唯一的映射</strong></p>
<blockquote>
<p>例如，在<code>端口受限锥型 NAT</code> 的例子上进行扩展，我的 <code>PC</code> 向网站 <code>IP</code> <code>217.87.69.8</code> 和 <code>56.76.87.98</code> 建立两个出站连接。我的电脑使用源 <code>IP</code> <code>192.168.0.1</code> 和源端口 <code>56723</code> 进行两个连接。到目前为止，在所有类型的 <code>NAT</code> 上，这两个连接都会被 <code>NAT</code> 化，只改变源 IP 地址而保持源端口不变。然而这次，<code>对称型 NAT</code> 没有将源端口保留为 <code>56723</code>，而是将其中一个连接的源端口改为 <code>45765</code>，另一个连接的源端口改为 <code>53132</code>（随机）。这就为每个连接创建了唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以 <code>217.87.69.8</code> 必须将数据包发送到目的端口 <code>45765</code>，<code>56.76.87.98</code> 必须将数据包发送到端口 <code>53132</code>，此外还需要遵循<code>端口受限锥型 NAT</code> 的要求。</p>
</blockquote>
<h2 id="对-nat-的正面评价">对 NAT 的正面评价</h2>
<ol>
<li>
<p><code>NAT</code> 在一定程度上缓解了 <code>IPv4</code> 地址短缺的问题，让更多的设备（间接）接入了互联网。</p>
</li>
<li>
<p><code>NAT</code> 全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT 依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为 UDP 的跨局域网的传输提供了方便。</p>
</li>
</ol>
<h2 id="对-nat-的批评">对 NAT 的批评</h2>
<ol>
<li>
<p>在一个具有 <code>NAT</code> 功能的路由器下的主机并没有获得真正的 IP 地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的 TCP 连接和无状态协议（比如 UDP）无法实现。除非 <code>NAT</code> 路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。</p>
</li>
<li>
<p>端对端连接是被 IAB 委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为 <code>NAT</code> 是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地 IP 地址，所以他们必须通过 <code>NAT</code> 来访问 ISP 网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。</p>
</li>
<li>
<p><code>NAT</code> 使得 <code>IP</code> 协议从面向无连接变成立面向连接。<code>NAT</code> 必须维护专用 <code>IP</code> 地址与公用 IP 地址以及端口号的映射关系。在 <code>TCP/IP</code> 协议体系中，如果一个路由器出现故障，不会影响到 <code>TCP</code> 协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在 <code>NAT</code> 时，最初设计的 <code>TCP/IP</code> 协议过程将发生变化，<code>Internet</code> 可能变得非常脆弱。</p>
</li>
<li>
<p><code>NAT</code> 违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第 N 层是不能修改第 N+1 层的报头内容的。<code>NAT</code> 破坏了这种各层独立的原则。</p>
</li>
<li>
<p><code>NAT</code> 同时存在对高层协议和安全性的影响问题。<code>RFC</code> 对 <code>NAT</code> 存在的问题进行了讨论。NAT 的反对者认为这种临时性的缓解 <code>IP</code> 地址短缺的方案推迟了 <code>IPv6</code> 迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener noreffer">Wikipedia NAT</a></p>
</li>
<li>
<p>[2] <a href="https://think-like-a-computer.com/2011/09/19/symmetric-nat/" target="_blank" rel="noopener noreffer">What you need to know about symmetric NAT | Think Like A Computer</a></p>
</li>
<li>
<p>[3] <a href="https://portforward.com/nat-types/" target="_blank" rel="noopener noreffer">NAT Types Defined</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
