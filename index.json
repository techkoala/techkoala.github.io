[{"categories":["Web"],"content":" 搭建自己的在线 EPUB 阅读器 ","date":"2020-08-12","objectID":"/reader/:0:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"什么是 Netlify 引用 Netlify 官网的介绍： Netlify is a unified platform that automates your code to create high-performant, easily maintainable sites and web apps. 也就是说，Netlify 是一个提供静态网站托管的服务。它提供CI服务，能够将托管在 GitHub，GitLab 等网站上代码生成静态网站进行展示。类似于 Github Pages，不过功能更加丰富。 ","date":"2020-08-12","objectID":"/reader/:1:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"Koodo Reader Koodo Reader 是一个基于 React 和 Electron 开发的 Epub 阅读器。 Koodo Reader 首页\" Koodo Reader 首页 Koodo Reader 阅读界面\" Koodo Reader 阅读界面 提供以下功能： 📝 强大笔记和翻译功能，学习事半功倍 🚩 使用书架来为你的图书分类 🌎 支持 Windows ， MacOS 和 网页版 🖥 绑定 OneDrive， Google Drive， Dropbox 等网盘，实现数据的多端同步 💻 您所有的数据都支持导入导出 更多详情请点击 Koodo Reader 官网 查看。 ","date":"2020-08-12","objectID":"/reader/:2:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"搭建 首先进入 Netlify 官网，点击注册，这里我选择直接使用Github登录，当然，你也可以选择其他方式。 Netlify 注册\" Netlify 注册 注册登陆后，进入首页，点击右上角的 New Site from Git ，创建一个新的站点。 创建新站点\" 创建新站点 接下来，点击下方的 Github 进行授权，这里会弹出一个新的窗口，让你授权 Netlify 访问你的 Github 账户，完成授权后进去下一步。 使用Github 创建新站点\" 使用Github 创建新站点 这一步会让你选择你将用于生成站点的库，这里我已经提前 Fork troyeguo 的 Koodo Reader 库，所以直接选择即可。 选择相应的 Repo\" 选择相应的 Repo 接着，配置 Build 选项。在该项目的部署中，需要修改 Build name \u003e yarn build，Publish directory \u003e build/ ，其他保持默认即可。（如果配置其他项目，这里的参数可能不同，请参考具体项目的指导说明） 配置\" 配置 到这里，已经完成了整个部署工作，等待 Netlify 构建完成即刻。 配置\" 配置 Netlify 会给你默认分配一个二级域名用于访问，当然也支持自定义域名，这里我绑定了自己域名。除了在此处绑定外，还需要配置 DNS 等等，这个请自行完成。（由于搭建博客时，已经完成了相应设置，因此，我直接在 Cloudfalre 新建了一个 CNAME 指向 Netlify 给我的域名就好了） 配置\" 配置 大功告成，来这里看看书吧。 ","date":"2020-08-12","objectID":"/reader/:3:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"后续 如果需要对网站进行更新，只需要关注你的 Github Repo 即可。每次 commit 之后，Netlify 都会自动拉取更新并生成。 ","date":"2020-08-12","objectID":"/reader/:4:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"参考 [1] koodo-reader ","date":"2020-08-12","objectID":"/reader/:5:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["WirelessCommunication"],"content":" LTE 上行链路帧结构详细讲解 LTE 使用 SC (单载波)-FDMA 作为上行链路信号。 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:0:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"时隙结构 从下面的时隙结构可以看出，LTE上下行链路的时隙结构是相似的： 上行时隙结构\" 上行时隙结构 与下行链路相同，上行链路中的帧时间和时隙时间与下行链路中相同。并且资源块结构和下行链路上也相同。如上所述，在一个时隙中的 7 个符号在上行链路和下行链路上也是相同的。 你可能会注意到的一点区别是每个物理信道的位置。在下行链路情况下，信道通常占用整个带宽，但是上行链路时隙中的信道更局限。例如，PUCCH 仅位于整个带宽中的的最低端和最高端。 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:1:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUCCH RS 携带解调 PUCCH 所需的参考信号。这意味着如果此部分配置不正确或 eNodeB 检测不到此部件，则 eNodeB 无法解码 PUCCH。 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:1:1","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUCCH 此信道可以承载大量信息(UCI)，但根据配置的不同，它只能承载以下信息中的一部分： ACK/NACK for the recieved PDSCH data CQI RI PMI 正如你在时隙结构中看到的，PUCCH 以子帧内两个时隙之间交替的方式位于上行链路频域的两端，这意味着如果 PUCCH 是时隙 0 (第一个时隙) 中的频域的最低部分，并且它将位于时隙 1 (第二个时隙) 中的频域的最高部分。分配给 PUCCH 的资源元素的确切数量由网络确定，并且配置通过 SIB2 广播到 UE。 详细的 PUCHH 结构参考： PUCCH Format PUCCH Format 1,1a,1b Location PUCCH Format 2,2a,2b Location ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:1:2","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUSCH RS 携带解调 PUSCH 所需的参考信号。 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:1:3","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUSCH 承载 UE 尝试发送的上行链路数据。并且除了上行链路数据之外，还可以携带 UE 接收的 PDSCH 的 ACK/NACK。 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:1:4","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"SRS 参考 SRS in Quick Reference ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:1:5","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"上行资源网格 具体来说，上行资源还有一种网格格式，如下所示: 上行资源网格\" 上行资源网格 最小的单元是 “资源元素 (RE)”，最小的资源分配单元是 RB (资源块)，它沿时域跨越 7 RE，沿频域跨越 12 RE。 这意味着一个 RB 有 84 个单元 (7x12)。 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:2:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"通信中的信道 下图显示了上行/下行数据传输的总体顺序。你可以将数据传输序列图与 DL/UL 帧结构中每个通道的特定位置相关联。 LTE 上下行传输顺序图\" LTE 上下行传输顺序图 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:3:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"帧结构总览 上行帧结构概览\" 上行帧结构概览 ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:4:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"参考 [1] UL FrameStructure ","date":"2020-08-10","objectID":"/lte_uplink_frame_structure/:5:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["Network"],"content":" TCP、UDP 和 SCTP 的终极速度测试工具 ","date":"2020-08-07","objectID":"/iperf/:0:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"什么是 iPerf iPerf 是一个用于测量网络最大带宽的小工具。iPerf 可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和 UDP 特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。对于每个测试，它都会报告带宽，丢包和其他参数。 现在的版本也称 iPerf3，这是对 NLANR/DAST 开发的原始版本的重新设计。 注意：iPerf3 与此前版本的 iPerf 不兼容。 ","date":"2020-08-07","objectID":"/iperf/:1:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"安装 iPerf iPerf3 官方仅支持 CentOS Linux，FreeBSD 和 macOS，但实际上，官网提供了主流系统的预编译文件。（包括 Windows、Android、iOS、Ubuntu、Arch Linux 等） 类 UNIX 系统直接使用包管理进行安装即可，例如： $ sudo apt install iperf3 ","date":"2020-08-07","objectID":"/iperf/:2:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"使用 iPerf 首先，介绍服务端和客户端共有的参数： -p, --port n 服务器用于侦听和客户端连接的服务器端口，两者应该相同，默认值为 5201 --cport n 指定客户端端口 -f, --format 用于指定单位显示格式，支持 'k' = Kbits/sec 'K' = KBytes/sec 'm' = Mbits/sec 'M' = MBytes/sec，默认为自适应格式 -i, --interval n 设置测试信息报告之间的间隔时间（以秒为单位）。如果为零，则不打印任何定期报告。默认值为零。 -F, --file name 客户端：从文件读取并写入网络，而不是使用随机数据；服务器端：从网络读取并写入文件，而不是丢弃数据。 -A, --affinity 如果可以，设置 CPU 关联（仅限 Linux 和 FreeBSD）。 -B, --bind host 绑定到主机。对于客户端，这将设置出站接口。对于服务器，这将设置传入接口。这只适用于具有多个网络接口的多宿主主机。 -V, --verbose 提供更详细的输出 -J, --json 以 JSON 格式输出 --logfile file 输出到日志文件 --d, --debug 发出调试输出 -v, --version 输出版本信息 -h, --help 输出帮助信息 服务端特有参数： -s, --server 在服务器模式下运行 iPerf（一次只允许一个 iPerf 连接） -D, --daemon 将服务器作为守护进程在后台运行 -I, --pidfilefile 使用进程ID编写文件，这在作为守护进程运行时非常有用 客户端特有参数: -c, --client host 在客户端模式下运行 iPerf --sctp 使用 SCTP 而不是 TCP -u, --udp 使用 UDP 而不是 TCP -b, --bandwidth 将目标带宽设置为 nbits/sec（对于 UDP 默认为 1 Mbit/sec，对于 TCP 为无限制）。如果有多个流（-P 标志），则带宽限制将分别应用于每个流。您还可以在带宽说明符中添加一个 “/” 和一个数字。这称为 “突发模式”。 它会发送给定数量的数据包而不会暂停，即使该数据包暂时超过了指定的带宽限制 -t, --time 传输的时间（以秒为单位）。iPerf 通常通过在 t 时间内重复发送 len 长度的字节数组来工作。默认值为 10 秒 -n, --num 要传输的缓冲区数量。通常，iPerf 只会发送 10 秒。-n 选项覆盖此设置，并发送 len 长度字节数组 n 次，无论需要多长时间 -k, --blockcount 要传输的块（数据包）数 -l, --length 读取或写入的缓冲区的长度，iPerf 通过多次写入 len 个字节的数组来工作。TCP 的默认值为 128 KB，UDP 的默认值为 8 KB。 -P, --parallel 与服务器同时建立的连接数，默认值为 1 -R, --reverse 以反向模式运行（服务器发送，客户端接收） -w, --window 将套接字缓冲区大小设置为指定值。对于 TCP，这将设置 TCP 窗口大小（这将发送到服务器并在该侧使用） -M, --set-mss 尝试设置 TCP 最大段大小（MSS）。MSS 通常是 MTU-TCP/IP 标头的 40 个字节。对于以太网，MSS 为 1460 字节（1500 字节 MTU） -N, --no-delay 设置 “TCP no delay” 选项，禁用 Nagle 的算法。通常，仅对交互式应用程序（如 telnet）禁用此功能 -4, --version4 仅使用 IPv4. -6, --version4 仅使用 IPv6. -S, --tos 传出数据包的服务类型。(许多路由器会忽略TOS字段。）可以使用十六进制值（0x）作为前缀，使用八进制数（0）作为前缀，或者使用十进制来指定值。 例如，'0x10'十六进制='020'八进制='16'十进制。RFC 1349中指定的TOS编号为： IPTOS_LOWDELAY minimize delay 0x10 IPTOS_THROUGHPUT maximize throughput 0x08 IPTOS_RELIABILITY maximize reliability 0x04 IPTOS_LOWCOST minimize cost 0x02 -L, --flowlabel 设置 IPv6 流标签（当前仅在 Linux 上受支持） -Z, --zerocopy 使用 “零拷贝” 方法发送数据，如 sendfile（2），而不是通常的 write（2）。这样可以占用更少的 CPU -O, --omit 省略测试的前 n 秒，以跳过 TCP TCP 慢启动周期 -T, --title 为每个输出行添加此字符串前缀 -C, --linux-congestion 设置拥塞控制算法 (仅适用于 iPerf 3.1 的 Linux 和 FreeBSD)。 注意： 从客户端专有选项可以看出，iPerf 默认测试的是从客户端发送到服务端，相对于客户端来说，测试就是上行链路的带宽，对于一般参考意义更大的下行链路需要加上 -R 选项。 常用启用参数： 服务端 $ iperf3 -s -p 12345 -i 1 客户端 $ iperf3 -c 192.168.1.43 -p 12345 -i 1 -t 20 -w 100k iPerf 使用实例\" iPerf 使用实例 ","date":"2020-08-07","objectID":"/iperf/:3:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"参考 [1] iPerf user docs [2] iPerf Github ","date":"2020-08-07","objectID":"/iperf/:4:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Software"],"content":" SCP 的继承者 ","date":"2020-08-06","objectID":"/sftp/:0:0","tags":["Software","Linux"],"title":"文件传输 3：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"什么是 SFTP 首先需要明确的是，SFTP（SSH File Transfer Protocol）不是运行在 SSH 上的 FTP，而是由 IETF（Internet Engineering Task Force）工作组设计的新协议，将其作为 SSH 2.0 版的扩展，提供安全的文件传输功能。因此，没有单独的 SFTP 端口，而是使用普通的 SSH 端口。协议本身不提供身份验证和安全性，而是期望底层协议提供。 与仅允许文件传输的 SCP 协议相比，SFTP 协议允许对远程文件进行一系列操作，这使其更像远程文件系统协议。SFTP 客户端还支持包括恢复中断的传输，目录列表和远程文件删除等功能。此外，上传的文件可以与它们的基本属性相关联，例如时间戳。相比普通 FTP 协议，这是一项优势。 尽管 SFTP 最常在 Unix 平台上实现，但 SFTP 在主流平台都可用。 有关 SFTP 详细草案参见 draft-ietf-secsh-filexfer-02 ","date":"2020-08-06","objectID":"/sftp/:1:0","tags":["Software","Linux"],"title":"文件传输 3：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"使用 SFTP sftp 选项 参数 ","date":"2020-08-06","objectID":"/sftp/:2:0","tags":["Software","Linux"],"title":"文件传输 3：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"选项 -B：指定传输文件时缓冲区的大小； -l：使用 ssh 协议版本 1； -b：指定批处理文件； -C：使用压缩； -o：指定 ssh 选项； -F：指定 ssh 配置文件； -R：指定一次可以容忍多少请求数； -v：升高日志等级。 ","date":"2020-08-06","objectID":"/sftp/:2:1","tags":["Software","Linux"],"title":"文件传输 3：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"参数 目标主机：指定 SFTP 服务器 IP 地址或者主机名。 ","date":"2020-08-06","objectID":"/sftp/:2:2","tags":["Software","Linux"],"title":"文件传输 3：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"参考 [1] SSH File Transfer Protocol [2] SFTP Command ","date":"2020-08-06","objectID":"/sftp/:3:0","tags":["Software","Linux"],"title":"文件传输 3：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":" SCP 的另一个绝佳替选 ","date":"2020-08-05","objectID":"/rsync/:0:0","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"什么是 rsync rsync (remote synchronize) 是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync 是类 Unix 系统下的数据镜像备份工具。它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。 rsync 中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync 可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。 rsync 默认监听 TCP 端口 873，以原生 rsync 传输协议或者透过远程 shell 如 RSH 或者 SSH 提供文件。SSH 模式下，rsync 客户端运行程序必须同时在本地和远程机器上安装。 ","date":"2020-08-05","objectID":"/rsync/:1:0","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"rsync 算法 此部分内容转载 RSYNC 的核心算法 rsync 的算法如下：（假设源文件名为 fileSrc，目的文件叫 fileDst） ","date":"2020-08-05","objectID":"/rsync/:2:0","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"分块 Checksum 算法 首先，我们会把 fileDst 的文件平均切分成若干个小块，比如每块 512 个字节，然后对每块计算两个 checksum，一个叫 rolling checksum，是弱 checksum，32 位的 checksum，其使用的是 Mark Adler 发明的 adler-32 算法，另一个是强 checksum，128 位的，以前用 md4，现在用 md5。为什么要这样？因为若干年前的硬件上跑 md4 的算法太慢了，所以，需要一个快算法来鉴别文件块的不同，但是弱的 adler-32 算法碰撞概率太高了，所以我们还要引入强的 checksum 算法以保证两文件块是相同的。也就是说，弱的 checksum 是用来区别不同，而强的是用来确认相同。 ","date":"2020-08-05","objectID":"/rsync/:2:1","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"传输算法 同步目标端会把 fileDst 的一个 checksum 列表传给同步源，这个列表里包括了三个东西，rolling checksum (32bits)，md5 checksume (128bits)，文件块编号。同步源机器拿到了这个列表后，会对 fileSrc 做同样的 checksum，然后和 fileDst 的 checksum 做对比，这样就知道哪些文件块改变了。 但是 如果我 fileSrc 这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和 fileDst 这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？ 如果这个 checksum 列表特别长，而两边相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？ ","date":"2020-08-05","objectID":"/rsync/:2:2","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"Checksum 查找算法 同步源端拿到 fileDst 的 checksum 数组后，会把这个数据存到一个 hash table 中，用 rolling checksum 做 hash，以便获得 O(1) 时间复杂度的查找性能。这个 hash table 是 16 bits 的，所以，hash table 的尺寸是 2 的 16 次方，对 rolling checksum 的 hash 会被散列到 0 到 $ 2^{16} – 1 $ 中的某个整数值。 ","date":"2020-08-05","objectID":"/rsync/:2:3","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"比对算法 取 fileSrc 的第一个文件块（我们假设的是 512 个长度），也就是从 fileSrc 的第 1 个字节到第 512 个字节，取出来后做 rolling checksum 计算。计算好的值到 hash 表中查询。 如果查到了，说明发现在 fileDst 中有潜在相同的文件块，于是就再比较 · 的 checksum，因为 rolling checksume 太弱了，可能发生碰撞。于是还要算 md5 的 128 bits 的 checksum，这样一来，我们就有 $2^{-(32+128)} = 2^{-160} $ 的概率发生碰撞，这小到可以忽略。如果 rolling checksum 和 md5 checksum 都相同，那就可以说明在 fileDst 中有相同的块，记下这一块在 fileDst 下的文件编号。 如果 fileSrc 的 rolling checksum 没有在 hash table 中找到，那就不用算 md5 checksum 了。表示这一块中有不同的信息。总之，只要 rolling checksum 或 md5 checksum 其中有一个在 fileDst 的 checksum hash 表中找不到匹配项，那么就会触发算法对 fileSrc 的 rolling 动作。于是，算法会住后 step 1 个字节，取 fileSrc 中字节 2-513 的文件块要做 checksum，然后继续第一步 – 这就是为什么叫 rolling checksum 。 这样，我们就可以找出 fileSrc 相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。 ","date":"2020-08-05","objectID":"/rsync/:2:4","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"Rolling Checksum 算法 rolling checksum 算法也叫 Rabin-Karp 算法，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它用来解决多模式串匹配问题。其最大的精髓是，当往后面 step 1 个字符的时候，不用全部重新计算所有的 checksum，也就是说，从 [0, 512] rolling 到 [1, 513] 时，不需要重新计算从 1 到 513 的 checksum，而是重用 [0，512] 的 checksum 直接算出来。 其公式可以表示为： hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0 其中的 b 是一个常数基数，在 Rabin-Karp 算法中，一般取值为 256。 于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了： hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1) + t[m] * b ^0 rsync 算法示意\" rsync 算法示意 最终，得到的数据组可以想象为 BT 协议下载 torrent ：一些文件块已下载（匹配上），其他的文件块还未下载（未匹配上）。然后，同步端将这些未匹配上的文件打上标号发送，目的端根据标号重组文件就完成了同步。 ","date":"2020-08-05","objectID":"/rsync/:3:0","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"使用 rsync rsync [OPTION]... SRC DEST rsync [OPTION]... SRC [USER@] host:DEST rsync [OPTION]... [USER@] HOST:SRC DEST rsync [OPTION]... [USER@] HOST::SRC DEST rsync [OPTION]... SRC [USER@] HOST::DEST rsync [OPTION]... rsync://[USER@] HOST [:PORT]/SRC [DEST] 对应于以上六种命令格式，rsync 有六种不同的工作模式： 拷贝本地文件。当 SRC 和 DES 路径信息都不包含有单个冒号 “:” 分隔符时就启动这种工作模式。如：rsync -a /data/backup 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 DST 路径地址包含单个冒号 “:” 分隔符时启动该模式。如：rsync -avz *.c foo:src 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将远程机器的内容拷贝到本地机器。当 SRC 地址路径包含单个冒号 “:” 分隔符时启动该模式。如：rsync -avz foo:src/bar/data 从远程 rsync 服务器中拷贝文件到本地机。当 SRC 路径信息包含 “::” 分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack 从本地机器拷贝文件到远程 rsync 服务器中。当 DST 路径信息包含 “::” 分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www 列出远程主机的文件列表。这类似于 rsync 传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www 可用选项如下： -v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -C, --cvs-exclude 使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 - rlptgoD。 -r, --recursive 对子目录以递归模式处理。 -R, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为～filename。可以使用 --suffix 选项来指定不同的备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。 -l, --links 保留软链结。 -L, --copy-links 想对待常规文件一样处理软链结。 -H, --hard-links 保留硬链结。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -D, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -S, --sparse 对稀疏文件进行特殊处理以节省 DST 的空间。 -T --temp-dir=DIR 在 DIR 中创建临时文件。 -n, --dry-run 现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是 700 字节。 -e, --rsh=command 指定使用 rsh、ssh 方式进行数据同步。 -P 等同于 --partial。 -z, --compress 对备份的文件在传输时进行压缩处理。 -h, --help 显示帮助信息。 --backup-dir 将备份文件 (如～filename) 存放在在目录下。 -suffix=SUFFIX 定义备份文件前缀。 --copy-unsafe-links 仅仅拷贝指向 SRC 路径目录树以外的链结。 --safe-links 忽略指向 SRC 路径目录树以外的链结。 --rsync-path=PATH 指定远程服务器上的 rsync 命令所在路径信息。 --existing 仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。 --delete 删除那些 DST 中 SRC 没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现 IO 错误也进行删除。 --max-delete=NUM 最多删除 NUM 个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组 id 匹配为用户名和组名。 --timeout=time ip 超时时间，单位为秒。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为 0。 --compare-dest=DIR 同样比较 DIR 中的文件来决定是否需要备份。 --progress 显示备份过程。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除 FILE 中指定模式的文件。 --include-from=FILE 不排除 FILE 指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的 rsyncd.conf 文件。 --port=PORT 指定其他的 rsync 服务端口。 --blocking-io 对远程 shell 使用阻塞 IO。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=formAT 指定日志文件格式。 --password-file=FILE 从 FILE 中得到密码。 --bwlimit=KBPS 限制 I/O 带宽，KBytes per second。 ","date":"2020-08-05","objectID":"/rsync/:4:0","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"参考 [1] The rsync algorithm [2] RSYNC 的核心算法 [3] rsync wikipedia [4] rsync command ","date":"2020-08-05","objectID":"/rsync/:5:0","tags":["Software","Linux"],"title":"文件传输 2：rsync","uri":"/rsync/"},{"categories":["Github"],"content":" 最常用的 Git Log 技巧令总结 ","date":"2020-08-01","objectID":"/git_log/:0:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"概览提交历史 $ git log —oneline 该命令帮助您以更清晰的方式查看提交。每个提交仅显示为一行，并且只有最少量的信息，比如提交哈希、提交消息。 ","date":"2020-08-01","objectID":"/git_log/:1:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"显示详细更改信息 $ git log -p 此命令会显示更新的详细更改信息，方便查阅。 ","date":"2020-08-01","objectID":"/git_log/:2:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"根据时间筛选 $ git log --after=\"2020-15-05\" $ git log --after=\"2020-15-05\" --before=\"2020-25-05\" $ git log --after=\"yesterday\" // 显示昨天的提交 $ git log --after=\"today\" // 显示今天的提交 $ git log --before=\"10 day ago\" // 显示最近十天的提交 $ git log --after=\"1 week ago\" // 显示上周以来的提交 $ git log --after=\"2 month ago\" // 显示近两个月的提交 上述命令将按给定的时间段过滤出提交。 例如，--after 将仅筛选给定时间段之后的提交，而 --before 将仅筛选给定时间段之前的提交。 ","date":"2020-08-01","objectID":"/git_log/:3:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"根据作者筛选 $ git log --author=\"techkoala\" 该命令会显示由 techkoala 提交的更改。当然，可以结合上面介绍的命令，进行更加精确的筛选，例如： $ git log --after=\"1 week ago\" --author=\"techkoala\" -p ","date":"2020-08-01","objectID":"/git_log/:4:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"根据 log 信息筛选 $ git log --grep=\"ISSUE-43560\" 需要注意的是，上述筛选字段区分大小写，如果需要不区分，请加上 -i 选项。 此外，还支持正则表达式： $ git log -i --grep=\"issue-43560\\|issue-89786\" ","date":"2020-08-01","objectID":"/git_log/:5:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"根据文件筛选 $ git log Git_Log.md 该命令显示针对特定文件的的提交历史。 当然，可以传入多个文件： $ git log Git_Log.md Github_Issue.md 同样的，结合别的命令可以做出更精确的筛选，例如： $ git log -i --grep=\"fix \" Git_Log.md Github_Issue.md ","date":"2020-08-01","objectID":"/git_log/:6:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"根据文件内容筛选 $ git log -S\"function login()\" 上述命令帮你在源代码中搜索已添加到提交历史记录中的特定字符串。同样的，加上 -i 可以不区分大小写。 ","date":"2020-08-01","objectID":"/git_log/:7:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"仅显示合并提交 $ git log --merges 该命令显示当前分支上合并的提交。 ","date":"2020-08-01","objectID":"/git_log/:8:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"显示不同分支间的区别 $ git log master..develop 该命令将显示所有来自 develop 但不在 master 分支的提交。 ","date":"2020-08-01","objectID":"/git_log/:9:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"自定义 log 信息格式 $ git log --pretty=format:\"%Cred%an - %ar%n %Cblue %h -%Cgreen %s %n\" Git提供了用于自定义日志消息格式的选项，你可以查看自定义漂亮选项（custom pretty options ）以获得更多选项。 ","date":"2020-08-01","objectID":"/git_log/:10:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Github"],"content":"参考 [1] Ten Useful Git Log Tricks [2] Git 基础 - 查看提交历史 ","date":"2020-08-01","objectID":"/git_log/:11:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["WirelessCommunication"],"content":" 概述 LTE 信息帧中的各类物理通道和信号 在 此前的一篇文章 中，我们详细了解 LTE 下行链路的帧结构，其中包含了各种物理信道和信号，本文将会做一个概要性的讲述，用作一个速查表。 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:0:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PBCH Physical Broadcast Channel，物理广播通道 它只携带 MIB (master information block，主系统信息块) 它使用的是 QPSK 映射到 6 个资源块（72 个子载波），以 0 号子帧中的 DC 子载波为中心 映射到不为传输参考信号、PDCCH 或 PCHICH 而保留的资源元素 详情参考 Physical Layer : PBCH 和 Matlab Toolbox : PBCH 页面（待填坑） ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:1:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PCFICH Physical Control Format Indicator Channel，物理控制格式指示通道 它映射到每个下行链路子帧中的第一个 OFDM 符号 它包含了携带控制信道（PDCCH 和 PHICH）的 OFDM 符号数量的信息。UE 对该信道进行解码，以找出该帧中为控制信道（PDCCH 和 PHICH）分配了多少个 OFDM 符号 它是子帧的第一个 OFDM 符号的 16 个数据子载波 PCFICH 数据由 4 个 REG 承载，并且这 4 个 REG 均匀分布在整个频带上，与带宽无关 PCFICH 的确切位置由小区 ID 和带宽确定 详细信息参阅 Physical Layer : PCFICH 和 Matlab Toolbox : PCFICH 页面 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:2:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PDCCH Physical Downlink Control Channel，物理下行控制信道 映射到下行链路每个子帧中前 L 个 OFDM 符号 PDCCH 的符号数（L）可以是 1,2 或 3 PDCCH 的符号数由 PCFICH 指定 PDCCH 承载 DCI，而 DCI 承载传输格式，资源分配，与 DL-SCH，UL-SCH 和 PCH 相关的 H-ARQ 信息以及其他取决于 DCI 格式的信息 PDCCH 还携带用于 UL 调度分配的 DCI 0（例如，UL 授权） 可以在单个子帧中分配多个 PDCCH，并且 UE 对所有 PDCCH 进行盲解码 调制方案是 QPSK PDCCH 类似于 HSDPA 的 HS-SCCH、R99 的 PDCCH 和 HSUPA 的 E-AGCH/E-RGCH 即使 PDCCH 具有很多功能，但并非所有功能都同时使用，因此 PDCCH 配置应灵活设置 如果您对该通道中的详细信息映射感兴趣，请参阅 36.211 中的 6.8.1。简要说明如下： 物理下行链路控制信道承载调度分配和其他控制信息。物理控制信道是在一个或几个连续的控制信道元素（CCE）的聚合上发送的，其中控制信道元素对应于 9 个资源元素组。未分配给 PCFICH 或 PHICH 的资源元素组的数量为 REG N。系统中可用的 CCE 从 0 和 N_CCE-1 编号，其中 N_CCE = floor（N_REG/9）。 详细信息参阅物理层 Physical Layer : PDCCH 和 Matlab Toolbox : PDCCH 页面 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:3:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PHICH Physical Hybrid ARQ Indicator Channel，物理 HARQ 指示信道 对收到的 PUSCH 进行 H-ARQ 反馈 UE 在 UL 中传输数据后，等待 PHICH 进行 ACK 类似于 HSPA 中的 E-HICH 某些情况下，几个 PHICH 使用相同的资源元素构成 PHICH 组 详细信息参见 Physical Layer : PHICH 和 Matlab Toolbox : PHICH 页面 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:4:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PDSCH Physical Downlink Shared Channel，物理下行共享信道 携带用户特定的数据（DL 有效负载） 携带随机访问响应消息 它使用带有 QPSK，16 QAM，64 QAM，256 QAM 调制方案的 AMC（此调制方案由 DCI 承载的 MCS 确定） 详细信息参见 Physical Layer : PDSCH 和 Matlab Toolbox : PDSCH 页面 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:5:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PRACH Physical Random Access Channel，物理随机接入信道 携带随机访问前导码 它在频域中占用 72 个子载波（6 RB）的带宽 在该信道内是随机访问前导，该随机访问前同步码用 Zadoff-Chu 序列 生成 详细信息参见 RACH 和 Matlab Toolbox : PRACH 页面 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:6:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"P-SS Primary Synchronization Signal，主同步信号 映射到 72 个活动子载波（6 个资源块），以时隙 0（子帧 0）和时隙 10（子帧 5）中的 DC 子载波为中心。 由 62 个 Zadoff-Chu 序列值 组成 用于下行帧同步 决定 物理小区 ID 的关键因素之一 详细信息参见 Physical Layer : PSS 和 Matlab Toolbox : PSS 页面 如何从基带捕获的 IQ 数据序列中找到 PSS 的确切位置？是定时同步中最重要的部分之一；也是理解 LTE 协议中非常棘手的部分之一，需要花费很长时间进行研究。 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:7:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"S-SS Secondary Synchronization Signal，副同步信号 SSS 是用于无线电帧同步的特定物理层信号，它具有以下列出的特征： 映射到 72 个活动子载波（6 个资源块），以 FDD 中的时隙 0（子帧 0）和时隙 10（子帧 5）的 DC 子载波为中心 子帧 0 中的 SSS 序列与子帧 5 中的 SSS 序列互不相同 由 62 个加扰序列（基于 m 序列）组成 奇偶索引的资源元素的值由不同方程生成 用于下行帧同步 决定 物理小区 ID 的关键因素之一 详细信息参见 Physical Layer : SSS 和 Matlab Toolbox : SSS ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:8:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS Reference Signal，参考信号 大多数信道（例如，PDSCH，PDCCH，PBCH 等）都用于承载特殊信息（比特序列），它们与更高层的信道相连，但是参考信号是仅存在于 PHY 层的特殊信号，不用于传递任何特定信息。参考信号的目的是为下行链路功率提供参考点。 当 UE 尝试计算 DL 功率（即，来自 eNode-B 的信号的功率）时，它将测量参考信号的功率并将其作为下行链路小区功率。 这些参考信号由每个时隙中的多个特定资源元素承载，并且资源元素的具体位置由天线配置确定。 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:9:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - Cell Specific 在下图中，红色/蓝色/绿色/黄色是承载参考信号的部分，灰色标记的资源元素是为参考信号保留的部分，但未承载该特定天线的参考信号。（插图基于 36.211 的图 6.10.1.2-1： 下行链路参考信号的映射（正常循环前缀）） 小区特定参考信号\" 小区特定参考信号 以下是 4 天线情况下物理信道配置和 RE（资源元素）映射的示例。测量结果来自 LTE 信号分析仪，它测量从 LTE 网络模拟器传出的 LTE 信号。它仅显示 20 Mhz 系统带宽中的一个 RB（RB0）（总共 100 个 RB），并且分别在 LTE 网络发送 MIB/SIB 和 UE 未连接时在天线端口 0、1、2、3 处捕获。你会注意到，每个天线的参考信号位置都不同。 由于此参考信号位置的差异，REG 分组可能由 PCFICH 的不同位置中略有不同。 各天线小区特定参考信号\" 各天线小区特定参考信号 有两种不同类型的参考信号：小区特定参考信号和 UE 特定参考信号 小区特定参考信号（CRS）：该参考信号在每个子帧处被发送，并且跨越整个工作带宽，通过天线端口 0、1、2、3 发送。 UE 特定参考信号：此参考信号在仅分配给特定 UE 的资源块中传输，并通过天线端口 5 传输。 特定于小区的参考信号的资源元素是否固定？ 否，位置会根据物理小区 ID 进行更改，如下所述： 参考信号的时域索引（l）= 固定（l = [0,4]） 参考信号的频域索引 k 根据 36.211 6.10.1.2 映射到资源元素中指定的物理小区 ID 而变化。 主要规则是：$k = 6m + (v + v_{shift})mod 6$，其中v_shift=物理小区ID mod6。详细信息参阅 36.211 6.10.1.2 下行参考信号携带什么样的值？ 该值是 36.211 6.10.1.1 序列生成中定义算法生成的伪随机序列。该序列的确定值之一是物理小区 ID，这意味着物理小区 ID 也影响参考信号的值。 CRS 是否以任何子帧类型（类型 1、2、3）传输？ 对于帧结构类型 1，在所有下行链路子帧中发送 CRS。 对于帧结构类型 2，在所有下行链路子帧和 DwPTS 中发送 CRS 对于帧结构类型 3，CRS 在非空子帧中传输 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:9:1","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - MBSFN 下图基于 36.211 的图 6.10.2.2-1：MBSFN 参考信号的映射（扩展循环前缀，Δf= 15 kHz） Reference Signal - MBSFN\" Reference Signal - MBSFN ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:9:2","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - UE Specific 下图基于 36.211 的图 6.10.3.2-1：特定于 UE 的参考信号，天线端口 5（正常循环前缀）的映射 Reference Signal - UE Specific - Antenna Port 5\" Reference Signal - UE Specific - Antenna Port 5 Reference Signal - UE Specific - Antenna Port 5\" Reference Signal - UE Specific - Antenna Port 5 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:9:3","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - Positioning 下图基于 36.211 的图 6.10.4.2-1：定位参考信号的映射（正常循环前缀） Reference Signal - Positioning - Antenna Port 6\" Reference Signal - Positioning - Antenna Port 6 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:9:4","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - CSI 下图基于 36.211 的图 6.10.5.2-1：CSI 参考信号的映射（CSI 配置 0，常规循环前缀） Reference Signal - CSI - Antenna Port 15,16,17,18,19,20,21,22\" Reference Signal - CSI - Antenna Port 15,16,17,18,19,20,21,22 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:9:5","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"全帧快照 下图展示了上述提及的所有物理信道在整个框架上的整体图像： Full Frame\" Full Frame ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:10:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"通信过程中的物理信道 下图显示了上行/下行数据传输的总体顺序： 数据传输序列图\" 数据传输序列图 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:11:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"附加图 Spectrogram - LTE FDD DL - Radio Frame\" Spectrogram - LTE FDD DL - Radio Frame Spectrogram - LTE FDD DL - PBCH\" Spectrogram - LTE FDD DL - PBCH Spectrogram - LTE FDD DL - PSS/SSS\" Spectrogram - LTE FDD DL - PSS/SSS Spectrogram - LTE FDD DL - Each Symbol\" Spectrogram - LTE FDD DL - Each Symbol ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:12:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"参考 [1] Physical Channels and Signals [2] LTE的信道 ","date":"2020-07-30","objectID":"/lte_physical_channels_and_signals/:13:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":null,"content":"Network DigitalOcean Nginx Tool: Nginx Config 生成 ","date":"2020-07-30","objectID":"/tools/:1:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Reading Epub在线阅读 网站测速： BOCE 17CE 网络测速: CloudFlare Speed Test Speedtest by Ookla 测速网 IP\u0026DNS 测试： WHOER ipleak DnsLeakTest IPv6: 国家 IPv6 发展检测平台 IPv6 发展监测平台目录服务 ","date":"2020-07-30","objectID":"/tools/:2:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Wireless Communication Sandesh Dhagle’s Resource Grid Tools: LTE 资源网格生成 ","date":"2020-07-30","objectID":"/tools/:3:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Linux Linux Command：Linux命令搜索引擎命令 ","date":"2020-07-30","objectID":"/tools/:4:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Pics webp2jpg：图片格式转换 sm.ms：图床 Favicon Generator：网站图标生成 ","date":"2020-07-30","objectID":"/tools/:5:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Security 文件安全在线检测： Virustotal 微步在线威胁情报社区 ","date":"2020-07-30","objectID":"/tools/:6:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"File Share TMP.LINK：文件上传分享 transfer.sh：命令行文件上传分享 Unicode Text Converter: Unicode 文本转换 ","date":"2020-07-30","objectID":"/tools/:7:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Others 能不能好好说话？：网络缩写翻译 ","date":"2020-07-30","objectID":"/tools/:8:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":["WirelessCommunication"],"content":" LTE 下行链路帧结构详细讲解 ","date":"2020-07-29","objectID":"/lte_downlink_frame_structure/:0:0","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"下行帧结构 ","date":"2020-07-29","objectID":"/lte_downlink_frame_structure/:1:0","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"FDD——类型 1 36.211 中 FDD LTE 的帧结构概览图如下所示： FDD 帧结构\" FDD 帧结构 上图仅显示了帧在时域上的结构，而没有显示频域上的结构。 从图中可以看处： 一帧（一个无线帧，一个系统帧）的持续时间是 10 ms。 一帧（10 毫秒）的样本数是 307200（307.200 K）。 一帧中有 10 个子帧。 一个子帧中有 2 个时隙。 那么一个时隙是时域上最小的结构吗？不，如果进一步放大此结构，则会得到下图： 时隙结构\" 时隙结构 可以观察到一个时隙由 7 个符号组成。（一个符号是信号的某个时间跨度，在 I/Q 星座中的一个点。） 在符号的开头，还有一个很小的跨度，称为循环前缀，其余部分是真实的符号数据。 LTE 中有两种不同类型的循环前缀。一种是普通循环前缀；另一个是扩展循环前缀，其长度比普通循环前缀更长。（由于一个时隙的长度是固定的且不能更改，因此，如果使用扩展循环前缀，则一个时隙内则只能有 6 个符号）。 继续放大子帧以可以观察到确切的时间和采样，如下图所示： 符号结构\" 符号结构 此图中显示的长度不随采样率而变化，但是每个符号和 CP 中的采样数随采样率而变化。此图中显示的样本数基于 30.72 Mhz 采样率的情况。 关于上述子帧结构，需要注意的几件事是： 时隙中的第一个 OFDM 符号比剩下的 OFDM 符号长一些。 上图中显示的样本数基于以下参数设置：采样率为 30.72M 个样本/秒和 2048 个 bin/IFFT（$N_{ifft}$）。实际采样率和 $N_{ifft}$ 可能会随系统带宽而变化，需要根据特定带宽来缩放。 每种系统带宽的典型 $N_{ifft}$ 如下: System BW Number of RBs $N_{ifft}$ (bins/IFFT) 1.4 6 128 3.0 15 256 5.0 25 512 10.0 50 1024 15.0 75 2048 20.0 100 2048 下图是LTE 资源网格的总体子帧结构： LTE 资源网格\" LTE 资源网格 以下显示所有 4 个天线信号叠加（重叠）的理想情况下的下行链路帧结构和 RE（Resource Element，资源元素）映射的示例。 4天线帧结构和 RE 映射示例\" 4天线帧结构和 RE 映射示例 实际上，来自每个天线的信号具有略微不同的符号数据和参考信号位置。 RE 映射的顶部和底部显示的星座图是 LTE 信号分析器测量来自 LTE 网络模拟器的 LTE 信号的测量结果。这是在 LTE 网络正在传输 MIB/SIB 且 UE 未连接的情况下在天线端口 0 处捕获的。如果您使用不同的信道功率（例如 PCFICH 功率，PDCCH 功率，CRS 功率等）执行类似的操作，则可能会看到一些不同的星座图。 现在我们进一步放大结构，但这一次是在频域而不是时域扩展。我们将获得以下完整的详细图： 下行帧结构物理信道\" 下行帧结构物理信道 如上所述，我们可以在二维图中表示LTE信号。横轴是时域，纵轴是频域。纵轴上的最小单位是子载波，横轴上的最小单位是符号。时域和频域多个较小单位组合成较大单位。 首先让我们看一下频域结构： LTE（无论 OFDM/OFDMA）频带由多个小间隔信道组成，这些小信道称为子载波。 无论 LTE 频带的系统带宽是多少，子载波间隔都相同。 如果 LTE 信道的系统带宽发生变化，则信道数（子载波）会发生变化，但信道之间的间隔不会发生变化。 子载波和下一个子载波之间的空间是多少？ 15 Khz 20 Mhz LTE 频段的信道（子载波）数量是多少？ 1200个子载波。 10 Mhz LTE 频段的信道（子载波）数量是多少？ 600个子载波。 5 Mhz LTE 频段的信道（子载波）数量是多少？ 300个子载波。 接着我们看一下横轴（即时域）的上的基本组成单位。时域上的最小单位是符号，长度为 66.7 us。无论带宽如何，符号长度都不会改变。 一个时隙中有多少个符号？ A\u003e 7 个符号。 一个子帧中有多少个符号？ A\u003e 14 个符号。 一个帧中有几个时隙？ A\u003e 20个时隙。 现在，让我们看一下由时域（横轴）和频域（竖轴）组成的单位。我们将此类型的单元称为二维单元。 最小的二维单位是 RE，它由时域中的一个符号和频域中的一个子载波组成。另一个二维单位是 RB（Resource Block，资源块），它由时域中的一个时隙和频域中的 12 个子载波组成。RB 是 LTE 中协议侧和 RF 测量侧最重要的单元。 一个资源块中有多少个符号？ 7个符号。 一个资源块中有多少个子载波？ 12个子载波。 一个资源块中有多少资源元素？ 84个资源元素。 那么 20 Mhz频带中有多少资源块？ 100个资源块。 10 Mhz频带中有多少资源块？ 50个资源块。 5 Mhz频带中有多少资源块？ 25个资源块。 ","date":"2020-07-29","objectID":"/lte_downlink_frame_structure/:1:1","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"TDD——类型 2 TDD 帧结构\" TDD 帧结构 以下是使用 Sandesh Dhagle’s Resource Grid Tools 生成的各种配置的 TDD UL/DL 资源分配图。 类别 颜色 PDCCH 橙色 PBCH 蓝色 PSS 紫色 SSS 浅蓝色 PDSCH 白色 Reserved 黑色 Ref Signal 红色 PCFICH 浅绿色 PHICH 黄色 TDD Uplink 绿色 Guard Period 灰色 Configuration 0, Special Subframe Config 0\" Configuration 0, Special Subframe Config 0 Configuration 1, Special Subframe Config 0\" Configuration 1, Special Subframe Config 0 Configuration 2, Special Subframe Config 0\" Configuration 2, Special Subframe Config 0 Configuration 3, Special Subframe Config 0\" Configuration 3, Special Subframe Config 0 Configuration 4, Special Subframe Config 0\" Configuration 4, Special Subframe Config 0 Configuration 5, Special Subframe Config 0\" Configuration 5, Special Subframe Config 0 Configuration 6, Special Subframe Config 0\" Configuration 6, Special Subframe Config 0 下面展示具有不同特殊子帧配置的资源网格的示例。在这些示例中，仅注意子帧0和子帧6中的符号结构如何变化。 Configuration 0, Special Subframe Config 0\" Configuration 0, Special Subframe Config 0 Configuration 0, Special Subframe Config 1\" Configuration 0, Special Subframe Config 1 Configuration 0, Special Subframe Config 2\" Configuration 0, Special Subframe Config 2 Configuration 0, Special Subframe Config 3\" Configuration 0, Special Subframe Config 3 Configuration 0, Special Subframe Config 4\" Configuration 0, Special Subframe Config 4 Configuration 0, Special Subframe Config 5\" Configuration 0, Special Subframe Config 5 Configuration 0, Special Subframe Config 6\" Configuration 0, Special Subframe Config 6 Configuration 0, Special Subframe Config 7\" Configuration 0, Special Subframe Config 7 Configuration 0, Special Subframe Config 8\" Configuration 0, Special Subframe Config 8 ","date":"2020-07-29","objectID":"/lte_downlink_frame_structure/:1:2","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"LAA——类型 3 从 3GPP Rel 13 开始，提出了一种新的帧结构，主要应用于 LAA（License Assisted Access，许可辅助访问），与 LTE-U 一样，这也是一种在未经许可的频率范围内传输 LTE 信号的技术。 然而，与 LTE-U 不同的是，LAA 使用一种特殊的物理层帧结构，称为帧结构类型 3，这是以前不存在的。这种新的帧结构旨在使 LTE 信号类似于 WLAN 突发，并使 LTE 信号更好地与现有的 WLAN 业务共存。更多详情参见 LAA。 ","date":"2020-07-29","objectID":"/lte_downlink_frame_structure/:1:3","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"参考 [1] Frame Structure - Downlink [2] Sandesh Dhagle’s Resource Grid Tools ","date":"2020-07-29","objectID":"/lte_downlink_frame_structure/:2:0","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["Algorithm"],"content":" 最常见的 SHA-2 算法是如何实现的？本文逐步为你讲解。 SHA-2 (Secure Hash Algorithm 2)，是最流行的哈希算法之一，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。 SHA-2 以安全和速度著称，在未生成密钥的情况下（例如挖掘比特币），像 SHA-2 这样的快速哈希算法通常占据上风。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:0:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"哈希函数（Hash Function） 如果，你还不清楚哈希是什么，可以参见我的另外一篇文章 简单来说，哈希函数的拥有如下三个重要特性： 哈希函数对数据进行确定性加扰。 无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。 无法从加扰数据中检索原始数据（单向函数）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:1:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"SHA-2 vs SHA-256 有人可能会困惑：欸？我平时看到的都是 SHA-128、SHA-256 等等，这个 SHA-2 又是什么？ SHA-2 是一种算法，一种关于如何哈希数据的广义思想。SHA-256 设置了定义 SHA-2 算法行为的附加常量。其中一个常量是输出大小，“256” 和 “512” 是指它们各自的输出摘要大小（以位为单位）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:2:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"逐步详解 SHA-256 接下来举例说明 SHA-256 如何工作: ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第一步：消息预处理 将 hello world 转换为二进制 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 尾部追加单独的 1 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 1 填充 0 直到数据为 512 的整数倍，再减去 64 位（在本例中剩下 448 位）： 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 在末尾附加新的 64 位，这 64 位是一个大端整数，用于表示原始二进制输入的长度。在本文的例子中，是 88，或者二进制，1011000。 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01011000 现在，得到了初始的输入值（通过对消息进行补位处理，最终的长度应该是 512 位的倍数）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:1","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第二步：初始化哈希值（h） 现在，初始化 8 个哈希值。这些是硬编码的常数，分别代表前 8 个素数（2、3、5、7、11、13、17、19）的平方根的小数部分的前 32 位： h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:2","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第三步：初始化圆常数(k) 与步骤 2 类似，初始化一些常量，一共有 64 个。每个值（0-63）是前 64 个素数（2-311）的立方根分数部分的前 32 位。 0x428a2f98 0x71374491 0xb5c0fbcf 0xe9b5dba5 0x3956c25b 0x59f111f1 0x923f82a4 0xab1c5ed5 0xd807aa98 0x12835b01 0x243185be 0x550c7dc3 0x72be5d74 0x80deb1fe 0x9bdc06a7 0xc19bf174 0xe49b69c1 0xefbe4786 0x0fc19dc6 0x240ca1cc 0x2de92c6f 0x4a7484aa 0x5cb0a9dc 0x76f988da 0x983e5152 0xa831c66d 0xb00327c8 0xbf597fc7 0xc6e00bf3 0xd5a79147 0x06ca6351 0x14292967 0x27b70a85 0x2e1b2138 0x4d2c6dfc 0x53380d13 0x650a7354 0x766a0abb 0x81c2c92e 0x92722c85 0xa2bfe8a1 0xa81a664b 0xc24b8b70 0xc76c51a3 0xd192e819 0xd6990624 0xf40e3585 0x106aa070 0x19a4c116 0x1e376c08 0x2748774c 0x34b0bcb5 0x391c0cb3 0x4ed8aa4a 0x5b9cca4f 0x682e6ff3 0x748f82ee 0x78a5636f 0x84c87814 0x8cc70208 0x90befffa 0xa4506ceb 0xbef9a3f7 0xc67178f2 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:3","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第四步：块循环 对输入的每 512 位分为一块，执行以下步骤： 注： 在本文的例子中，因为 “hello world” 太短了，所以只有一个块。在循环的每一次迭代中，都将对哈希值 h0-h7 进行变更，最终作为结果输出。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:4","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第五步：重组信息数组（w） 将步骤 1 中的输入数据重新排列到新数组中，其中每个条目都是一个 32 位字： 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 再加上 48 个初始化为零的字，这样就有了一个数组 w [0…63] 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 … … 00000000000000000000000000000000 00000000000000000000000000000000 使用以下算法修改数组末尾的零索引： For i from w[16…63]: s0 = (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 = (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10) w[i] = w[i-16] + s0 + w[i-7] + s1 以 w[16] 举例说明： w[1] rightrotate 7: 01101111001000000111011101101111 -\u003e 11011110110111100100000011101110 w[1] rightrotate 18: 01101111001000000111011101101111 -\u003e 00011101110110111101101111001000 w[1] rightshift 3: 01101111001000000111011101101111 -\u003e 00001101111001000000111011101101 s0 = 11011110110111100100000011101110 XOR 00011101110110111101101111001000 XOR 00001101111001000000111011101101 = 11001110111000011001010111001011 w[14] rightrotate 17: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 w[14] rightrotate19: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 w[14] rightshift 10: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 s1 = 00000000000000000000000000000000 XOR 00000000000000000000000000000000 XOR 00000000000000000000000000000000 = 00000000000000000000000000000000 w[16] = w[0] + s0 + w[9] + s1 = 01101000011001010110110001101100 + 11001110111000011001010111001011 + 00000000000000000000000000000000 + 00000000000000000000000000000000 = 00110111010001110000001000110111 // addition is calculated modulo $ 2^{32} $ 总的结果就是： 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 00110111010001110000001000110111 10000110110100001100000000110001 11010011101111010001000100001011 01111000001111110100011110000010 00101010100100000111110011101101 01001011001011110111110011001001 00110001111000011001010001011101 10001001001101100100100101100100 01111111011110100000011011011010 11000001011110011010100100111010 10111011111010001111011001010101 00001100000110101110001111100110 10110000111111100000110101111101 01011111011011100101010110010011 00000000100010011001101101010010 00000111111100011100101010010100 00111011010111111110010111010110 01101000011001010110001011100110 11001000010011100000101010011110 000001101010111110","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:5","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第六步：压缩 初始化变量 a，b，c，d，e，f，g，h，并将它们分别设置为等于当前的哈希值：h0，h1，h2，h3，h4，h5，h6，h7 进行压缩循环。 压缩循环将改变 a…h 的值。压缩循环如下： for i from 0 to 63: S1 = (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) ch = (e and f) xor ((not e) and g) temp1 = h + S1 + ch + k[i] + w[i] S0 = (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) maj = (a and b) xor (a and c) xor (b and c) temp2 := S0 + maj h = g g = f e = d + temp1 d = c c = b b = a a = temp1 + temp2 下面演示第一次迭代，所有加法都是以 $ 2^{32} $ 为模的： a = 0x6a09e667 = 01101010000010011110011001100111 b = 0xbb67ae85 = 10111011011001111010111010000101 c = 0x3c6ef372 = 00111100011011101111001101110010 d = 0xa54ff53a = 10100101010011111111010100111010 e = 0x510e527f = 01010001000011100101001001111111 f = 0x9b05688c = 10011011000001010110100010001100 g = 0x1f83d9ab = 00011111100000111101100110101011 h = 0x5be0cd19 = 01011011111000001100110100011001 e rightrotate 6: 01010001000011100101001001111111 -\u003e 11111101010001000011100101001001 e rightrotate 11: 01010001000011100101001001111111 -\u003e 01001111111010100010000111001010 e rightrotate 25: 01010001000011100101001001111111 -\u003e 10000111001010010011111110101000 S1 = 11111101010001000011100101001001 XOR 01001111111010100010000111001010 XOR 10000111001010010011111110101000 = 00110101100001110010011100101011 e and f: 01010001000011100101001001111111 \u0026 10011011000001010110100010001100 = 00010001000001000100000000001100 not e: 01010001000011100101001001111111 -\u003e 10101110111100011010110110000000 (not e) and g: 10101110111100011010110110000000 \u0026 00011111100000111101100110101011 = 00001110100000011000100110000000 ch = (e and f) xor ((not e) and g) = 00010001000001000100000000001100 XOR 00001110100000011000100110000000 = 00011111100001011100100110001100 // k[i] 是圆常数 // w[i] 信息数组 temp1 = h + S1 + ch + k[i] + w[i] = 01011011111000001100110100011001 + 00110101100001110010011100101011 + 00011111100001011100100110001100 + 1000010100010100010111110011000 + 01101000011001010110110001101100 = 01011011110111010101100111010100 a rightrotate 2: 01101010000010011110011001100111 -\u003e 11011010100000100111100110011001 a rightrotate 13: 01101010000010011110011001100111 -\u003e 00110011001110110101000001001111 a rightrotate 22: 01101010000010011110011001100111 -\u003e 00100111100110011001110110101000 S0 = 11011010100000100111100110011001 XOR 00110011001110110101000001001111 XOR 00100111100110011001110110101000 = 11001110001000001011010001111110 a and b: 01101010000010011110011001100111 \u0026 10111011011001111010111010000101 = 00101010000000011010011000000101 a and c: 01101010000010011110011001100111 \u0026 00111100011011101111001101110010 = 00101000000010001110001001100010 b and c: 10111011011001111010111010000101 \u0026 00111100011011101111001101110010 = 00111000011001101010001000000000 maj = (a and b) xor (a and c) xor (b and c) = 00101010000000011010011000000101 XOR 00101000000010001110001001100010 XOR 00111000011001101010001000000000 = 00111010011011111110011001100111 temp2 = S0 + maj = 11001110001000001011010001111110 + 00111010011011111110011001100111 = 00001000100100001001101011100101 h = 00011111100000111101100110101011 g = 10011011000001010110100010001100 f = 01010001000011100101001001111111 e = 10100101010011111111010100111010 + 01011011110111010101100111010100 = 00000001001011010100111100001110 d = 00111100011011101111001101110010 c = 10111011011001111010111010000101 b = 01101010000010011110011001100111 a = 01011011110111010101100111010100 + 00001000100100001001101011100101 = 01100100011011011111010010111001 整个计算会继续循环进行了 63 次，期间不断修改了变量 a-h 的值。最终结果为： a = 4F434152 = 001001111010000110100000101010010 b = D7E58F83 = 011010111111001011000111110000011 c = 68BF5F65 = 001101000101111110101111101100101 d = 352DB6C0 = 000110101001011011011011011000000 e = 73769D64 = 001110011011101101001110101100100 f = DF4E1862 = 011011111010011100001100001100010 g = 71051E01 = 001110001000001010001111000000001 h = 870F00D0 = 010000111000011110000000011010000 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:6","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第七步：修改最终值 压缩循环完成后，仍然处于在块循环中，通过向哈希值中添加它们各自的变量 a-h 来修改哈希值。同样的，所有的加法都是模 $ 2^{32} $。 h0 = h0 + a = 10111001010011010010011110111001 h1 = h1 + b = 10010011010011010011111000001000 h2 = h2 + c = 10100101001011100101001011010111 h3 = h3 + d = 11011010011111011010101111111010 h4 = h4 + e = 11000100100001001110111111100011 h5 = h5 + f = 01111010010100111000000011101110 h6 = h6 + g = 10010000100010001111011110101100 h7 = h7 + h = 11100010111011111100110111101001 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:7","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第八步: 组成最终的哈希值 digest = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 = B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9 搞定！至此，本文非常详细地实现了 SHA-256 中的每一步🙂。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:8","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"附录 SHA-2 的第 t 个加密循环\" SHA-2 的第 t 个加密循环 下面这段伪代码总结了上面执行的所有步骤： 注 1：所有变量均为 32 位无符号整数，加法以 $ 2^{32} $ 为模 注 2：对于每一轮，在消息调度数组 w [i]，0≤i≤63 中有一个循环常数 k [i] 和一个条目。 注 3：压缩函数使用 8 个工作变量，a 到 h。 注 4：在此伪代码中表示常量时使用大端约定，并且当将消息块数据从字节解析到字时，例如，填充后的输入消息 “abc” 的第一个字是 0x61626380 Initialize hash values: (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19): h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 Initialize array of round constants: (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311): k[0..63] := 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 Pre-processing (Padding): begin with the original message of length L bits append a single '1' bit append K '0' bits, where K is the minimum number \u003e= 0 such that L + 1 + K + 64 is a multiple of 512 append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits Process the message in successive 512-bit chunks: break message into 512-bit chunks for each chunk create a 64-entry message schedule array w[0..63] of 32-bit words (The initial values in w[0..63] don't matter, so many implementations zero them here) copy chunk into first 16 words w[0..15] of the message schedule array Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array: for i from 16 to 63 s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10) w[i] := w[i-16] + s0 + w[i-7] + s1 Initialize working variables to current hash value: a := h0 b := h1 c := h2 d := h3 e := h4 f := h5 g := h6 h := h7 Compression function main loop: for i from 0 to 63 S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) ch := (e and f) xor ((not e) and g) temp1 := h + S1 + ch + k[i] + w[i] S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) maj := (a and b) xor (a and c) xor (b and c) temp2 := S0 + maj h := g g := f f := e e := d + temp1 d := c c := b b := a a := temp1 + temp2 Add the compressed chunk to the current hash value: h0 := h0 + a h1 := h1 + b h2 := h2 + c h3 := h3 + d h4 := h4 + e h5 := h5 + f h6 := h6 + g h7 := h7 + h Produce the final hash value (big-endian): digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:4:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"参考 [1] How SHA-2 Works Step-By-Step (SHA-256) [2] SHA-2 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:5:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":" 哈希函数入门介绍。 ","date":"2020-07-25","objectID":"/hash_functions/:0:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"哈希函数（Hash Function）用来做什么？ 哈希函数，又称散列函数，广泛应用于互联网的各处，包括但不限于安全地存储密码、查找重复记录、快速存储和检索数据等。例如，Qvault 应用使用哈希将主密码扩展为私人加密密钥。你还可以 点击这里 查看哈希函数用于何处。 ","date":"2020-07-25","objectID":"/hash_functions/:1:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"重要特性 哈希函数的拥有如下三个重要特性，这些特性可以说是最重要的特性： 哈希函数对数据进行确定性加扰。 无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。 无法从加扰数据中检索原始数据（单向函数）。 ","date":"2020-07-25","objectID":"/hash_functions/:2:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"确定性加扰 想象一下，如果随机扭动一个魔方，到最后会得到一些和开始时不一样的东西。但是，如果重新开始，并做完全相同的一系列动作，那么将能够反复得到完全相同的结果。尽管结果可能看起来是随机的，但它其实是严格按照一定的规则进行变幻地，这就是确定性加扰的含义。 确定性对于安全存储密码很重要。例如，假设我的密码是 iLoveBitcoin，我可以使用哈希函数对其进行加扰： iLoveBitcoin → “2f5sfsdfs5s1fsfsdf98ss4f84sfs6d5fs2d1fdf15” 现在，任何人看到加扰后的版本，他们都不会知道我的原始密码！这一点很重要，因为这意味着作为一个网站开发人员，我只需要存储我用户密码的哈希(加扰数据)就可以验证它们。当用户注册时，我将用户密码进行哈希运算然后将其存储在我的数据库中。当用户登录时，我只是对他们输入的内容再次进行哈希运算，并比较两个哈希值。因为给定的输入总是生成相同的哈希值，所以能够很方便地进行验证。 ","date":"2020-07-25","objectID":"/hash_functions/:2:1","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"输出定长 如果对单个单词进行哈希处理，则输出将具有一定的大小（对于 SHA-256，则为特定的哈希函数，大小为 256 位）。即便我对一本书进行哈希处理，输出同样将是相同的大小。 这是另一个重要的功能，因为它可以节省我们的计算时间。 一个典型的例子是使用哈希作为数据映射中的键。 数据映射是计算机科学中用来存储数据的一种简单结构。 数据映射\" 数据映射 当程序在映射中存储数据时，会为映射指定一个键和值。当程序想要访问该值时，它只要提供适当的键就能接收相应的值。数据映射很好，因为它们可以立即找到数据。计算机通过键可以立即找到对应的值，而不是花费数小时在数百万条记录中搜索。 因为键类似于地址，所以它们不能太大。如果我想将图书存储在数据映射中，我可以对图书的内容进行哈希，并使用该哈希作为键。 ","date":"2020-07-25","objectID":"/hash_functions/:2:2","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"哈希处理如何进行？ 接下来，以 LANEHASH 算法为例，简要讲解哈希处理是如何完成的。 首先，选取下面的数据进行哈希处理 iLoveBitcoin 将字母转换成二进制 iLoveBitcoin→ 100010100000101111 注: 在这一步中，我们通过各种预定的步骤来转换我们的原始数据。转换方式可以采用各种方式，但重要的是，每当我们使用 LANEHASH 时，都需要使用相同的步骤，以便我们的算法是确定性的。 将比特前四位从左移到右边 100010100000101111 → 101000001011111000 奇偶分离比特 101000001011111000 → 110011110 \u0026 000001100 分别转化为十进制数 110011110 → 414 000001100→ 12 两数相乘 414 *12 = 4968 乘积平方 4968 ^ 2 = 24681024 再次转换为二进制 24681024 →1011110001001101001000000 剥离右边的9个比特以得到16位比特 1011110001001101001000000 → 1011110001001101 转换回字母/数字 1011110001001101 → “8sj209dsns02k2” 正如你所看到的，如果在开始时使用相同的单词，则在结束时将始终得到相同的输出。然而，即使你改了一个字母，结果也会发生很大的变化。 ","date":"2020-07-25","objectID":"/hash_functions/:3:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"注意 本文中英文和二进制之间的相互转换并没有遵循任何模式，请读者不要纠结于这一点。当然，实际中，有很多方法用于将我们熟知的字符（例如中文、英语等）转换为二进制（十六进制），如果感兴趣，可以点击下面的参考中的内容 ","date":"2020-07-25","objectID":"/hash_functions/:4:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"总结 哈希函数实际上就是按照特定的规则将数据进行一系列转换，最后得到一串键值用来代替/指代原始数据，但是需要注意的是，哈希函数需要满足确定性、定长性、不可逆性。 ","date":"2020-07-25","objectID":"/hash_functions/:5:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"参考 [1] (Very) Basic Intro to Hash Functions (SHA-256, MD5, etc) [2] Hash Function [3] ASCII [4] Unicode ","date":"2020-07-25","objectID":"/hash_functions/:6:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Software"],"content":" SCP 就是 SSH 协议的文件传输功能吗？ ","date":"2020-07-18","objectID":"/scp/:0:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"什么是 SCP SCP（Secure Copy Protocol，安全复制协议）允许我们在两台计算机之间复制文件（和目录）。 使用起来特别方便： $ scp local_file remote_host:/home 这将把本地文件 localfile 复制到远程主机的 /home 文件之下。 SCP 使用起来特别便利，因为他能工作在几乎所有的 Unix-like 的系统中，并且 Windows 下拥有许多客户端。但是仅仅复制文件并不是关键。SCP 真正的价值是对 计算机的身份进行验证 以及对 传输文件进行加密（也就是 S 代表的含义）。 使用前需要首先配置到远程主机的 SSH 连接权限。SCP 的验证提示和 SSH 看起很像，因为 SCP 跑在 SSH 的上层，仅仅把它作为文件数据的管道。事实上，SSH 负责处理所有安全相关的任务，SCP 只是将一些文件扔到 SSH 连接上。 维基百科上的条目讲述了 SCP 的历史，简而言之：在旧的 BSD 系统上曾经有一个叫 RCP 的工具，可以在电脑之间移动文件。在当时受信任的网络时代，每个人都是别人的朋友。后来人们意识到，也许并不是每个人在他们的网络上都是这么好的朋友。于是有人把 RCP 的实现复制到 OpenSSH 的前身上，然后简单地在 SSH 会话上运行它，以保护文件不被非好友发现。问题解决了！从此以后，它就留在了 OpenSSH 中。 ","date":"2020-07-18","objectID":"/scp/:1:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"SCP 工作原理 SCP 并不是一个标准协议，并没有一个 RFC 或者任何官方描述如何实现它。OpenSSH 实现是一个事实上的规范。此实现有两个部分：连接建立和之后的传输协议。 ","date":"2020-07-18","objectID":"/scp/:2:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"建立连接 实际上，这并不是真正的连接。因为它只是利用 SSH 执行命令后的 STDIN/STDOUT ，有点类似 Unix 管道。OpenSSH 中包含两个程序来完成:sshd 和 scp。sshd 是始终运行的服务器守护进程，接受新的 SSH 连接。SCP 是伪装成 SSH 的客户端程序，发送和接受文件。 当 SCP 运行时，他将开启一个新的 SSH 连接。在该连接上，它会在服务端执行另一个带有特殊标志的 SCP 程序。你可以认为是 ssh exec scp [flags]。主要的标志包含 -t（“to”）和 -f（“from”）用于代表接受和发送，而 -d 表示文件夹，-r 表示递归。 建立连接\" 建立连接 值得注意的是，SCP 协议是单向的，一端发送文件，另一端接收文件。在远程端 SCP 开始运行后，实际的 SCP 协议命令开始通过 STDIN 和 STDOUT 运行。 ","date":"2020-07-18","objectID":"/scp/:2:1","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"传输协议 现在，安全的 I/O 通道建立起来，并且已经有效地切换到 RCP 协议上。该协议是 顺序（一次一个操作）和 同步（每个命令执行完后才执行下一个命令）执行的。 命令格式大致为（不带括号或空格）：[command type][arguments]\\n [optional data] [command type] 通常是一个 ASCII 字符： ‘C’- 写入文件 ‘D’- 输入目录 ‘E’- 退出最后一个目录 ‘T’- 设置下一个文件或目录的创建 / 更新时间戳 [arguments] 是特定于命令的，如文件 / 目录名称、文件大小或时间戳。“E” 命令没有参数。 [optional data] 在上一个命令为 “C”（创建文件）时发送。数据的大小指定为 “C” 的参数。 此外，还有控制字节，这些字节是在没有新行的情况下自己发送的： ‘0x00’-“OK”，确认完成最后一个命令（如编写本地文件）。接收方也会在启动时发送此消息，让发送方知道它已准备好接收命令。 ‘0x00’-“警告”，后面是要向用户显示的行（由新行终止）。 ‘0x00’-“错误” 后跟随可选消息（和警告相同），但连接随后终止。 下面这个带有注释的图片实例，详细讲述了这个过程： 传输过程\" 传输过程 ","date":"2020-07-18","objectID":"/scp/:2:2","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"使用 SCP $ scp 选项 参数 其中选项如下： -1：使用ssh协议版本1； -2：使用ssh协议版本2； -4：使用ipv4； -6：使用ipv6； -B：以批处理模式运行； -C：使用压缩； -F：指定ssh配置文件； -l：指定宽带限制； -o：指定使用的ssh选项； -P：指定远程主机的端口号； -p：保留文件的最后修改时间，最后访问时间和权限模式； -q：不显示复制进度； -r：以递归方式复制。 参数分别为： 源文件：指定要复制的源文件。 目标文件：格式为user@host：filename（文件名为目标文件的名称）。 ","date":"2020-07-18","objectID":"/scp/:3:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"SCP 的问题 看起来，SCP 听起来似乎没什么问题。它是一个简单易用的工具，然而存在一些现实问题。 ","date":"2020-07-18","objectID":"/scp/:4:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"性能 传输协议的顺序性：每个命令的强制确认都会增加大量开销。例如，如果沿途丢弃单个确认数据包，则整个连接将暂停，直到重新传输开始。最重要的是，发送所有数据而不压缩或询问接收方是否已经拥有该文件并不理想。 有经验的系统管理员可以告诉您，使用 tar 归档文件并发送比使用 scp 递归命令传输要快得多。事实上，这样的话你甚至无需使用 SCP： # Copy a local folder with 10000 files $ find /tmp/big_folder/-type f | wc -l 10000 # Using scp $ time scp -r -q /tmp/big_folder/server:/tmp/big_folder ________________________________________________________ Executed in 882.99 millis fish external usr time 114.09 millis 0.00 micros 114.09 millis sys time 278.46 millis 949.00 micros 277.51 millis # Using tar over ssh $ time sh -c \"tar cf - /tmp/big_folder | ssh server 'tar xC /tmp/-f -'\" tar: Removing leading '/' from member names ________________________________________________________ Executed in 215.68 millis fish external usr time 93.22 millis 0.00 micros 93.22 millis sys time 66.51 millis 897.00 micros 65.62 millis 在这种比较糟糕的情况下，tar\u0026ssh 的 215.68ms 对比 SCP 的 882.99ms，足足有四倍的速度提升。 ","date":"2020-07-18","objectID":"/scp/:4:1","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"安全 我们已经知道，SCP 靠 SSH 负担安全工作，因此它完全安全… 吗？ OpenSSH 的发行说明提到： scp 协议已经过时、不灵活且不容易修复。我们建议使用更现代的协议，如 sftp 和 rsync 来传输文件。 如果远程端的 shell 打印出任何非交互式会话，则本地 SCP 进程将愉快地将该输出解释为 SCP 命令。好的话，这仅仅是打破 SCP 协议中模糊的错误。但在最坏的情况下，远程 shell 启动脚本是恶意的，并向你发送恶意文件，而不是所需的文件。 此外，早在 2018 年，Harry Sintonen 就发现了流行的 SCP 实现（包括 OpenSSH）中的一堆漏洞。包括从修改目录的权限到覆盖任意文件（由于 ～/.ssh/authorized_keys 或 ～/.bashrc）、有效地执行代码，以及注入终端转义序列来隐藏任何追踪。这些漏洞对于任何构建网络 CLI 应用程序的人来说都是一个很好的教训。 ","date":"2020-07-18","objectID":"/scp/:4:2","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"SCP 的替代方案 SFTP 被广泛认为是 SCP 的继承者。为了传输层安全性，它仍然在 SSH 上运行，并且不需要单独设置访问。它可以为您提供一个自定义交互式提示来探索远程文件系统，或者您可以使用预先编写的一系列命令编写脚本。 缺点是，您需要学习 SFTP 提示命令，协议本身尚未完全标准化（有很多 RFC 草稿，但作者最终放弃了）。 Rsync 是另一个很好的选择。使用与 SCP 命令完全相同 - 它也利用 SSH。Rsync 着重优化性能 - 它执行大量的复杂本地计算从而通过网络发送尽可能少的数据。从技术上讲，它致力于数据同步而不是纯传输文件 - 如果远程和本地内容相似，则只会发送增量。 同样，它也有其自身的缺点：发送方使用大量的 CPU 资源来计算要发送什么，并且接收方使用大量磁盘 IO 将数据按正确的顺序放在一起。与 OpenSSH 不同，Rsync 在大多数系统上并不预安装。 ","date":"2020-07-18","objectID":"/scp/:5:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"结论 SCP 是一个简单的工具，它在复制文件方面做得很好，但较新的软件在很多方面都优于它。对于您信任的计算机之间的个人简单使用，SCP 仍然适合。 但是，如果您遇到性能问题或需要满足更高的安全标准，则上面列出的任何备选方案都比 SCP 更可取。选择最适合您需求的，然后试着开始使用。 ","date":"2020-07-18","objectID":"/scp/:6:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"另见 rsync SFTP ","date":"2020-07-18","objectID":"/scp/:7:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Software"],"content":"参考 [1] SCP - Familiar, Simple, Insecure, and Slow [2] Wikipedia Secure copy [3] Call for testing: OpenSSH 8.0 [4] Scp ","date":"2020-07-18","objectID":"/scp/:8:0","tags":["Software","Linux","Translation"],"title":"文件传输 1：SCP","uri":"/scp/"},{"categories":["Network"],"content":" NAT 引发的问题以及解决方法 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:0:0","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"问题 对称型 NAT（Symmetric NAT）常常在游玩联机游戏（尤其是 P2P 联机方式）时候给我们造成困扰。如果 Xbox、PS、switch 或者 PC 上的应用程序报告 NAT 是严格、类型 3、类型 D、对称这样的字样，那么就意味着你将会出现联机问题。 理解这个问题之前，首先要认识到，这些设备及软件是无法感知它们是否被 NAT 化的。但是，在 Internet 上与之通信的任何设备都应该使用公共 IP 地址，例如 1.1.1.1。在进行任何连接尝试时，都必须知道目标公共 IP 地址和端口。在上面的所有示例中，你应该发现了网站 IP 地址和端口均已知，这些地址是固定的，并且未曾发生更改。但是，某些程序会使用一系列动态端口。在运行游戏时，你的主机选择一个随机端口来进行游戏。由于其他主机不知道你的 IP 地址或端口，因此必须在连接之前以某种方式了解它。你的主机会将游戏的 IP 地址和端口发送到 Xbox Live 或 PS 网络，这样其他主机便可以在其中检索它，然后直接与你连接。但问题是，它发送的是内部 IP 地址 192.168.0.1 和端口 54324，而不是 Nat 后的公共 IP。它应该发送的是（例如）1.1.1.1 的公共 IP 地址和端口 54324。而且当处于对称型 NAT 时，该端口也会发生更改，因此它必须发送经过 NAT 处理的端口，例如 54254，而不是主机本身的内部端口（54324）。 这不仅仅是游戏面对的问题，这一直是 NAT 的问题。 那么，主机如何得知它位于 NAT 之后，并告诉其他主机将数据发送到 NAT 后的 IP 地址和端口而不是其自身的内部 IP 地址和端口？ ","date":"2020-07-15","objectID":"/nat_issues_solutions/:1:0","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"解决办法 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:0","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"STUN（Session Traversal Utilities） STUN 是 NAT 的 Session Traversal Utilities 的缩写，你可能已经猜到了它的名字，它是一个实用工具的集合，以帮助 NAT 设备穿越内网。简单地说，STUN 允许你的主机 / PC 或内部设备了解它的公共 NAT 的 IP 地址和端口是什么。一旦实现了这一点，你的设备现在可以发送正确的 IP 和端口，其他设备也可以连接到你。但是，它在对称型 NAT 下无法工作，在对称型 NAT 中，你的主机可以得知它的公共 IP 地址，但无法得知它的公共端口（因为，端口是 NAT 随机生成的）。 STUN 的工作原理很简单。你连接到一个运行 STUN 协议的服务器 (Xbox Live Servers)，它从接收的数据包中读取源 IP 地址和源端口，这些当然会是 NAT 后的（这是我们需要的）。然后 STUN 将这些信息返回给客户端，它的工作就完成了。你的主机现在知道了它的 NAT 后的 IP 和端口，并且会把这些信息发送到其他设备上。 STUN 算法\" STUN 算法 如果你还记得，除了对称型 NAT 之外，所有其他类型的 NAT 都不会改变源端口。这意味着当我的主机创建一个 NAT 映射时，它将对所有这种类型的连接使用它，当向互联网上的个设备发送和接收数据包时，它使用同一个映射，因此它使用相同的公共 IP 地址和端口； 但在对称型 NAT 的情况下，每一个连接都有一个不同的映射，有一个不同的（随机生成的）端口，意味着连接到 STUN 服务器也将有它自己独特的映射，表现的就像一个新的设备接入一样。这意味着每个映射都有不同的端口，在这种情况下，STUN 检测到的端口现在已经没有用了，因为这个映射是 STUN 服务器独有的。无论映射到其他设备的端口是什么，都是未知的，STUN 也没有办法检测到它。由于你的主机无法得知每个映射到每个主机的公共 NAT 化端口，因此无法将这些信息传递给你，也就意味着没有设备可以连接到你的游戏，这就是对称型 NAT 导致如此多游戏联机问题的原因。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:1","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"DMZ（Demilitarized zone) 路由器上的外围网络（也称 DMZ）功能用于消除对 Internet 的限制。它主要是将你的设备移到你的网络防火墙之外的区域，将部分用于提供对外服务的服务器主机划分到一个特定的子网 —— DMZ 内，在 DMZ 的主机能与同处 DMZ 内的主机和外部网络的主机通信，而同内部网络主机的通信会被受到限制。这使 DMZ 的主机能被内部网络和外部网络所访问，而内部网络又能避免外部网络所得知。 注意 当你设置外围网络时在主机上使用静态 IP 地址十分重要。要设置静态 IP 地址，请使用路由器的 DHCP 预留功能（如果可用）。如果该功能不可用，你将需要在你的设备 上配置手动 IP 设置。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:2","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"UPnP（Universal Plug and Play） UPnP（Universal Plug and Play）是帮助路由器有效通信的一个标准。如果路由器或网关支持 UPnP，则它在默认情况下可能已启用。开启 UPnP 功能后，局域网中的计算机可以请求路由器自动进行端口转换。这样，互联网上的计算机就能在需要时访问局域网计算机上的资源（如 MSN Messenger 或迅雷、BT、PPLive 等支持 UPnP 协议的应用程序）。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:3","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"参考 [1] Symmetric NAT and It’s Problems | Think Like A Computer [2] Wikipedia STUN [3] Wikipedia DMZ [4] 解决 NAT 错误和多人游戏问题 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:3:0","tags":["NAT","Translation"],"title":"NAT 2：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":" 一文概览 NAT ","date":"2020-07-14","objectID":"/nat/:0:0","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"NAT NAT（Network Address Translation，网络地址转换）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。 NAT 从大类上都可以分为两类：静态 NAT 和 动态 NAT。 静态 NAT 是管理员手动创建和维护映射，通常与 NAT 的入站类型相关联。 动态 NAT 是路由器根据需要自动创建和维护映射，通常与 NAT 的出站类型相关联。 每个 TCP/IP 数据包都包含一个 源 IP 地址、源端口、目的 IP 地址 和 目的端口。所有类型的 NAT 都会使用这些值创建 NAT 映射。 例如，一个 IP 为 192.168.0.1 的内部客户机使用端口 56876，经过 NAT 转变后 IP 变为 3.3.3.3（翻译后的源 IP）和端口 56876（源端口）连接到 IP 2.2.2.2（目的 IP 地址）的 80 端口（目的端口）。NAT 使用原始内部 IP 和端口、翻译后 IP 和端口这 4 个值创建一个映射。当数据包从网站返回到路由器时，使用与该映射相关值，NAT 将数据包转发到内部客户端。 ","date":"2020-07-14","objectID":"/nat/:1:0","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"NAT 的四种类型 ","date":"2020-07-14","objectID":"/nat/:2:0","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"全锥型 NAT（Full Cone NAT) 全锥型 NAT\" 全锥型 NAT 全锥型 NAT 是静态 NAT，也是唯一一种永久开放端口的 NAT，允许从 任何外部主机 进行入站连接。全锥型 NAT 将一个公共 IP 地址和端口映射到 LAN IP 和端口。任何外部主机都可以通过映射的 NAT IP 和端口向 LAN IP 发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的 NAT 也被称为端口转发。这是受限制最少的 NAT 类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。 例如，我的电脑有一个网站在 80 端口上运行，我创建了一个一对一的规则，将路由器的WAN IP 1.1.1.1 映射到 192.168.0.1，端口 80 映射到 80 端口。凡是在 80 端口向 1.1.1.1 发送数据的外部主机都会被 NAT 转发到 192.168.0.1 80 端口。 注意： 端口号不必相同；我可以在 56456 端口上运行我的网站，但创建 NAT 映射，将 80 端口转发到 56456 端口。这样，外部客户端就会认为我的网站在 80 端口上，而在任何其他端口上的连接尝试都会被丢弃。 ","date":"2020-07-14","objectID":"/nat/:2:1","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"受限锥形 NAT（Restricted Cone NAT） 受限锥形 NAT\" 受限锥形 NAT 受限锥体 NAT 是动态 NAT，它的工作方式与全锥型 NAT 相同，但会对进站的 IP 地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的 IP 地址。亦即需要内部主机首先发起连接的外部主机，才能被接受入站。 例如，我的电脑与一个网站 (56.45.34.78) 进行外向连接，源 IP 为 192.168.0.1，源端口为 56723。NAT 使用源端口 56723 创建一个（动态）映射到我的电脑。使用目的端口 56723（这是出站 NAT 的源端口）到达的源 IP 为 56.45.34.78（网站 IP）的数据包将被接受，接着网站返回数据至我的 PC。任何其他 IP 即使使用正确的 56723 端口进行连接尝试将被丢弃。同样，即使正确的 IP 使用 56723 以外的目的端口进行的连接尝试也将被丢弃。 ","date":"2020-07-14","objectID":"/nat/:2:2","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"端口受限锥型 NAT（Port Restricted Cone NAT) 端口受限锥型 NAT\" 端口受限锥型 NAT 端口受限锥型 NAT 是动态 NAT，它的作用与受限锥形 NAT 完全相同，但同时对端口进行限制。受限锥形 NAT 接受来自外部主机任何源端口的连接，而端口受限锥型 NAT 则进一步要求外部主机的源端口是固定的。 例如，我的电脑在 80 端口（目标端口）上向网站 IP 217.87.69.8 建立了一个外向连接。NAT 将我的源 IP 192.168.0.1 映射到 WAN IP 1.1.1.1 和源端口 56723。当网站发回数据包时，它的源 IP 必须是 217.87.69.8，目的端口是 56723（就像一个受限锥型 NAT），但除此之外，还要求源端口必须是 80。如果这三者中的任何一个不一样，端口受限锥型 NAT 就会放弃连接。 ","date":"2020-07-14","objectID":"/nat/:2:3","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"对称型 NAT（Symmetric NAT） 对称型 NAT\" 对称型 NAT 对称型 NAT 是动态 NAT，它限制的方式与端口受限锥型 NAT 完全相同，但处理 NAT 转换的方式不同。目前讨论的所有类型的 NAT 在 NAT 连接时都 不会改变源端口。 例如，当客户端使用 IP 192.168.0.1 和源端口 56723 访问互联网时，NAT 将源 IP 改变为 56.35.67.35，但保持端口号不变，这被称为端口保留。 而对称型 NAT 会将端口改为 随机生成的新端口，甚至是同一客户端到不同目的地的连接也会发生。亦即为每个连接创建唯一的映射 例如，在端口受限锥型 NAT 的例子上进行扩展，我的 PC 向网站 IP 217.87.69.8 和 56.76.87.98 建立两个出站连接。我的电脑使用源 IP 192.168.0.1 和源端口 56723 进行两个连接。到目前为止，在所有类型的 NAT 上，这两个连接都会被 NAT 化，只改变源 IP 地址而保持源端口不变。然而这次，对称型 NAT 没有将源端口保留为 56723，而是将其中一个连接的源端口改为 45765，另一个连接的源端口改为 53132（随机）。这就为每个连接创建了唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以 217.87.69.8 必须将数据包发送到目的端口 45765，56.76.87.98 必须将数据包发送到端口 53132，此外还需要遵循端口受限锥型 NAT 的要求。 ","date":"2020-07-14","objectID":"/nat/:2:4","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"对 NAT 的正面评价 NAT 在一定程度上缓解了 IPv4 地址短缺的问题，让更多的设备（间接）接入了互联网。 NAT 全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT 依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为 UDP 的跨局域网的传输提供了方便。 ","date":"2020-07-14","objectID":"/nat/:3:0","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"对 NAT 的批评 在一个具有 NAT 功能的路由器下的主机并没有获得真正的 IP 地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的 TCP 连接和无状态协议（比如 UDP）无法实现。除非 NAT 路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。 端对端连接是被 IAB 委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为 NAT 是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地 IP 地址，所以他们必须通过 NAT 来访问 ISP 网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。 NAT 使得 IP 协议从面向无连接变成立面向连接。NAT 必须维护专用 IP 地址与公用 IP 地址以及端口号的映射关系。在 TCP/IP 协议体系中，如果一个路由器出现故障，不会影响到 TCP 协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在 NAT 时，最初设计的 TCP/IP 协议过程将发生变化，Internet 可能变得非常脆弱。 NAT 违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第 N 层是不能修改第 N+1 层的报头内容的。NAT 破坏了这种各层独立的原则。 NAT 同时存在对高层协议和安全性的影响问题。RFC 对 NAT 存在的问题进行了讨论。NAT 的反对者认为这种临时性的缓解 IP 地址短缺的方案推迟了 IPv6 迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。 ","date":"2020-07-14","objectID":"/nat/:4:0","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"参考 [1] Wikipedia NAT [2] What you need to know about symmetric NAT | Think Like A Computer [3] NAT Types Defined ","date":"2020-07-14","objectID":"/nat/:5:0","tags":["NAT","Translation"],"title":"NAT 1：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":" DNS 如何工作？更新网站的 DNS 记录的时候发生了什么？更新后必须等待 48 小时才能生效吗？为什么有人看到的是新 IP，有人看到的是旧 IP？ ","date":"2020-07-02","objectID":"/dns_update/:0:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"DNS 分类 我们知道，DNS 服务器有两种：权威服务器（authoritative）和递归服务器（recursive） 权威 DNS 服务器（也称为名称服务器，NS，nameserver） 具有其所负责的每个域的 IP 地址数据库。 例如，github.com 的权威 DNS 服务器是 NS-421.awsdNS-52.com 您可以像这样要求它提供 github.com 的 IP: $ dig @NS-421.awsdNS-52.com github.com 递归 DNS 服务器，本身并不知道谁拥有什么 IP 地址。它们通过询问正确的权威 DNS 服务器，找出域名的 IP 地址，然后缓存这个 IP 地址，以备再次询问。8.8.8.8 是一个递归 DNS 服务器。 当人们访问你的网站时，他们可能会向递归 DNS 服务器进行 DNS 查询。那么，递归 DNS 服务器是如何工作的呢？ ","date":"2020-07-02","objectID":"/dns_update/:1:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"递归 DNS 服务器如何工作 以 8.8.8.8 为例，如果我们向其请求 github.com 的 IP 地址（A 记录），如果它存在缓存，那么就直接返回缓存结果。然而，缓存是有期限的，如果所有缓存都过期了呢？那么情况是这样的： 递归服务器内部硬编码（hardcoded）有根 DNS 服务器 . 的 IP 地址（参见 [2][3]），选择一个根 DNS 服务器，例如 198.41.0.4 询问根 DNS 服务器有关 com. 的 NS 此步可以使用如下方法模拟： $ dig @198.41.0.4 github.com ... com. 172800 IN NS a.gtld-servers.net. ... a.gtld-servers.net. 172800 IN A 192.5.6.30 ... 可以看到，这里我们得到一个 com. 的权威 NSa.gtld-servers.net. 及其 IP 地址 192.5.6.30 注：实际上，99.99% 的情况下，此步我们就将得到 github.com 的 A 记录，但为了展示 DNS 解析进程，我们假设这里没有得到。 询问该权威 NS 有关 github.com 的 NS $ dig @192.5.6.30 github.com ... github.com. 172800 IN NS NS-421.awsdNS-52.com. NS-421.awsdNS-52.com. 172800 IN A 205.251.193.165 ... 这里，我们得到的 github.com.NSNS-421.awsdNS-52.com. 及其 IP 地址 205.251.193.165 询问该 NS 有关 github.com 的 A 记录 $ dig @205.251.193.165 github.com github.com. 60 IN A 140.82.112.4 至此，在假设没有缓存的情况下，我们通过完整的流程（实际上绝大多数情况不需要完整进行）获得了 github.com 的 IP 地址。 此外，使用 $ dig @8.8.8.8 +trace github.com 可以一次性显示上述所有步骤。 ","date":"2020-07-02","objectID":"/dns_update/:1:1","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"更新 DNS 记录 更新 DNS 记录时，有两种情况： 保持相同的 NS 变更 NS ","date":"2020-07-02","objectID":"/dns_update/:2:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"首先谈谈生存时间（TTLs，time to live） 上面已经说到，DNS 服务器一般存有缓存，而控制缓存是否过期的参数就是 TTL。 我们假设得到一个查询结果： $ dig @205.251.193.165 github.com github.com. 60 IN A 140.82.112.4 这里的 60（秒）即表示 TTL，这是一个很短的 TTL。理论上，如果每个用户都遵循 DNS 标准，那么 github.com 在更改了 IP 地址后，每个用户都应该在 60 秒内得到这个新的地址。但实际上呢？ ","date":"2020-07-02","objectID":"/dns_update/:2:1","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"更新同一 NS 上的 DNS 记录 假设我们已经在域名商处更新了新的 DNS 记录 test.jvNS.ca–\u003e1.2.3.4，试着查询： $ dig @8.8.8.8 test.jvNS.ca test.jvNS.ca. 299 IN A 1.2.3.4 如果此前没有设置过 DNS 记录，因为没有缓存，所以立刻生效了。这里可以看到 TTL 是 299。那么，修改 IP 为 5.6.7.8 呢。 $ dig @8.8.8.8 test.jvNS.ca test.jvNS.ca. 144 IN A 1.2.3.4 可以看到，IP 并没有发生改变且 TTL 表示缓存还将存在 144 秒。而且，多次查询，你可能会发现，有时候可以得到新的 IP，但有的时候又是旧的 IP。 这里是因为像 8.8.8.8 这样的 DNS 服务器采用了负载均衡，每次查询可能被分配到不同的后端服务器，而他们的缓存不尽相同。 等待 5 分钟后，所有的缓存都更新了，再次查询，将会始终返回新 IP。 ","date":"2020-07-02","objectID":"/dns_update/:2:2","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"TTL 并非总是可靠 与大多数互联网协议一样，并不是所有的终端都服从 DNS 规范（包括 8.8.8.8 这样的大型 DNS 也不尊重 TTL）。一些 ISP 的 DNS 服务器会将缓存记录的时间比 TTL 规定的时间长，比如可能是 2 天而不是 5 分钟。而且人们总是可以在他们的 /etc/hosts 中硬编码旧的 IP 地址。 此外，应用程序（例如浏览器）都内置了自己的 DNS 缓存，或者本地网关也存在缓存。 这也是为什么，即便正确地设置了对应的 TTL（大部分 DNS 将会在短时间内更新缓存），有些 DNS 服务器仍然需要更长时间生效，这也导致我们的查询也并不总是会得到新的 IP 地址。 ","date":"2020-07-02","objectID":"/dns_update/:2:3","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"连同 NS 一起更新 假设此前的 NS 为 dNS1.p01.NSone.net，现在我们把他修改为谷歌的 NSNS-cloud-b1.googledomaiNS.com。 通常，当你修改完成后，你的域名商会提示你：“修改将在 48 小时内生效”。 然后设置一个新的 A 记录指向 1.2.3.4 dig 看看： $ dig @8.8.8.8 examplecat.com examplecat.com. 17 IN A 104.248.50.87 8.8.8.8 没有变化，询问别的 DNS： $ dig @1.1.1.1 examplecat.com examplecat.com. 299 IN A 1.2.3.4 1.1.1.1 更新了。 造成这样不同结果的原因，可能是此前并没有人询问过 1.1.1.1，所以他没有缓存，能立刻得到新的 IP。 而如果我们向新的 NS 查询，肯定会得到新的 IP 记录： $ dig @NS-cloud-b1.googledomaiNS.com examplecat.com examplecat.com. 300 IN A 1.2.3.4 ","date":"2020-07-02","objectID":"/dns_update/:2:4","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"NS 的 TTL 要长很多 域名商提示：“修改将在 48 小时内生效” 的原因是 NS 记录（告诉递归 NS 应该向哪个 NS 查询）的 TTL 要长的多。 回到上一节中，我们的查询结果显示： $ dig @192.5.6.30 github.com ... github.com. 172800 IN NS NS-421.awsdNS-52.com. NS-421.awsdNS-52.com. 172800 IN A 205.251.193.165 ... 172800 秒是 48 小时！这就是为什么更改 NS 后需要更长的时间来生效。 ","date":"2020-07-02","objectID":"/dns_update/:2:5","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"NS 如何得到更新？ 更新 NS 后，我们向根服务器查询的话就会到得到这样的结果： $ dig NS @j.gtld-servers.net examplecat.com examplecat.com. 172800 IN NS NS-cloud-b1.googledomaiNS.com 你可能会疑惑，新的 NS 记录是如何在根服务器处更新的呢？是因为当你在域名商那里更改你域名的 NS 后，他们会负责将这个给更改告知根服务器。 通常这个更新将在几分钟内就生效，但是对于其他一些顶级域名（TLD）（非.com）可能速度稍微慢一些。 ","date":"2020-07-02","objectID":"/dns_update/:2:6","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"总结 本文展示了 DNS 的解析过程以及我们更新 DNS 记录时发送了什么，希望有助于你理解这一过程。 ","date":"2020-07-02","objectID":"/dns_update/:3:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"参考 [1] What happens when you update your DNS? [2] unbound’s source code [3] iana root files ","date":"2020-07-02","objectID":"/dns_update/:4:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":" 简要介绍 Nagle 算法 ","date":"2020-06-28","objectID":"/nagle/:0:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Network"],"content":"Nagle 算法 Nagle 算法通过减少网络发包频率从而提高 TCP/IP 网络的效率。 主要解决由于 TCP 包头大小，导致频繁发送小数据包有效数据内容太少，开销过大段的问题。 Nagle 算法是将大量等待发送的小数据包合并起来，然后一次性全部发送出去。具体地说，只要有一个发送方没有收到任何确认的数据包，发送方就应该一直缓冲它的输出，直到它有一个完整的数据包的输出，这样就允许一次发送所有的输出。 其思路可以由下面的步骤所描述： if there is new data to send then if the window size ≥ MSS and available data is ≥ MSS then send complete MSS segment now else if there is unconfirmed data still in the pipe then enqueue data in the buffer until an acknowledge is received else send data immediately end if end if end if Nagle 算法可能导致期望实时响应和低延迟的应用程序体验不佳。 诸如网络多人视频游戏或鼠标在远程控制的操作系统中移动等应用程序，期望立即发送操作，而算法故意延迟传输，以牺牲延迟为代价提高带宽效率。因此，具有低带宽时间敏感传输的应用程序通常用于绕过 Nagle 延迟的 ACK 延迟。 ","date":"2020-06-28","objectID":"/nagle/:1:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Network"],"content":"Windows 下关闭 Nagle 算法 打开注册表编辑器 打开如下路径 计算机 \\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces 注册表界面\" 注册表界面 依次点击下方注册表项，检查右窗格中是否包含 DhcpIPAddress 值； 在包含有 DhcpIPAddress 的子项下，分别建立两个 DWORD (32) 值，依次命名为 TcpAckFrequency 和 TCPNoDelay，键值全部设为 1。 注意 包含 DhcpIPAddress 的子项可能不只一个，所有的都要添加。 ","date":"2020-06-28","objectID":"/nagle/:2:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Network"],"content":"参考 [1] Nagel 算法维基百科 [2] RFC896 ","date":"2020-06-28","objectID":"/nagle/:3:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Linux"],"content":" 记录一些常见的 Linux 服务器安全问题分析以及防护措施 ","date":"2020-06-07","objectID":"/linux_security/:0:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"日志分析 ","date":"2020-06-07","objectID":"/linux_security/:1:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"常用日志文件 Debian 以及 RHEL 系的系统日志是由一个名为 syslog 的服务管理的，如以下日志文件都是由 syslog 日志服务驱动的： /var/log/boot.log：记录了系统在引导过程中发生的事件，就是 Linux 系统开机自检过程显示的信息 /var/log/lastlog ：记录最后一次用户成功登陆的时间、登陆 IP 等信息 /var/log/messages ：记录 Linux 操作系统常见的系统和服务错误信息 /var/log/secure ：Linux 系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 /var/log/syslog：只记录警告信息，常常是系统出问题的信息，使用 lastlog 查看 /var/log/wtmp：该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，使用 last 命令查看 /var/run/utmp：该日志文件记录有关当前登录的每个用户的信息。如 who、w、users、finger 等就需要访问这个文件 /var/log/btmp：记录 Linux 登陆失败的用户、时间以及远程 IP 地址 /var/log/auth.log 或 /var/log/secure 存储来自可插拔认证模块 (PAM) 的日志，包括成功的登录，失败的登录尝试和认证方式。 注：Debian 系在 /var/log/auth.log 中存储认证信息而 RHEL 系则在 /var/log/secure 中存储。 Archlinux 使用 systemd 提供的日志系统（logging system），称为 journal。使用 systemd 日志，无需额外安装日志服务（syslog）。 ","date":"2020-06-07","objectID":"/linux_security/:1:1","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"相关日志查看命令 $ cat /var/log/secure | awk '/Failed/{print $(NF-3)}' | sort | uniq -c | awk '{print $2\"=\"$1;}' 查看尝试暴力登录 root 的 IP 及次数 $ grep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more ","date":"2020-06-07","objectID":"/linux_security/:1:2","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"常见防护措施 ","date":"2020-06-07","objectID":"/linux_security/:2:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"SSH 编辑 SSH 配置文件 $ vim /etc/ssh/sshd_config 1、修改端口 #Port 22 —\u003e Port xxxx 2、关闭 root 登录 PermitRootLogin yes -\u003e PermitRootLogin no 3、使用证书登录 若不存在证书首先执行下面步骤 在客户端生成密钥: $ ssh-keygen -t rsa 把公钥拷贝至服务器: $ ssh-copy-id -i .ssh/id_rsa.pub server 或手动将 id_rsa.pub 拷贝至服务器用户目录的.ssh 中，并修改访问权限： $ scp .shh/id_rsa.pub server:~/.ssh 服务器中： $ chmod 400 authorized_keys 打开证书登录： RSAAuthentication yes 开启公钥验证： PubkeyAuthentication yes 验证文件路径： AuthorizedKeysFile .ssh/authorized_keys 禁止密码认证： PasswordAuthentication no 禁止空密码： PermitEmptyPasswords no 最后，重启 SSHD 服务 $ systemctl restart sshd ","date":"2020-06-07","objectID":"/linux_security/:2:1","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"用户以及用户组管理 无用用户、用户组 Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户 使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时 在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限 可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"关闭不必要的服务 例如 某台 Linux 服务器用于 www 应用，那么除了 httpd 服务和系统运行是必须的服务外，其他服务都可以关闭。下面这些服务一般情况下是不需要的，可以选择关闭： anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv ","date":"2020-06-07","objectID":"/linux_security/:2:3","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"文件系统安全 文件权限检查和修改 （1）查找系统中任何用户都有写权限的文件或目录 $ find / -type f -perm -2 -o -perm -20 |xargs ls -al //查找文件 $ find / -type d -perm -2 -o -perm -20 |xargs ls –ld //查找目录 （2）查找系统中所有含 “s” 位的程序 $ find / -type f -perm -4000 -o -perm -2000 -print | xargs ls –al 含有 “s” 位权限的程序对系统安全威胁很大，通过查找系统中所有具有 “s” 位权限的程序，可以把某些不必要的 “s” 位程序去掉，这样可以防止用户滥用权限或提升权限的可能性。 （3）检查系统中所有 suid 及 sgid 文件 $ find / -user root -perm -2000 -print -exec md5sum {} ; $ find / -user root -perm -4000 -print -exec md5sum {} ; 将检查的结果保存到文件中，可在以后的系统检查中作为参考。 （4）检查系统中没有属主的文件 $ find / -nouser -o –nogroup 没有属主的孤儿文件比较危险，因此找到这些文件后，要么删除掉，要么修改文件的属主，使其处于安全状态。 ","date":"2020-06-07","objectID":"/linux_security/:2:4","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"参考 [1] Linux 服务器为什么被黑？ [2] linux 系统安全加固 – 账号相关 [3] Security - Archlinux Wiki ","date":"2020-06-07","objectID":"/linux_security/:3:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Software"],"content":" 简单介绍使用 Docker 运行的 Huginn 数据的备份与恢复 ","date":"2020-05-27","objectID":"/huginn_backup/:0:0","tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/"},{"categories":["Software"],"content":"备份数据 使用命令在容器中生成备份： $ docker exec -it huginn mysqldump --single-transaction --opt -u root -ppassword huginn_production \u003e huginn_backupfile.sql 或直接拷贝数据到容器外： $ docker exec -it huginn mysqldump -u root -ppassword huginn_production \u003e /root/test_db.sql ","date":"2020-05-27","objectID":"/huginn_backup/:0:1","tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/"},{"categories":["Software"],"content":"恢复数据 首先复制文件到 docker 中： $ docker cp /home/xxxx/huginn_backupfile.sql huginn: /app/xxxxx/huginn_backupfile.sql 然后进入 docker： $ docker exec -ti huginn bash 接下来恢复数据库: $ mysql -u root -ppassword huginn_production \u003c huginn_backupfile.sql ","date":"2020-05-27","objectID":"/huginn_backup/:0:2","tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/"},{"categories":["VM"],"content":" PVE 安装过程中遇到的问题以及解决方法 PVE 安装 Q\u0026A 近期将家里的服务器从 Hyper-V 迁移到 PVE 上。 目前安装有黑群晖、Openwrt、Ubuntu 18.09LTS 目前的网络拓扑图如下： 网络拓扑图\" 网络拓扑图 将安装过程中遇到的问题以及解决方法整理如下： ","date":"2020-05-19","objectID":"/pve_q_a/:0:0","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"1. Temporary failure in name resolution： 由于开始使用路由器拨号，因此初次安装设置的 DNS 服务器为路由器地址，安装软路由后更改了地址，所以导致 DNS 服务器设置错误 192.168.1.190 \u003e 192.168.1.1 ","date":"2020-05-19","objectID":"/pve_q_a/:0:1","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"2. 群晖挂载硬盘： PVE 正确识别到了 NTFS 的一硬盘，但是群晖不能自动挂载。需要关机后，在 PVE 虚拟机管理界面，添加，然后重启才能识别。(否则显示为红色，同样的，移除硬件需要同样的操作) ","date":"2020-05-19","objectID":"/pve_q_a/:0:2","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"3. PVE 节点监视图不显示，时间为 1970-1-1： 删除界面缓存文件即可： $ rm /var/lib/rrdcached/db/pve2-node ","date":"2020-05-19","objectID":"/pve_q_a/:0:3","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"4. 群晖 socks 代理 Openwrt 安装 luci-app-Privoxy，设置转发规则： $ /ip:port . ","date":"2020-05-19","objectID":"/pve_q_a/:0:4","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["Web"],"content":" 记录使用 Hugo 搭配 LoveIt 搭建本博客遇到的问题以及解决方案 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:0","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"1. 虚拟机中 Hugo server 无法远程访问 hugo server 默认只会 bind localhost 使用： $ Hugo server --bind xxx.xxx.xxx.xxx 指定虚拟机 IP，即可通过同网域机器访问该 web 服务 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:1","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"2. 使用 git 信息生成文章上一次修改时间 首先，启用 git 信息： enableGitInfo = true 然后，启用 gitRepo 参数： gitRepo = “/xxx/xxxx/.git/” 需要注意的是： 这里 .git 应该 init 在 Hugo 生成的项目根目录中 但是这样，如果只 push public 文件夹到 Github 上部署的话，网页上无法正确跳转对应的 commit 详情页。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:2","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"3. 页面出现 %!(EXTRA string=xxxx) LoveIt Github Issue 提到该问题的解决方案 但实际通过修改 config.toml 中的defaultContentLanguage = \"zh\"为defaultContentLanguage = \"zh-cn\"即可解决。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:3","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"4.开启 Gitalk 评论 Gitalk 使用 Github 仓库的 Issue 页面存储评论内容。 因此，首先我们需要在 Github 新建一个仓库（推荐）用于存储评论。 接着打开 Settings \u003e Developer settings \u003e OAuth Apps ，点击 New OAuth App 新建 OAuth App\" 新建 OAuth App 然后填写信息： Application name : 随便填写 Homepage URL : 随便填写 Application description : 随便填写 Authorization callback URL : 一定要填写你的博客地址 完成后，点击 Register application 完成注册。 然后找到博客项目根目录中的 config.toml ，修改以下字段： [params.page.comment.gitalk] enable = true owner = “techkoala” # 你的 Github 用户名 repo = “commets_of_blog” # 用于存储评论的仓库名 clientId = “xxxxxx” # 请于 OAuth App 页面获取 clientSecret = “xxxxxx” # 请于 OAuth App 页面获取 完成上述设置后，现在就可以正常使用 Gitalk 评论系统了。评论内容可以通过 Github 对应仓库的 Issue 页面进行管理。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:4","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"CDN 配置 LoveIt 的默认的 CDN 数据文件位于 themes/LoveIt/assets/data/cdn/ 目录。 将该目录下的 jsdelivr.yml 移动到你的项目下相同路径： assets/data/cdn/。（如果需要使用别的 CDN，可以执行参考 CDN 网站的配置说明对 jsdelivr.yml 进行修改 然后修改 config.toml 文件中的： CSS 和 JS 文件的 CDN 设置 [params.cdn] CDN 数据文件名称, 默认不启用 (“jsdelivr.yml”) data = “jsdelivr.yml” ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:5","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Github"],"content":" 总结使用 Github 时遇到的问题以及解决方法 ","date":"2020-05-10","objectID":"/github_issue/:0:0","tags":["Git"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["Github"],"content":"无法推送 ​ 首先，使用如下命令检查问题详情： $ ssh -vT git@github.com ​ 然后确认您的私钥已生成并加载到 SSH。 如果使用的是 OpenSSH 6.7 或更早版本： # 在后台启动 ssh-agent $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 $ ssh-add -l \u003e 2048 a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/you/.ssh/id_rsa (RSA) ​ 如果使用的是 OpenSSH 6.8 或更新版本： # 在后台启动 ssh-agent $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 $ ssh-add -l -E md5 \u003e 2048 MD5:a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/you/.ssh/id_rsa (RSA) ","date":"2020-05-10","objectID":"/github_issue/:1:0","tags":["Git"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["Github"],"content":"确认公钥已附加到账户 ​在后台启动 SSH 代理程序。 $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 ​找到并记录公钥指纹。 如果使用的是 OpenSSH 6.7 或更早版本： $ ssh-add -l \u003e 2048 a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/USERNAME/.ssh/id_rsa (RSA) ​如果使用的是 OpenSSH 6.8 或更新版本： $ ssh-add -l -E md5 \u003e 2048 MD5:a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/USERNAME/.ssh/id_rsa (RSA) 如果没有添加，则 $ ssh-add /xxx/.ssh/xxx 注：不知为何，使用自定义名字的密钥，每次 git 操作都要重新添加一次，尚不明确原因。 ","date":"2020-05-10","objectID":"/github_issue/:1:1","tags":["Git"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["Github"],"content":"添加到 Github ​ Settings \u003e SSH and GPG keys \u003e 添加公钥即可 ","date":"2020-05-10","objectID":"/github_issue/:1:2","tags":["Git"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":null,"content":" 粗体 表示在多平台中使用的软件 斜体 表示优先选择表示商店版本(Windows \u0026 MacOS) Linux 优先选用对应包管理器安装 ","date":"2019-12-30","objectID":"/softwares/:0:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"浏览器 FireFox Microsoft Edge Chrome ","date":"2019-12-30","objectID":"/softwares/:1:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"浏览器插件 ClearURLs Enpass extension Feedbro：RSS阅读器 MONKNOW：美化新建标签页 OneNote Web Clipper Proxy SwitchyOmega Save to Pocket Tampermonkey uBlock Origin 京价保 - 京东价保助手 FireShot 沙拉查词-聚合词典划词翻译 隐私獾 Augmented Steam：steam 增强 Free Download Manager Imagus：鼠标悬停放大图片 Little Star：Github 分类管理 Notion Web Clipper OneTab Stylus Unpaywall：文献解锁 Reggy：匿名用户资料生成 Vimium 二管家：扩展管理 ","date":"2019-12-30","objectID":"/softwares/:1:1","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"压缩\u0026解压缩 Bandizip：7.0版本已增加付费,停留于6.26 7-zip Peazip ","date":"2019-12-30","objectID":"/softwares/:2:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"下载 FDM Motrix Eagleget：官方宣称是外国软件，查询证书为国产，原因不明 IDM Aria2 Aria2NG Curl Wget ","date":"2019-12-30","objectID":"/softwares/:3:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"游戏平台及工具 战网 Steam Origin Uplay GOG Galaxy 网易UU Logitech鼠标驱动 ","date":"2019-12-30","objectID":"/softwares/:4:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"Code Visual studio code Visual studio 2019 Git Python3 Matlab Pycharm-professional Goland Go ","date":"2019-12-30","objectID":"/softwares/:5:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"文档工具 Office 365 Office tools plus：office 套件管理工具 Typora iSlide Tools DrawBoard PDF Adobe acrobat DC CAJViewer Visio OneNote Notion ","date":"2019-12-30","objectID":"/softwares/:6:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"视频\u0026音乐 Potplayer 斗鱼 网易云音乐 Mp3tag (歌曲信息管理) foobar2000 VLC Petal：Linux 下豆瓣 FM 第三方客户端 ","date":"2019-12-30","objectID":"/softwares/:7:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"网盘工具 Onedrive RaiDrive Rclone Speedpan ：已失效 Pandownload ：已失效，尽量避免使用百度网盘 Goodsync Resilio Sync ","date":"2019-12-30","objectID":"/softwares/:8:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"即时通信 Telegram Unigram ：Telegram 第三方客户端，相较官方客户端增加了 PC 端的端到端加密聊天功能 微信 QQ ","date":"2019-12-30","objectID":"/softwares/:9:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"密码管理 Enpass ","date":"2019-12-30","objectID":"/softwares/:10:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"网络工具 Shadowsocks-libev ：转向 vmess 协议 Sstap ：停止更新 V2rayN ：已转 Clash，支持更加灵活的规则和配置文件管理 Clash Clash for Windows ClashX Fiddler Best Trace MobaXterm ：已转 Termius,多端同步 Termius ZeroTier One Remmina ：Linux下远程桌面 Wireshark ","date":"2019-12-30","objectID":"/softwares/:11:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"效率工具 Quicker：已转utools Wox：已转utools WGestures ：Windows 鼠标手势 Fastcopy-M：基于原版的二次开发 Everything Pollar Easystroke：Linux 鼠标手势 Bcompare：已用 Meld 代替 Meld：跨平台开源文件/文件夹对比软件 Utools PowerToys ","date":"2019-12-30","objectID":"/softwares/:12:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"软件\u0026磁盘管理 CCleaner Dism++ Scoop：PowerShell 包管理器 Geek Uninstaller SpaceSniffer CrystalDiskMark CrystalDiskInfo DiskGenius ","date":"2019-12-30","objectID":"/softwares/:13:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"安全工具 火绒 Sandboxie ","date":"2019-12-30","objectID":"/softwares/:14:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"虚拟机 VMware Workstation Pro Hyper-V ","date":"2019-12-30","objectID":"/softwares/:15:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"阅读 irreader Liferea ","date":"2019-12-30","objectID":"/softwares/:16:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"Cli Zsh Oh-my-zsh：插件见配置文件 Navi Screenfetch Htop ","date":"2019-12-30","objectID":"/softwares/:17:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"系统工具 BleachBit Redshift Deepin-wine Docker TimeShift：系统备份 Better and Better iStat Menus ","date":"2019-12-30","objectID":"/softwares/:18:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"邮件 Thunderbird Outlook ","date":"2019-12-30","objectID":"/softwares/:19:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"🤷‍♂️我 对网络知识有浓厚的兴趣 会 Python🐍 的通信🐕 喜欢瞎折腾👨‍💻一些有用没用的技术 长期使用 Linux(Arch \u0026 Ubuntu) \u0026 Windows 工作学习 ","date":"2019-12-30","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"这个网站 本质上，就是我自己的笔记📔，某天突发奇想💭：做成网站也不错呀，随时都可以查看。于是就诞生了这网站。 网站文章使用 Markdown 撰写排版，网页利用 Hugo 渲染生成，页面由 LoveIt 装点。 网站托管在 Github Pages 上，套用了 Cloudflare \u0026 jsDelivr 的 CDN 。 在此，感谢 各位开发者 \u0026 公司。 ","date":"2019-12-30","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"说明 网站中含有 Translation 标签的文章，其 主要内容 来源于博主对优秀外文文章地翻译和校对，这里并不一定会遵循原文的叙述逻辑，内容上也会有一定的增删，原文请见文末参考。 译文的目的仅为加深自己学习的印象，同时希望能够共享优质的内容。 ","date":"2019-12-30","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"本站的内容授权 本站点发布内容默认采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议（CC BY-NC-SA 4.0）进行许可，即： 本授权条款允许您（用户）可以复制、发行、展览、表演、放映、广播或通过信息网络传播本站作品； 您必须以附加本站 URL 的方式对作品进行署名 若您改变、转变或更改本作品，仅在遵守与本作品相同的许可条款下，您才能散布由本作品产生的派生作品 您不得为商业目的而使用本作品 转载作品另行声明，遵守原作者授权协议，所有权利归原作者所有 如果我的文章能帮到你，那是我极大的荣幸 ","date":"2019-12-30","objectID":"/about/:0:4","tags":null,"title":"关于","uri":"/about/"},{"categories":["ChitChat"],"content":" 条形码以及二维码的过去与将来 注：本文是最早以 TechKoala 的名字所写的文章，发布于电脑爱好者 2013 年第 06 期。说来当时以邮汇方式发的稿费至今没有收到，2333  面对我们随时可以看见的条形码，说出来你也许会不信，如果没有这个家伙，整个世界的经济都无法正常运行。这些黑白条码不但能让机场不弄丢你的行李，能对快件的包裹进行跟踪，而且还能在网上对各种信件进行查询。它们既可以用在食品包装上，也可以用在图书的扉页。这个时候看看手上的《电脑爱好者》杂志，你发现了吗？ ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:0","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"条形码的由来  三十多年前的一天，一位名叫道森的购物者走进马什超市，购买了一包箭牌口香糖，扫扫条形码然后付钱。这在今天稀疏平常的事，当时却是标志性事件 — 由此，条形码迎来了它的里程碑，从此走到你我的眼前。 伍德蓝德\" 伍德蓝德  说到条形码，就不得不说它的发明者 —— 伍德蓝德。他出生于新泽西州，从小便对技术发明具有浓厚的兴趣，具备非凡的动手能力。他生长在二战前后，战争期间，他不得不中断学业，参与研发原子弹的曼哈顿工程，这个看似八竿子打不着边的事，却使他对发明愈发迷恋。二战之后，美国经济快速发展，规模宏大的超市面临着一个巨大的问题，他们无法精确掌握库存情况，唯一的办法是手工清理，但耗时又费力。于是他们向德雷赛尔大学求助，恰巧伍德蓝德得知，于是，伍德蓝德开始与自己的朋友苏沃一起研究这个解决方案。蓝德本来是出于商业目的，但随着研究的深入，这项工作彻底改变了他的人生。类似历史上的诸多发明，开始时，蓝德遇到了许多次失败，但他没有放弃。他毅然辍学全心投入，坚信成功不远，但总差那么一层窗户纸。后来，他去了迈阿密的住所放松，那里有优美的居住环境、安静的思考空间，他期待能有灵感迸发。  老天不负有心人。有一天，他在沙滩坐定，苦苦思索：“如何才能给每件物品分类呢？编号？对！莫尔斯电码？可是这样太复杂了，一般人也没办法分辨。” 想到此，他开始无聊地在沙滩上用手画沙子，一条一条，突然，一个神奇的图案出现在蓝德脑海 — 如果用粗细、间距不同的竖线构成图案，那就可以实现对商品编码。就这样，条码的原型在沙滩上诞生了。待到出现文章开头的一幕时，已经过去了三十多年，可喜的是，我们的主人公是一位有耐心的人。 ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:1","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"条形码的标准与应用  与现在的条形码不同，蓝德发明的第一条条形码不是由线条构成，而是一组同心圆，通过照片扫描器读取。它形如箭靶，美国人称其为 “公牛眼”。遗憾的是，以美国当时的工艺和经济水平，他们还没有能力印制出这种编码。 公牛眼\" 公牛眼  后来，伍德蓝德加入了 IBM 公司，并把自己的专利卖给了 IBM。然而，伟大的成果却并非属于 IBM，几经转手，机遇来到了 RCA 公司。直到条形码大展宏图时，IBM 公司里的人才知道：“哦，原来发明条形码的人就在我们公司。”  我们目前所知的第一个商用条形码出现于 1966 年，但人们很快就意识到应该为其制定出一个行业标准。  两年后的夏天，应国家食物连锁协会要求，Logicon 公司开发出了食品工业统一码（UGPIC）。随后，美国统一编码协会建立了 UPC 码系统，并且实现了该码制的标准化。UPC 码首先在杂货零售业中试用，俄亥俄州的 Marsh 超级市场安装了由 NCR（IBM 公司的前身）制造的第一台 UPC 扫描器，而第一个被收银员扫描的便是文章开头所说的标价 69 美分的十片装箭牌口香糖。  直到现在，我们都不可否认的是，正是零售业的成功应用才促进了条形码技术的发展。  目前，全球每天大约要扫描 80 亿次条形码。而普华永道公司的一项研究报告表明，条形码每年仅在超市和大众零售领域就能为客户、零售商和制造商节约 300 亿美元的成本。令人感到遗憾的是，伍德兰德的朋友，条形码联合发明人苏沃并没有亲眼看到条形码的商业化应用，他在自己 38 岁的时候（1962 年）英年早逝。而伍德蓝德则在 1992 年被当时的美国总统布什授予了国家科技奖章。  令人遗憾的是，前不久，伍德蓝也不幸地告别了人世。据《纽约时代》报道，他于美国当地时间 2012 年 12 月 9 日在自己新泽西的家中逝世，享年 91 岁。蓝德的女儿苏珊评价父亲说：“他参与了整个系统的设计，从使用者的站立方式、激光扫描仪高度到如何保护人们的眼睛不受激光刺激，他是一个绝对的完美主义者。” ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:2","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"条形码的未来  今天，条形码已经占据我们生活的每个角落，从超市购买的食品到手中握住的杂志，我们依靠条形码管理我们的生活，条形码技术也在不断进步。  其实，如今风生水起的二维码也属于条形码，作为后起之秀，它比它的前辈更进一步。自从它出现以来，得到了人们的广泛关注，发展十分迅速。  二维条形码最早发明于日本，它是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的，在代码编制上巧妙地利用构成计算机内部逻辑基础的 “0”、“1” 比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信息自动处理。它具有条形码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、处理图形旋转变化等特点。  一维条形码虽然提高了资料收集与资料处理的速度，但由于受到资料容量的限制，一维条形码仅能标识商品，而不能描述商品，因此相当依赖电脑网络和资料库。在没有资料库或不便连网的地方，一维条形码很难派上用场。此外一维条形码有一个明显的缺点，即垂直方向不携带资料，故资料密度偏低。当初这样设计有二个目的：（1）为了保证局部损坏的条形码仍可正确辨识；（2）使扫描容易完成。  要提高资料密度，又要在一个固定面积上印出所需资料，可用二种方法来解决：（1）在一维条形码的基础上向二维条形码方向扩展；（2）利用图像识别原理，采用新的几何形体和结构设计出二维条形码。前者发展出堆叠式（Stacked）二维条形码，后者则有矩阵式（Matrix）二维条形码之发展，构成现今二维条形码的两大类型： 堆叠式二维条形码的编码原理是建立在一维条形码的基础上，将一维条形码的高度变窄，再依需要堆成多行，其在编码设计、检查原理、识读方式等方面都继承了一维条形码的特点，但由于行数增加，对行的辨别、解码算法及软件则与一维条形码有所不同。较具代表性的堆叠式二维条形码有 PDF417、Code16K、Supercode、Code49 等。 矩阵式二维条形码是以矩阵的形式组成，在矩阵相应元素位置上，用点的出现表示二进制的 “1”，不出现表示二进制的 “0”，点的排列组合确定了矩阵码所代表的意义。其中点可以是方点、圆点或其他形状的点。矩阵码是建立在电脑图像处理技术、组合编码原理等基础上的图形符号自动辨识的码制，已较不适合用 “条形码” 称之。具有代表性的矩阵式二维条形码有 Datamatrix、Maxicode、Vericode、Softstrip、Code1、Philips Dot Code 等。  二维条形码的新技术在 1980 年代晚期逐渐被重视，在 “资料储存量大”、“资讯随着产品走”、“可以传真影印”、“错误纠正能力高” 等特性下，二维条形码在 1990 年代初期已逐渐被使用。现在，几乎所有的社交软件都具备扫一扫的功能，对着抽象的图案一扫，迎来一个多彩的世界已经成为许多人的习惯。  马化腾在去年九月开幕的互联网大会的演讲中便说到：“从微信强化扫二维码的功能之后，我们希望把这个行为定义成更加普及，老百姓一看到码就去扫的概念。我们前几天还在网上看到一个新的名词，就是扫墓，看到墓碑有那个二维码，一扫描就看到这个墓碑的主人过去的生平介绍等等，这些都是非常典型的应用。”  或许，墓碑的例子有些夸张，但是，你不能否认，条形码越来越贴近我们的生活，不再只是局限于购物。也许未来，我们的一切都涵盖在那小小的方寸之间。  碰巧，时隔多年把这篇文章重新整理出来的时候，回形针正好发布了一期关于二维码的视频：  放在这里，作为补充。 ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:3","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"Sybian 联盟\" Sybian 联盟 聊聊 Symbian 的过去 注：这是一篇写于 2013 年的文章，时过境迁，仅表怀念。  毫不夸张的说，今天我们所拥有的一切，都是建立在它的肩膀上。无论多少人咒骂它的臃肿，嫌弃它的卡顿，都无法改变它作为手机智能操作系统鼻祖的地位。当山寨机还在襁褓中时，当伪智能还在浪费人们的时间时，作为先驱的它便已上路。大多数人接触的第一款真正的智能手机系统，它把软件下载，游戏安装，刷机破解等诸多名词第一次带到了大众视野。它叫 Symbian，也曾辉煌。三十年河东，三十年河西，科技领域本就没有常青树。虽然如今已经沦落，但不妨碍我们一起回味它曾经的辉煌。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:0","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"混沌之初，Symbian 伊始 ​ Symbian，源自一家充满梦想的公司。  1980 年，potter 在伦敦成立了 Psion 公司，这家以数字产品开发和研究为目的，为率先使用电子设备的大公司服务的小公司便是 Symbian 的生母。随着公司的发展，Psion 开始浸淫移动终端市场，他们生产的各类移动设备不仅皮实耐用还能按需求定制，凭借这种 “开放移动” 的理念，Psion 在上世纪 90 年代 成为了欧洲较成功的 PDA 生产商，进而促进了 EPOC 的诞生。在 potter 看来，EPOC 是一种面向普通大众的便携系统。正如他的全称 “A new epoch of personal convenience.”（一个人人方便使用电子产品的新时代），他被 Psion 给予了对于人机交互未来的憧憬。  犹如一代闪电，EPOC 划开了混沌的天空，不过真正的风暴才刚来临。  1991 年到 1998 年，Psion 发布了几款给予 EPOC 16 的的设备，作为早期产品，免不了简陋无比，它们充其量只能算是 PDA 模块，只是方便了厂商研发新品。  真正让 EPOC 走向成熟的是一位叫做 Nicholas Myers 的程序设计师。1994 年，他在构思下一代 EPOC 时，设定了开发适应 21 世纪技术性能的系统的目标。正是这样的思路。让他把握住了市场脉搏。1997 年，他成为 Psion 旗下 Symbian 软件公司的 CEO，其上任后发布的 EPOC 32 操作系统，比起前辈，已有了翻天覆地的变化。吸引了人们以及投资者的兴趣。今天我们吧 Myers 成为 “Symbian 之父”。  EPOC 32 与 windows 极为相似，它是一套 32 位的系统，支持多任务，拥有图形化美观的界面。鉴于当时几乎没有可以直接用于手机的操作系统，它的问世，一下子汇聚了厂商的目光。不过，任何一项新技术新产品的诞生都需要时间的推敲，智能手机系统作为新兴事物，没有哪家厂商敢冒险直接挺近。一番商榷之后，1998 年，爱立信、诺基亚、摩托罗拉和 Psion 共同成立了一家公司，目的是推进手机和 PDA 的智能化，它就是我们今天熟知的 “Symbian”。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:1","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"拉帮结派，飞速发展  联盟的成立不仅吸引了大量手机厂商，一些上有配件商，例如 ARM 和德州仪器都加入了合作计划。  Symbian 从一成立便秉持着开放的理念，任何组织和个人都能为其开发软件。但刚成立那几年，公司都未能推出一款真真意义上的产品，巨头们也只是作为附属项目在发展。直到 1999 年，Symbian OS v5 平台作为第一款成熟的产品被设计出来，为了争夺 “谁是世界上第一台智能手机”，爱立信没有经过完成的 DEBUG，就匆忙的把他推向市场，生产出 Erisson R380。同时期，摩托也推迟了自己的天拓 A6188。可实际上，两者中无论哪个都不能算严格意义上的智能手机，它们连软件都不能自由安装，真正算起来，搭载了 os v5.1 的诺基亚 9210 才符合智能机最基本的定义，由此，诺基亚开始领先于其他厂商并保持到了最后。  众所周知，利益面前必有纠纷。诺基亚的崛起必然伴随了很多厂商的陨落，同时，它的存在也让联盟中其他有实力的厂商感到了危机，这为后来阵营的割分埋下了导火索。  Symbian 成立之初提出了著名的三分法：Pearl (珍珠）、Quartz (石英）和 Crystal（水晶）。分别对应手机的三大发展趋势：标砖键盘、触摸屏以及全键盘。诺基亚依靠 Pearl 迅速赢得了市场，逼迫索尼爱立信和摩托罗拉只能另寻他路 –Quartz。于是，联盟分为了两大派系，一是以诺基亚牵头的 S 系列平台，再者便是索尼爱立信主打 UIQ。诺基亚凭借标准键盘占据了大半江山，而后者则主攻触摸屏。这种同床异梦的现象愈演愈烈，直接导致了联盟崩溃的迫近。  当然，上述现象只是苗头，整个联盟正处于高速发展阶段。2002 年，微软的 WM 系统进入市场，这个原本被人们誉为 “Symbian 终结者” 的系统，却远没有它的大哥一般占据市场，反而被后者打的满地找牙。与此同时，诺基亚更是凭借 Pearl 进一步扩展帝国的领土，N70、N73、N95 的横空出世，为诺基亚扎实了自己的实力，待到 Symbian 王朝最鼎盛时，这个姓塞的家族占据了 72% 的智能手机市场，其中更是有九成乃至如日中天的诺基亚。直到现在，都没有哪一家厂商甚至哪一个操作系统打破这个纪录。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:2","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"兄弟反目，联盟瓦解  正如上文所说，一家独大必然引发隐患。而事实证明那一天来了。2008 年，UIQ 宣布倒闭。究其原因，一方面是由于它自身定位与市场的极大反差，而另一方面便是来自于诺基亚的压力。相比 S60，开发者在这个平台上的收益远不及前者。应用程序的短缺自然局限了消费者的购买欲，如此一来，倒闭似乎只是时间问题了。诺基亚的持续壮大，扼杀了其他厂商的利润，长此以往，天平的过分了倾斜让别的厂商不得不退出 Symbian 的纷争。UIQ 的倒闭，标志着诺基亚对于 Symbian 掌控的最大化，后者从此只有一个主人了。  联盟名存实亡，但诺基亚为了避嫌，标榜着 “开放” 而成立了 Symbian 基金会，继续推向面向所有开发者开放的原则，明则共享资源，暗则染指一统智能市场。不幸的是，这是 iPhone 和 Android 问世了。后来的结果，各位看官一定也都清楚。诺基亚的美梦做早了，自大的它快走到了末路。  多年以后，关于那个一统江湖的传说，早已沦为笑谈罢了。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:3","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"成也 Symbian，败也 Symbian  船大难掉头。巨头对于市场末端的变化总是慢半拍。身处多年王位的诺基亚早已麻痹了大意。UIQ 的倒闭，让其认为触摸屏不被市场接受，继续推进 S60 这个老迈的系统被诺基亚看做唯一路线。iPhone 的面市彻底颠覆了人们对于智能手机的认识，一度让人们认为 iPhone 重新定义了智能手机。市场的反应也确实印证了这一点，我们的双手确实是最适合操作的工具。但固守己见的诺基亚貌似看不到这一变化，迟迟不肯跳出键盘的定式思维。虽然后来确实推出了几款诸如 5800 这样销量很不错的触屏手机，当一切来的太晚，苹果做大了，随后的绿皮机器人也成熟了，Symbian 王朝彻底步入了晚年。  失去市场号召力的诺基亚此时的地位一落千丈，对于 Symbian 的态度也是一日三变。曾一度把源代码挂在网站上任人下载，随后又宣布只面向企业用户开源。这时的诺基亚真的急了。不愿投奔机器人阵营沦落为硬件制作商的他，竟甘心跪倒在昔日手下败将的裙下。2011 年 12 月，Symbian Belle 正式更名为诺基亚 Belle。诺基亚连名字都不行再见的 Symbian 从此已经不复存在。  然而，这并不意味着 Symbian 彻底的灭亡。名字虽然没有了，但产品依旧没有改变，与其说它灭亡不如说它失去了原来那般强大的市场号召力。毕竟，凭借 S40 在低端市场的畅销，诺基亚还能在手机市场分的一杯羹。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:4","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"未来？未来！  向微软投怀送抱之后，诺基亚在 Symbian 的建树彻底才枯思竭。以至于不得不推出 808 这样依靠单一买点为噱头吸引市场关注的 “帐篷手机”。Symbian 的今生今世已经无话可说。而未来又在何方？原本打算有所期盼的笔者，本来打算对它的未来有所展望和揣测，不幸的是，本文截稿前的 1 月 24 日，诺基亚公布了 2012 年第四季度最新的财政业绩报告显示，该季度诺基亚实现净利润 2.02 亿欧元，告别 6 连亏，但同时诺基亚官方宣称去年在巴塞罗那发布的 808PureView 将会是最后一款塞班手机，这也意味着塞班这一已经被使用了 15 年之久的智能手机操作系统终于将告别市场，而诺基亚在智能手机领域也终于百分之百微软化。 诺基亚 CEO 斯蒂芬・埃洛普表示：“2012 财年上半年相对艰难，但第四财季表现强劲，设备和服务部门的运营利润率得到了改善。我们将继续执行既定的转移战略，包括继续提升产品竞争力，加速运营，管理成本等。”  因此，至少在看得见的未来，Symbian 已经没有了未来！ ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:5","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"末了  无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。 P.S. 谨以此文献给那些成长路上的人和事，Symbian 没了，坛子没有了，但我们都还在。这些有关我们青春的事逝去也就随他去了，至少我们还有彼此。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:6","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":" Symbian、黑莓、苹果、微软、Android 五大手机系统，谁先会被淘汰？ ","date":"2010-04-12","objectID":"/mobile_phone_systems/:0:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"BlackBerry  这是一个很难预测的问题，先从黑莓说起吧，黑莓的成功是–针对高级白领和企业人士，提供企业移动办公的一体化解决方案，它让手机邮件发送变的更简单，所以它得到了众多商务人士及企业的青睐，但它在娱乐互联网上缺乏吸引力，一旦其它竞争对手加强在移动办公上的投入及创新，那么黑莓的优势将不复存在（最新的苹果系统 iso4 已经加强了在企业方面的应用）。虽然它现在份额依然是世界第二、美国第一，但它依然会是第一个被淘汰的。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:1:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Symbian  Symbian 是因为诺基亚而存在的系统，它的兼容性是最差的，实用复杂，速度慢（尤其是上网速度）所以不被看好，之所以它一直以来是世界最大的智能手机系统，那是因为诺基亚的金子招牌在支撑着，除了诺基亚之外的 Symbian 手机（三星、索爱）一直以来销量都不理想。缺乏创新，所以它是第二个被淘汰的系统。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:2:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Android  Android 速度最快的系统，被大家都看好，但它不可能成为第二个苹果，因为它的软件开发平台是开源的，导致了不同版本的出现，中国移动就是最好的例子，现在中国移动自主系统的手机想升级到 Android 最新版本是很困难的，加上品牌、型号不一样，硬件配置及屏幕尺寸不同，导致了同一个游戏在不同品牌及型号之间有着不同的表现，而苹果可以让一个游戏在四代上都是最佳体显（这样可以让软件的开发者利益最大化，而不需要为不同型号手机做出修改），Android 不会被淘汰，也许它会成为世界最大手机系统，但它将会沦为大众系统，我相信不久它将成为山寨手机进军低端智能市场的利器…  最后才是苹果与微软在中高端市场上的巅峰对决… ","date":"2010-04-12","objectID":"/mobile_phone_systems/:3:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Microsoft  虽然现在微软的 ppc 已经被淘汰，但它的 WP7 即将上线，一个替代 PPC 的时代即将到来，从最近放出的 WP7 资料来看，它是非常强大的，拥有众多新功能，凭着微软在 PC 市场上的垄断地位，加上它与 PC 之间的强兼容性，相信它前景广阔。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:4:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Apple  苹果是一个传奇，能让一款手机买到第三年而依然拥有强大的市场竞争力，不得不说这是一个奇迹，历史上可能只有摩托罗拉的 V998 可以与之相比了，V998、V998＋V988＋＋V8088，但苹果还在续写传奇，第四代已经出来了，苹果开创了一个手机的新时代，三年了，没有一个对手可以打败它，超越它，它引领着手机一次次的潮流，一次次的把手机用户体验推向一个新的水准，拥有 22 万多个应用商店、加上音乐商店，图书商店，它再一次的把资源整合到了极致，把苹果所有的娱乐产品连成了一个整体，这是其它对手所没有的优势，所以苹果会一直传奇下去… 注：本文写于2010年，时过境迁，有些事情似乎沿着上文预言发展，有些却不然。正如《Symbian 的前世今生》所言：无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:5:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"}]