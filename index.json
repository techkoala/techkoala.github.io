[{"categories":["WirelessCommunication"],"content":" 什么是波束赋形？波束赋形的基本原理是什么？5G 怎样实现波束赋形？ 注：本文系全文转载，原文信息如下： 作者：无线深海 链接：https://zhuanlan.zhihu.com/p/144971077 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2020-09-09","objectID":"/beamforming/:0:0","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":"什么是波束赋形？ 波束赋形这个概念可以拆分成波束和赋形这两个词来理解。 波束里的波字可以认为是电磁波，束字的本意是“捆绑”，因此波束的含义是捆绑在一起集中传播的电磁波 赋形可以简单地理解为“赋予一定的形状” 合起来，波束赋形的意思就是赋予一定形状集中传播的电磁波。 分散与集中的光线\" 分散与集中的光线 其实，我们常见的光也是一种电磁波，灯泡作为一个点光源，发出的光没有方向性，只能不断向四周耗散；而手电筒则可以把光集中到一个方向发射，能量更为聚焦，从而照地更远。 无线基站也是同理，如下图所示，如果天线的信号全向发射的话，这几个手机只能收到有限的信号，大部分能量都浪费掉了。 分散与集中的电磁波\" 分散与集中的电磁波 而如果能通过波束赋形把信号聚焦成几个波束，专门指向各个手机发射的话，承载信号的电磁能量就能传播地更远，而且手机收到的信号也就会更强。 因此，波束赋形在无线通信中大有可为。 ","date":"2020-09-09","objectID":"/beamforming/:1:0","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":"波束赋形的基本原理是什么？ 波束赋形的物理学原理，其实就是波的干涉现象。 频率相同的两列波叠加，使某些区域的振动加强，某些区域的振动减弱，而且振动加强的区域和振动减弱的区域相互隔开。 想象一下，在湖边漫步时，你和女朋友在相距很近的两点激起水波，两朵涟漪不断散开，然后交叠起来，形成了下面的图样。 波的干涉现象\" 波的干涉现象 可以看出，有的地方水波增强，有的地方则减弱，并且增强和减弱的地方间隔分布，在最中间的狭窄区域最为明显。 如果波峰和波峰，或者波谷和波谷相遇，则能量相加，波峰更高，波谷更深。这种情况叫做相长干涉。 反之，如果波峰和波谷相遇，两者则相互抵消，震动归于静寂。这种情况叫做相消干涉。 如果把这个现象抽象一下，可以得到下图： 波的干涉\" 波的干涉 在两个馈源正中间的地方由于相长干涉，能量最强，可以认为形成了一个定向的波束，也叫做主瓣；两边则由于相消干涉能量抵消，形成了零陷，再往两边又是相长干涉，但弱于最中间，因此称作旁瓣。 如果我们能继续增强正中央主瓣的能量，使其宽度更窄，并抑制两边的旁瓣，就可以得到干净利落的波束了。 其实，普通天线一直在做这样的事情。 天线内部排布着一系列的电磁波源，称作振子，或者天线单元。这些天线单元也利用干涉原理来形成定向的波束。 单列天线\" 单列天线 由上图可以看出，纵向排列的天线单元越多，最中间的可集中的能量也就越多，波束也就越窄。 但这只是一个垂直截面而已，其实完整的波束在空间是三维的，水平和垂直的宽度可能截然不同。 下图是一个天线的振子排列，以及辐射能量三维分布图。 纵向双列天线\" 纵向双列天线 可以看出，上述天线内振源的排布方式为纵向，横向的数量很少，因此其波束在垂直方向的能量集中，而水平方向的角度还是比较宽的，像一个薄薄的大饼。 这种传统的天线水平方向的辐射角度多为 60 度，进行大面积的地面信号覆盖是一把好手，但要垂直覆盖高楼就有些力不从心了，称作“波束赋形”还是不够格。 如果我们把这些天线单元的排布改成矩形，电磁波辐射能量将在最中央形成一个很粗的主瓣，周边是一圈的旁瓣，这就有点波束赋形的意思了。 矩形天线\" 矩形天线 为了让波束更窄能量更集中，天线单元还需要更多更密，水平和垂直两个维度也都要兼顾，原本的天线就变成了大规模天线阵列。 大规模矩形天线\" 大规模矩形天线 这下，生成的波束就犀利多了，用大规模天线阵列来支持波束赋形，稳了！ 但是这样还有问题，那就是这个最大波束位于正中央，且其传播方向和天线阵列垂直，而手机是一直随着用户移动的，所在的位置完全不确定，主波束虽然犀利，但照射不到手机上也是白搭。 那么，能不能让波束偏移一定的角度，对准手机来发射呢？ 首先我们看看中央的主波束的形成过程：多列波的相位相同，也就是波峰和波谷在同一时间是对齐的，则它们到达手机时，就可以相长干涉，信号通过叠加得以增强。 到达同相，相长干涉\" 到达同相，相长干涉 如果手机和天线阵列有一定的夹角，则各列波到达手机时，相位难以对齐，可能是波峰和波谷相遇，也可能是在其他相位进行叠加，难以达到相长干涉，信号叠加的效果。 到达异相，无法相长\" 到达异相，无法相长 这可咋办？总不能通过旋转天线来让波束跟随手机吧？ 其实，周期性是波最大的特点，不同的相位总是周期性的出现，错过了这个波峰，还有下一个波峰要来，因此相位是可以调整的。 通过调整不同天线单元发射信号的振幅和相位（权值），即使它们的传播路径各不相同，只要在到达手机的时候相位相同，就可以达到信号叠加增强的结果，相当于天线阵列把信号对准了手机。 相位控制\" 相位控制 下图是一个示例，可以看出天线阵列通过调整发射信号的相位，让波束偏移了 θ 度，从而可以精确对准手机发射信号。 相位控制\" 相位控制 ","date":"2020-09-09","objectID":"/beamforming/:2:0","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":"5G 怎样实现波束赋形？ 由此可见，波束赋形的关键在于天线单元相位的管控，也就是天线权值的处理。 根据波束赋形处理位置和方式的不同，可分为 数字波束赋形 模拟波束赋形 混合波束赋形 ","date":"2020-09-09","objectID":"/beamforming/:3:0","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":"模拟波束赋形 所谓模拟波束赋形，就是通过处理射频信号权值，通过移相器来完成天线相位的调整，处理的位置相对靠后。 模拟波束赋形\" 模拟波束赋形 模拟波束赋形的特点是基带处理的通道数量远小于天线单元的数量，因此容量上受到限制，并且天线的赋形完全是靠硬件搭建的，还会受到器件精度的影响，使性能受到一定的制约。 模拟波束赋形框图\" 模拟波束赋形框图 ","date":"2020-09-09","objectID":"/beamforming/:3:1","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":"数字波束赋形 数字波束赋形则在基带模块的时候就进行了天线权值的处理，基带处理的通道数和天线单元的数量相等，因此需要为每路数据配置一套射频链路。 数字波束赋形\" 数字波束赋形 数字波束赋形的优点是 赋形精度高 实现灵活 天线权值变换响应及时 缺点是 基带处理能力要求高 系统复杂 设备体积大 成本较高 Sub6G 频段，作为当前 5G 容量的主力军，载波带宽可达 100MHz，一般采用采用数字波束赋形，通过 64 通道发射来实现小区内时频资源的多用户复用，下行最大可同时发射 24 路独立信号，上行独立接收 12 路数据，扛起了 5G 超高速率的大旗。 数字波束赋形框图\" 数字波束赋形框图 在毫米波 mmWave 频段，由于频谱资源非常充沛，一个 5G 载波的带宽可达 400MHz，如果单个 AAU 支持两个载波的话，带宽就达到了惊人的 800MHz！ 如果还要像 Sub6G 频段的设备一样支持数字波束赋形的话，对基带处理能力要求太高，并且射频部分功放的数量也要数倍增加，实现成本过高，功耗更是大得吓人。 ","date":"2020-09-09","objectID":"/beamforming/:3:2","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":"混合波束赋形 因此，业界将数字波束赋形和模拟波束赋形结合起来，使在模拟端可调幅调相的波束赋形，结合基带的数字波束赋形，称之为混合波束赋形。 混合波束赋形数字和模拟融合了两者的优点： 基带处理的通道数目明显小于模拟天线单元的数量 复杂度大幅下降 成本降低 系统性能接近全数字波束赋形 非常适用于高频系统 混合波束赋形框图\" 混合波束赋形框图 这样一来，毫米波频段的设备基带处理的通道数较少，一般为 4T4R，但天线单元众多，可达 512 个，其容量的主要来源是超大带宽和波束赋形。 在波束赋形和 Massive MIMO 的加成之下，5G 在 Sub6G 频谱下单载波最多可达 7Gbps 的小区峰值速率，在毫米波频谱下单载波也最多达到了约 4.8Gbps 的小区峰值速率。 ","date":"2020-09-09","objectID":"/beamforming/:3:3","tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/"},{"categories":["WirelessCommunication"],"content":" Meanings of 3GPP releases ","date":"2020-09-03","objectID":"/3gpp_releases/:0:0","tags":["3GPP"],"title":"3GPP Releases","uri":"/3gpp_releases/"},{"categories":["WirelessCommunication"],"content":"3GPP Release schedule and summary 3GPP RELEASE RELEASE DATE DETAILS Phase 1 1992 Basic GSM Phase 2 1995 GSM features including EFR Codec Release 96 Q1 1997 GSM Updates, 14.4 kbps user data Release 97 Q1 1998 GSM additional features, GPRS Release 98 Q1 1999 GSM additional features, GPRS for PCS 1900, AMR, EDGE Release 99 Q1 2000 3G UMTS incorporating WCDMA radio access Release 4 Q2 2001 UMTS all-IP Core Network Release 5 Q1 2002 IMS and HSDPA Release 6 Q4 2004 HSUPA, MBMS, IMS enhancements, Push to Talk over Cellular, operation with WLAN Release 7 Q4 2007 Improvements in QoS \u0026 latency, VoIP, HSPA+, NFC integration, EDGE Evolution Release 8 Q4 2008 Introduction of LTE, SAE, OFDMA, MIMO, Dual Cell HSDPA Release 9 Q4 2009 WiMAX / LTE / UMTS interoperability, Dual Cell HSDPA with MIMO, Dual Cell HSUPA, LTE HeNB Release 10 Q1 2011 LTE-Advanced, Backwards compatibility with Release 8 (LTE), Multi-Cell HSDPA Release 11 Q3 2012 Heterogeneous networks (HetNet), Coordinated Multipoint (CoMP), In device Coexistence (IDC), Advanced IP interconnection of Services, Release 12 March 2015 Enhanced Small Cells operation, Carrier Aggregation (2 uplink carriers, 3 downlink carriers, FDD/TDD carrier Release 13 Q1 2016 LTE-U / LTE-LAA, LTE-M, Elevation beamforming / Full Dimension MIMO, Indoor positioning, LTE-M Cat 1.4MHz \u0026 Cat 200kHz introduced Release 14 Mid 2017 Elements on road to 5G Release 15 End 2018 5G Phase 1 specification Release 16 2020 5G Phase 2 specification Release 17 ~Sept 2021 ","date":"2020-09-03","objectID":"/3gpp_releases/:1:0","tags":["3GPP"],"title":"3GPP Releases","uri":"/3gpp_releases/"},{"categories":["WirelessCommunication"],"content":"参考 [1] 3GPP Specification Release Numbers ","date":"2020-09-03","objectID":"/3gpp_releases/:2:0","tags":["3GPP"],"title":"3GPP Releases","uri":"/3gpp_releases/"},{"categories":["Web"],"content":" 加速访问！ ","date":"2020-08-26","objectID":"/migrated_to_vercel/:0:0","tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/"},{"categories":["Web"],"content":"When 网站已于 2020-8-26 迁移至 Vercel ","date":"2020-08-26","objectID":"/migrated_to_vercel/:1:0","tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/"},{"categories":["Web"],"content":"Why 鉴于目前 Github 以及 Cloudflare 在国内的访问速度一日不如一日，所以开始寻找了替代服务。刚好有 V2er 发帖求助相同的需求，于是顺着帖子的推荐选择了 Vercel。 ","date":"2020-08-26","objectID":"/migrated_to_vercel/:2:0","tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/"},{"categories":["Web"],"content":"What 下面是 Vercel 官网的介绍： Vercel is a cloud platform for static sites and Serverless Functions that fits perfectly with your workflow. It enables developers to host Jamstack websites and web services that deploy instantly, scale automatically, and requires no supervision, all with no configuration. 相比于 Github Pages、Netlify 等，Vercel 拥有台湾和香港节点，对国内用户更加友好，并且免费套餐足够应付小流量情况了。 Vercel\" Vercel ","date":"2020-08-26","objectID":"/migrated_to_vercel/:3:0","tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/"},{"categories":["Web"],"content":"How 此前，本网站是托管在 Github Pages,然后通过 Clouflare 进行代理访问，因此只需要在 Cloudfalre 原配置上就行修改即可。 首先，直接使用 Github 账号（或 Gitlab 等）登录 Vercel 即可（注： 不可以使用 QQ 邮箱为主邮箱的 Github 账号，Vercel 不识别部分邮箱域名，如果你是，请到 Github 修改主邮箱） 导入 Github 项目\" 导入 Github 项目 选择需要导入的文件夹，默认为根文件夹\" 选择需要导入的文件夹，默认为根文件夹 完成导入后，配置你的预编译设置（由于本站是在本地使用 Hugo 编译好后 push 到 Github 上的所以这里选择 Other，然后勾选 OVERRIDE，不填写编译内容，表示不需要进行编译）如果你想要 Vercel 代替你编译，可以在这里选择相应的配置。 编译选项\" 编译选项 待你完成编译配置后，等待 Vercel 完成编译和部署，你就可以得到一个可以访问的网站了，当然域名是一个二级域名。接下来我们配置自定义域名，首先点击你的项目，进入 设置 \u003e 域名。然后添加你的域名，一开始你添加好的域名不会和图片上一样，会显示为正确配置，这是因为我们还需要到 Cloudflare 进行调整。 域名设置\" 域名设置 来到 Cloudflare 的 DNS 配置页面，首先删除此前指向 Github Pages 的两个解析，然后添加一个CNAME类型的解析，设置名字设置为www,内容填入cname.vercel-dns.com； 注： 关键一步是，这里一定要设置Proxy Status为DNS only，否则，你的网站依然会经过 Cloudflare 的代理来访问。 Cloudflare DNS 配置\" Cloudflare DNS 配置 这里我还添加一个 A 记录指向76.76.21.21，因为我默认将根域名跳转到www。这个根据实际情况决定，但同样记得设置设置Proxy Status为DNS only。 ","date":"2020-08-26","objectID":"/migrated_to_vercel/:4:0","tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/"},{"categories":["Web"],"content":"参考 [1] Introduction to Vercel ","date":"2020-08-26","objectID":"/migrated_to_vercel/:5:0","tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/"},{"categories":["Network"],"content":" 列举国内外常用的 DNS ","date":"2020-08-21","objectID":"/dns_list/:0:0","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"IPv4 ","date":"2020-08-21","objectID":"/dns_list/:1:0","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"国内 知名 DNS 服务 名称 IP 地址（首选） IP 地址（备选） 114 常规 DNS 114.114.114.114 114.114.115.115 114 拦截钓鱼病毒木马网站 114.114.114.119 114.114.115.119 114 拦截色情网站 114.114.114.110 114.114.115.110 阿里 AliDNS 223.5.5.5 223.6.6.6 百度 BaiduDNS 180.76.76.76 DNSPod DNS+ 119.29.29.29 182.254.116.116 CNNIC SDNS 1.2.4.8 210.2.4.8 oneDNS 117.50.11.11 52.80.66.66 DNS 派电信/移动/铁通 101.226.4.6 218.30.118.6 DNS 派联通 123.125.81.6 140.207.198.6 全国各地电信 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 安徽电信 DNS 61.132.163.68 202.102.213.68 北京电信 DNS 219.141.136.10 219.141.140.10 重庆电信 DNS 61.128.192.68 61.128.128.68 福建电信 DNS 218.85.152.99 218.85.157.99 甘肃电信 DNS 202.100.64.68 61.178.0.93 广东电信 DNS 202.96.128.86 202.96.128.166 202.96.134.33 202.96.128.68 广西电信 DNS 202.103.225.68 202.103.224.68 贵州电信 DNS 202.98.192.67 202.98.198.167 河南电信 DNS 222.88.88.88 222.85.85.85 黑龙江电信 219.147.198.230 219.147.198.242 湖北电信 DNS 202.103.24.68 202.103.0.68 湖南电信 DNS 222.246.129.80 59.51.78.211 江苏电信 DNS 218.2.2.2 218.4.4.4 61.147.37.1 218.2.135.1 江西电信 DNS 202.101.224.69 202.101.226.68 内蒙古电信 219.148.162.31 222.74.39.50 山东电信 DNS 219.146.1.66 219.147.1.66 陕西电信 DNS 218.30.19.40 61.134.1.4 上海电信 DNS 202.96.209.133 116.228.111.118 202.96.209.5 180.168.255.118 四川电信 DNS 61.139.2.69 218.6.200.139 天津电信 DNS 219.150.32.132 219.146.0.132 云南电信 DNS 222.172.200.68 61.166.150.123 浙江电信 DNS 202.101.172.35 61.153.177.196 61.153.81.75 60.191.244.5 全国各地联通 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 北京联通 DNS 123.123.123.123 123.123.123.124 202.106.0.20 202.106.195.68 重庆联通 DNS 221.5.203.98 221.7.92.98 广东联通 DNS 210.21.196.6 221.5.88.88 河北联通 DNS 202.99.160.68 202.99.166.4 河南联通 DNS 202.102.224.68 202.102.227.68 黑龙江联通 202.97.224.69 202.97.224.68 吉林联通 DNS 202.98.0.68 202.98.5.68 江苏联通 DNS 221.6.4.66 221.6.4.67 内蒙古联通 202.99.224.68 202.99.224.8 山东联通 DNS 202.102.128.68 202.102.152.3 202.102.134.68 202.102.154.3 山西联通 DNS 202.99.192.66 202.99.192.68 陕西联通 DNS 221.11.1.67 221.11.1.68 上海联通 DNS 210.22.70.3 210.22.84.3 四川联通 DNS 119.6.6.6 124.161.87.155 天津联通 DNS 202.99.104.68 202.99.96.68 浙江联通 DNS 221.12.1.227 221.12.33.227 辽宁联通 DNS 202.96.69.38 202.96.64.68 全国各地移动 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 江苏移动 DNS 221.131.143.69 112.4.0.55 安徽移动 DNS 211.138.180.2 211.138.180.3 山东移动 DNS 218.201.96.130 211.137.191.26 ","date":"2020-08-21","objectID":"/dns_list/:1:1","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"香港地区 名称 IP 地址（首选） IP 地址（备选） 香港宽频 DNS 203.80.96.10 和记环球电讯 DNS 202.45.84.58 202.45.84.59 Pacific SuperNet DNS 202.14.67.4 202.14.67.14 ","date":"2020-08-21","objectID":"/dns_list/:1:2","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"台湾地区 名称 IP 地址（首选） IP 地址（备选） 中华电信 DNS 168.95.1.1 168.95.192.1 数位联合电信 DNS 139.175.252.16 139.175.55.244 台湾网路资讯 101.101.101.101 101.102.103.104 ","date":"2020-08-21","objectID":"/dns_list/:1:3","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"韩国 名称 IP 地址（首选） IP 地址（备选） KT olleh DNS 168.126.63.1 168.126.63.2 SK Broadband DNS 210.220.163.82 219.250.36.130 LG U+ DNS 164.124.101.2 203.248.252.2 164.124.107.9 203.248.242.2 ","date":"2020-08-21","objectID":"/dns_list/:1:4","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"美国 名称 IP 地址（首选） IP 地址（备选） Cloudflare DNS 1.1.1.1 1.0.0.1 Google DNS 8.8.8.8 8.8.4.4 IBM Quad9 9.9.9.9 149.112.112.112 DNS.SB 185.222.222.222 185.184.222.222 OpenDNS 208.67.222.222 208.67.220.220 V2EX DNS 199.91.73.222 178.79.131.110 HE Public DNS 74.82.42.42 66.220.18.42 ","date":"2020-08-21","objectID":"/dns_list/:1:5","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"其他地区 名称 IP 地址（首选） IP 地址（备选） 俄罗斯 Yandex Public DNS 77.88.8.8 77.88.8.1 俄罗斯 SafeDNS 195.46.39.39 195.46.39.40 德国 DNS.WATCH Public DNS 84.200.69.80 84.200.70.40 瑞士 xiala.net Public DNS 77.109.148.136 77.109.148.137 丹麦 UncensoredDNS 91.239.100.100 89.233.43.71 荷兰 Freenom World Public DNS 80.80.80.80 80.80.81.81 ","date":"2020-08-21","objectID":"/dns_list/:1:6","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"IPv6 ","date":"2020-08-21","objectID":"/dns_list/:2:0","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"国内 名称 IP 地址（首选） IP 地址（备选） 百度 2400:da00::6666 阿里 2400:3200::1 2400:3200:baba::1 CNNIC 2001:dc7:1000::1 下一代互联网北京研究中心 240C::6666 240C::6644 高校 名称 IP 地址（首选） IP 地址（备选） 北京邮电大学 2001:da8:202:10::36 2001:da8:202:10::37 上海交通大学 2001:da8:8000:1:202:120:2:100 2001:da8:8000:1:202:120:2:101 中科院网络信息中心 2001:cc0:2fff:1::6666 北京交通大学 2001:da8:205:2060::188 清华大学 2001:da8:ff:305:20c:29ff:fe1f:a92a 清华大学 TUNA 协会 2001:da8::666 北京科技大学 2001:da8:208:10::6 ","date":"2020-08-21","objectID":"/dns_list/:2:1","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"台湾地区 名称 IP 地址（首选） IP 地址（备选） 中华电信 2001:b000:168::1 2001:b000:168::2 台湾网路资讯 2001:de4::101 2001:de4::102 ","date":"2020-08-21","objectID":"/dns_list/:2:2","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"美国 名称 IP 地址（首选） IP 地址（备选） GOOGLE 2001:4860:4860::8888 2001:4860:4860::8844 CloudFlare DNS 2606:4700:4700::1111 2606:4700:4700::1001 IBM 2620:fe::fe 2620:fe::9 Cisco OpenDNS 2620:0:ccc::2 2620:0:ccd::2 HE Public DNS 2001:470:20::2 2001:470:0:9d::2 Verisign Public DNS 2620:74:1b::1:1 2620:74:1c::2:2 Neustar Recursive DNS 2610:a1:1018::1 2610:a1:1019::1 ","date":"2020-08-21","objectID":"/dns_list/:2:3","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"其他地区 名称 IP 地址（首选） IP 地址（备选） 俄罗斯 Yandex Public DNS 2a02:6b8::feed:0ff 2a02:6b8:0:1::feed:0ff 德国 DNS.WATCH Public DNS 2001:1608:10:25::1c04:b12f 2001:1608:10:25::9249:d69b 瑞士 xiala.net Public DNS 2001:1620:2078:136:: 2001:1620:2078:137:: 丹麦 UncensoredDNS 2001:67c:28a4:: 2a01:3a0:53:53:: ","date":"2020-08-21","objectID":"/dns_list/:2:4","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"参考 [1] 全球免费公共 dns 解析服务器 ip 地址列表推荐 (解决无法上网/加速/防劫持) [2] 公共 dns 服务器 ip 地址 ","date":"2020-08-21","objectID":"/dns_list/:3:0","tags":["DNS"],"title":"DNS 列表","uri":"/dns_list/"},{"categories":["Network"],"content":"网络瑞士军刀 —— NetCat\" 网络瑞士军刀 —— NetCat ","date":"2020-08-19","objectID":"/netcat/:0:0","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"什么是 NetCat 简单来说，NetCat (nc) 是一个命令行工具，能够让你很方便、很灵活地操纵 传输层协议（TCP ＆ UDP） nc 可以在两台设备上面相互交互，即侦听模式/传输模式 nc 包含以下主要功能： Telnet 功能 获取 banner 信息 传输文本信息 传输文件 / 目录 加密传输文件，默认不加密 远程控制 加密所有流量 流媒体服务器 远程克隆硬盘 ","date":"2020-08-19","objectID":"/netcat/:1:0","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"使用 NetCat 一般来说，nc 的命令行包括如下几个部分： nc 命令选项 主机 端口 ","date":"2020-08-19","objectID":"/netcat/:2:0","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"命令选项 本文内容基于 OpenBSD 社区的变种（也叫 OpenBSD netcat，部分命令与原版有差异。 ） 下面列举了一些常用选项，更多选项参见 OpenBSD manual page 选项 是否有 “选项值” 说明 -h NO 输出 nc 的帮助 -v NO 在网络通讯时，显示详细的输出信息 -n NO 对命令行中的主机，不进行域名解析，如果主机是 IP 地址，需要用该选项 -p YES 指定端口号 -l NO 开启监听模式，nc 作为服务端，如不加，nc 默认作为客户端 -u NO 使用 UDP 协，如不加该选项，默认是 TCP 协议 -w YES 设置连接的超时间隔（N 秒） -q YES 让 nc 延时（N 秒）再退出 -z NO 开启 zero-I/O 模式，该选项仅用于端口扫描 -k NO 配合 -l 选项使用，可以重复接受客户端连接 -X YES 指定代理的类型 -x YES 以 IP:port 的格式指定代理 -d NO 后台模式 ","date":"2020-08-19","objectID":"/netcat/:2:1","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"主机 这部分可以没有，可以以 IP 地址 形式表示，也可以以 域名 形式表示。 ","date":"2020-08-19","objectID":"/netcat/:2:2","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"端口 这部分可以没有，可以是单个端口，可以是端口范围。 ","date":"2020-08-19","objectID":"/netcat/:2:3","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"常用使用场景示例 ","date":"2020-08-19","objectID":"/netcat/:3:0","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"测试某个远程主机的监听端口是否可达 经常有这种需求，要判断某个主机的监听端口是否能连上。导致监听端口无法连接，通常有两种原因： 监听端口没开启 监听端口虽然开启，但是被防火墙阻拦了 对第 1 个原因，（如果你能在该主机上运行命令）可以直接用 netstat 这个命令查看监听端口是否开启；但对于第 2 个原因，netstat 就用不上了，这时候就可以用 nc 来帮你搞定。 用如下命令可以测试某个 IP 地址上的某个监听端口是否开启: nc -nv ip port 注：　默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加 -w 选项，设置一个比较小的超时值。在下面的例子中，超时值设为 3 秒。 nc -nv -w 3 ip port ","date":"2020-08-19","objectID":"/netcat/:3:1","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"判断防火墙是否允许 or 禁止某个端口 假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何验证自己的配置生效？ 为了叙述方便，设想如下场景： 有两台主机 ——主机 C 充当客户端，主机 S 充当服务端。 然后要判断主机 S 上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。 在主机 S 上运行 nc，让它在 8080 端口，命令如下： nc -lv -p 8080 然后在 “主机 C” 上运行 nc，测试 “主机 S” 上的 8080 端口是否可达 注：　在默认情况下，nc 开启 listen 模式充当服务端，在接受第一次客户端连接之后，就会把监听端口关闭。如果你想要让 nc 始终监听模式，使之能重复接受客户端发起的连接，可以追加 -k 选项。 ","date":"2020-08-19","objectID":"/netcat/:3:2","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"端口扫描 下面这个命令，用来扫描的端口范围从 1 到 1024 nc -znv ip 1-1024 选项 -z 是指开启 zero-I/O 模式。该模式 nc 只判断某个监听端口是否能连上，连上后不与对端进行数据通讯。 **注：**端口扫描的时候，-v 选项会把成功/失败的结果统统打印出来。通常关注的都是 “扫描成功” 的那些端口。因此，可以用可以配合使用 grep 过滤一下，只打印扫出来的端口 nc -znv ip 1-1024 2\u003e\u00261 | grep succeeded 此外，由于 -v 选项产生的输出位于 stderr，上述命令中的 2\u003e\u00261 用来把 stderr 合并到 stdout。 另： nc 默认超时较大，导致扫描速度较慢。建议根据网络情况合理设置超时值，加快扫描速度。 ","date":"2020-08-19","objectID":"/netcat/:3:3","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"探测服务器类型和软件版本 如果某个服务器运行了 SSH 服务端，那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。 echo \"EXIT\" | nc -vq 5 -n ip 22 OR echo \"EXIT\" | nc -vq 5 domain 22 ","date":"2020-08-19","objectID":"/netcat/:3:4","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"端口转发 用 nc 进行端口转发，需要运行两个 nc 进程，一个充当服务端，另一个是客户端，然后用管道让把两个进程的标准输入输出``交叉配对。所谓的交叉配对就是——每一个 nc 进程的标准输出都对接到另一个 nc 进程的标准输入。如此一来，就可以完美地建立双向通讯。 步骤 1：创建命名管道 用下面这个简单的命令创建一个 “命名管道”，其名称叫做 nc_pipe mkfifo nc_pipe 步骤 2：同时启动两个 nc nc -l -p 1234 \u003c nc_pipe | nc 127.0.0.1 5678 \u003e nc_pipe 运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。 ","date":"2020-08-19","objectID":"/netcat/:3:5","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"传输文件 为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2 先在接收端 B 主机运行如下命令 nc -l -p port \u003e file2 然后在发送端 A 主机运行如下命令 nc ip port \u003c file1 两者端口号要相同 ","date":"2020-08-19","objectID":"/netcat/:3:6","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"远程备份整个磁盘 假设你要把 A 主机 /dev/sda 磁盘的原始数据整个复制到 B 主机的 /dev/sdb 磁盘。 先在接收端（B 主机）运行如下命令 nc -lp port | dd of=/dev/sdb 然后在发送端 A 主机运行如下命令 dd if=/dev/sda | nc ip port ","date":"2020-08-19","objectID":"/netcat/:3:7","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"远程控制 将 A 主机的 bash 发给 B 主机 A: nc -lp port -c bash B: nc ip port ","date":"2020-08-19","objectID":"/netcat/:3:8","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"流媒体服务 A: cat test.mp4 | nc -lp port B: nc -nv ip port | mplayer -vo x11 -cache 4000 A 让 test.MP4 这个文件成为流的形式发送到 B，B 用 mplayer 播放，接收多少播放多少，指定缓存 4000bytes。 ","date":"2020-08-19","objectID":"/netcat/:3:9","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"信息收集 收集目标机上的进程信息 nc -l -p port \u003e ps.txt 将远程发送过来的内容保存在本地 Ps aux |nc -nv ip port -q 1 标准输入完成后 delay 一秒钟，会发送到侦听端 ","date":"2020-08-19","objectID":"/netcat/:3:10","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":"参考 [1] netcat manual page [2] 扫盲 netcat（网猫）的 N 种用法 —— 从 “网络诊断” 到 “系统入侵” [3] NetCat 使用指南 ","date":"2020-08-19","objectID":"/netcat/:4:0","tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/"},{"categories":["Network"],"content":" 理解 HTTP 协议，对称和非对称加密，了解 HTTPS 协议的工作原理 注：本文系全文转载，原文信息如下： 作者：猫尾博客 链接：https://cattail.me/tech/2015/11/30/how-https-works.html 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 读完本文，你能明白 什么是 HTTPS，TLS (SSL)，TLS 和 HTTPS 是什么关系 什么是证书和数字签名，它们是如何传递信任的 HTTPS 有什么样的功能，它是如何实现这样的功能的 ","date":"2020-08-16","objectID":"/how_https_works/:0:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"简介 HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。本文着重描述 TLS 协议的 1.2 版本 下图描述了在 TCP/IP 协议栈中 TLS (各子协议）和 HTTP 的关系 Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS\" Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS 其中 Handshake protocol，Change Ciper Spec protocol 和 Alert protocol 组成了 SSL Handshaking Protocols。 HTTPS 和 HTTP 协议相比提供了: 数据完整性：内容传输经过完整性校验 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥 身份认证：第三方无法伪造服务端（客户端）身份 其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。 ","date":"2020-08-16","objectID":"/how_https_works/:1:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"总览 使用 RSA 算法的 SSL 握手过程是这样的: Source: Keyless SSL: The Nitty Gritty Technical Details\" Source: Keyless SSL: The Nitty Gritty Technical Details [明文] 客户端发送随机数 client_random 和支持的加密方式列表 [明文] 服务器返回随机数 server_random ，选择的加密方式和服务器证书链 [RSA] 客户端验证服务器证书，使用证书中的公钥加密 premaster secret 发送给服务端 服务端使用私钥解密 premaster secret 两端分别通过 client_random，server_random 和 premaster secret 生成 master secret，用于对称加密后续通信内容 ","date":"2020-08-16","objectID":"/how_https_works/:2:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"证书（Digital certificate） 那么什么是证书呢？ 证书信息\" 证书信息 ","date":"2020-08-16","objectID":"/how_https_works/:2:1","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"证书中包含了以下信息 证书信息：过期时间和序列号 所有者信息：姓名等 所有者公钥 为什么服务端要发送证书给客户端? 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。 ","date":"2020-08-16","objectID":"/how_https_works/:2:2","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"客户端为什么要验证接收到的证书 中间人攻击 客户端 \u003c------------ 攻击者 \u003c------------ 服务端 伪造证书 拦截请求 ","date":"2020-08-16","objectID":"/how_https_works/:2:3","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"客户端如何验证接收到的证书 为了回答这个问题，需要引入数字签名 (Digital Signature)。 +---------------------+ | A digital signature | |(not to be confused | |with a digital | |certificate) | +---------+ +--------+ | is a mathematical |---- 哈希 ---\u003e| 消息摘要 |--- 私钥加密 ---\u003e| 数字签名 | |technique used | +---------+ +--------+ |to validate the | |authenticity and | |integrity of a | |message, software | |or digital document. | +---------------------+ 将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。 假设消息传递在 Bob，Susan 和 Pat 三人之间发生。Susan 将消息连同数字签名一起发送给 Bob，Bob 接收到消息后，可以这样验证接收到的消息就是 Susan 发送的 +---------------------+ | A digital signature | |(not to be confused | |with a digital | |certificate) | +---------+ | is a mathematical |---- 哈希 ---\u003e| 消息摘要 | |technique used | +---------+ |to validate the | | |authenticity and | | |integrity of a | | |message, software | 对 |or digital document. | 比 +---------------------+ | | | +---------+ +----------+ | 数字签名 |--- 公钥解密 ---\u003e| 消息摘要 | +---------+ +----------+ 当然，这个前提是 Bob 知道 Susan 的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Bob。 此时就引入了证书颁发机构（Certificate Authority，简称 CA），CA 数量并不多，Bob 客户端内置了所有受信任 CA 的证书。CA 对 Susan 的公钥（和其他信息）数字签名后生成证书。 Susan 将证书发送给 Bob 后，Bob 通过 CA 证书的公钥验证证书签名。 Bob 信任 CA，CA 信任 Susan 使得 Bob 信任 Susan，信任链（Chain Of Trust）就是这样形成的。 事实上，Bob 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。 ","date":"2020-08-16","objectID":"/how_https_works/:2:4","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"TLS 协议 TLS 协议包括 TLS Record Protocol 和 TLS Handshake Protocol。总览中的流程图仅涉及到 TLS Handshake Protocol。 ","date":"2020-08-16","objectID":"/how_https_works/:3:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"TLS Record Protocol 在 TLS 协议中，有四种子协议运行于 Record protocol 之上 Handshake protocol Alert protocol Change cipher spec protocol Application data protocol Record protocol 起到了这样的作用 在发送端：将数据（Record）分段，压缩，增加 MAC (Message Authentication Code) 和加密 在接收端：将数据（Record）解密，验证 MAC，解压并重组 值得一提的是，Record protocol 提供了数据完整性和隐私性保证，但 Record 类型（type）和长度（length）是公开传输的 Record Protocol 有三个连接状态 (Connection State)，连接状态定义了压缩，加密和 MAC 算法。所有的 Record 都是被当前状态（Current State）确定的算法处理的。 TLS Handshake Protocol 和 Change Ciper Spec Protocol 会导致 Record Protocol 状态切换。 empty state -------------------\u003e pending state ------------------\u003e current state Handshake Protocol Change Cipher Spec 初始当前状态（Current State）没有指定加密，压缩和 MAC 算法，因而在完成 TLS Handshaking Protocols 一系列动作之前，客户端和服务端的数据都是明文传输的；当 TLS 完成握手过程后，客户端和服务端确定了加密，压缩和 MAC 算法及其参数，数据（Record）会通过指定算法处理。 其中，Record 首先被加密，然后添加 MAC（message authentication code）以保证数据完整性。 ","date":"2020-08-16","objectID":"/how_https_works/:3:1","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"TLS Handshaking Protocols Handshakeing protocols 包括 Alert Protocol，Change Ciper Spec Protocol 和 Handshake protocol。本文不会详细介绍 Alert Protocol 和 Change Ciper Spec Protocol。 使用 RSA 算法的握手过程是这样的（已在总览中提到） Source: Keyless SSL: The Nitty Gritty Technical Details\" Source: Keyless SSL: The Nitty Gritty Technical Details 客户端和服务端在握手 hello 消息中明文交换了 client_random 和 server_random ，使用 RSA 公钥加密传输 premaster secret ，最后通过算法，客户端和服务端分别计算 master secret。其中，不直接使用 premaster secret 的原因是：保证 secret 的随机性不受任意一方的影响。 除了使用 RSA 算法在公共信道交换密钥，还可以通过 Diffie–Hellman 算法。Diffie–Hellman 算法的原理是这样的 By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons\" By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons 使用 Diffie–Hellman 算法交换 premaster secret 的流程 Source: Keyless SSL: The Nitty Gritty Technical Details\" Source: Keyless SSL: The Nitty Gritty Technical Details ","date":"2020-08-16","objectID":"/how_https_works/:3:2","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"小结 TLS Handshaking Protocols 协商了 TLS Record Protocol 使用的算法和所需参数，并验证了服务端身份； TLS Record Protocol 在协商后保证应用层数据的完整性和隐私性。 TLS Handshaking Protocol 的核心是在公开信道上传递 premaster secret。 ","date":"2020-08-16","objectID":"/how_https_works/:4:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"Q\u0026A ","date":"2020-08-16","objectID":"/how_https_works/:5:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"为什么传输内容不直接使用非对称加密？ 因为性能限制。 ","date":"2020-08-16","objectID":"/how_https_works/:5:1","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"HTTPS 能保证正常连接？ 不能。 There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. 攻击者甚至可以直接丢弃双方的数据包 ","date":"2020-08-16","objectID":"/how_https_works/:5:2","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"服务端如何验证客户端身份？ 通过 Client Certificate This message conveys the client’s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite’s key exchange algorithm, and any negotiated extensions. ","date":"2020-08-16","objectID":"/how_https_works/:5:3","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"Alert protocol 有什么作用？ Closure Alerts：防止 Truncation Attack In a truncation attack, an attacker inserts into a message a TCP code indicating the message has finished, thus preventing the recipient picking up the rest of the message. To prevent this, SSL from version v3 onward has a closing handshake, so the recipient knows the message has not ended until this has been performed. Error Alerts：错误处理 ","date":"2020-08-16","objectID":"/how_https_works/:5:4","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"master secret 是如何计算的 master_secret = PRF (pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47]; ","date":"2020-08-16","objectID":"/how_https_works/:5:5","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"加密，压缩和 MAC 算法参数是如何计算的 Handshaking Protocols 使得客户端和服务端交换了三个参数：client_random，server_random 和 master_secret，通过以下算法生成算法所需要的参数 To generate the key material, compute key_block = PRF (SecurityParameters.master_secret, \"key expansion\", SecurityParameters.`server_random` + SecurityParameters.`client_random`); until enough output has been generated. Then, the key_block is partitioned as follows: client_write_MAC_key [SecurityParameters.mac_key_length] server_write_MAC_key [SecurityParameters.mac_key_length] client_write_key [SecurityParameters.enc_key_length] server_write_key [SecurityParameters.enc_key_length] client_write_IV [SecurityParameters.fixed_iv_length] server_write_IV [SecurityParameters.fixed_iv_length] The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key 使用 Diffie-Hellman 算法的 TLS 握手细节 Source: https://cipherstuff.wordpress.com/\" Source: https://cipherstuff.wordpress.com/ ","date":"2020-08-16","objectID":"/how_https_works/:5:6","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"拓展阅读 Keyless Let’s Encrypt Session resume 证书 Revoke ","date":"2020-08-16","objectID":"/how_https_works/:6:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Network"],"content":"参考 [1] TLS1.2 规范 [2] PKI 规范 [3] 证书和数字签名 [4] TLS Handshake ","date":"2020-08-16","objectID":"/how_https_works/:7:0","tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/"},{"categories":["Web"],"content":" 如何在互联网上高效地找到自己想要的东西？ 搜索引擎方便了我们搜索资料，但是由于各种垃圾内容、网站地出现，实际上，搜索过程往往是十分低效的（特别是使用中文搜索）。因此，值得学习一些提升搜索效率必要的小技巧。 废话不多说，直接分类讲解： ","date":"2020-08-14","objectID":"/how_to_search/:0:0","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"搜索语法 首先总结一下常用的语法表达式： operator description “phrase” 结果必须包含 “phrase” - phrase 结果排除 phrase A AND B A 和 B 必须同时包含 A OR B 必须包括 A 和 B 之一（或两者） site:example.com 在网站中搜索 filetype:jpg 结果必须包含类型 .jpg ","date":"2020-08-14","objectID":"/how_to_search/:1:0","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"实例展示 ","date":"2020-08-14","objectID":"/how_to_search/:2:0","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"网页 查找网站内的特定页面（例如：本网站上的 Trick 标签） site:www.techkoala.top Trick 查找必须在标题文本中包含短语的特定页面 allintitle:\"Github\" site:techkoala.com 查找类似网站（仅谷歌搜索） related:techkoala.com 您可以将运算符链接在一起 （例如：在 Url 中查找具有安全性或错误赏金） inurl:security OR inurl:bug-bounty OR site:hackerone.com) + \"techkoala\" 您可以限制为某些顶级域（例如：教师列表） site:.edu filetype:xls inurl:\"email.xls\" ","date":"2020-08-14","objectID":"/how_to_search/:2:1","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"Email 查找 Gmail 帐户 username \"@gmail.com\" 查找工作帐户（您需要先找到他们的域） username \"@techkoala.top\" 模糊搜索的情况下，可以尝试猜测电子邮件的格式 \"username\" \"@\" \".com\" 在网站上查找电子邮件 site:gumroad.com intext:\"@gumroad.com\" 在网页上查找您访问的每封电子邮件，适用于每个网站，将其注入 Chrome 开发工具 var elems = document.body.getElementsByTagName (\"*\"); var re = new RegExp (\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\"); for (var i = 0; i \u003c elems.length; i++) { if (re.test (elems [i].innerHTML)) { console.log (elems [i].innerHTML); } } 这将记录找到的每封电子邮件，而无需扫描整个页面。 ","date":"2020-08-14","objectID":"/how_to_search/:2:2","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"文件 查找电子表格 filetype:csv OR filetype:xlsx OR filetype:xls OR filetype:xltx OR filetype:xlt OR inurl:airtable.com/universe/ 查找谷歌文档和谷歌表格 site:docs.google.com \"techkoala\" ","date":"2020-08-14","objectID":"/how_to_search/:2:3","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"SEO 在锚文本中查找具有特定关键字的网站 inanchor:\"cyber security\" 研究标题中包含特定关键字的博客帖子 inposttitle:\"diy slime\" 查找反向链接 (例如：链接到特定博客帖子的其他网站)。注意：链接运算符 link 现在已弃用 intext:intercom.com/intercom-api-reference/reference 使用通配符运算符查找关键字排列 * design tools 使用给定的 widget 查找公司 intext:\"Powered by Intercom\" -site:intercom.com 待更新… ","date":"2020-08-14","objectID":"/how_to_search/:2:4","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":"参考 [1] dorking (how to find anything on the Internet) [2] Google Search Operators: The Complete List (42 Advanced Operators) ","date":"2020-08-14","objectID":"/how_to_search/:3:0","tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/"},{"categories":["Web"],"content":" 搭建自己的在线 EPUB 阅读器 ","date":"2020-08-12","objectID":"/reader/:0:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"什么是 Netlify 引用 Netlify 官网的介绍： Netlify is a unified platform that automates your code to create high-performant, easily maintainable sites and web apps. 也就是说，Netlify 是一个提供静态网站托管的服务。它提供 CI 服务，能够将托管在 GitHub，GitLab 等网站上代码生成静态网站进行展示。类似于 Github Pages，不过功能更加丰富。 ","date":"2020-08-12","objectID":"/reader/:1:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"Koodo Reader Koodo Reader 是一个基于 React 和 Electron 开发的 Epub 阅读器。 Koodo Reader 首页\" Koodo Reader 首页 提供以下功能： 📝 强大笔记和翻译功能，学习事半功倍 🚩 使用书架来为你的图书分类 🌎 支持 Windows ， MacOS 和 网页版 🖥 绑定 OneDrive， Google Drive， Dropbox 等网盘，实现数据的多端同步 💻 您所有的数据都支持导入导出 更多详情请点击 Koodo Reader 官网 查看。 ","date":"2020-08-12","objectID":"/reader/:2:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"搭建 首先进入 Netlify 官网，点击注册，这里我选择直接使用 Github 登录，当然，你也可以选择其他方式。 Netlify 注册\" Netlify 注册 注册登陆后，进入首页，点击右上角的 New Site from Git ，创建一个新的站点。 创建新站点\" 创建新站点 接下来，点击下方的 Github 进行授权，这里会弹出一个新的窗口，让你授权 Netlify 访问你的 Github 账户，完成授权后进去下一步。 使用Github 创建新站点\" 使用Github 创建新站点 这一步会让你选择你将用于生成站点的库，这里我已经提前 Fork troyeguo 的 Koodo Reader 库，所以直接选择即可。 选择相应的 Repo\" 选择相应的 Repo 接着，配置 Build 选项。在该项目的部署中，需要修改 Build name \u003e yarn build，Publish directory \u003e build/ ，其他保持默认即可。（如果配置其他项目，这里的参数可能不同，请参考具体项目的指导说明） 配置\" 配置 到这里，已经完成了整个部署工作，等待 Netlify 构建完成即刻。 配置\" 配置 Netlify 会给你默认分配一个二级域名用于访问，当然也支持自定义域名，这里我绑定了自己域名。除了在此处绑定外，还需要配置 DNS 等等，这个请自行完成。（由于搭建博客时，已经完成了相应设置，因此，我直接在 Cloudfalre 新建了一个 CNAME 指向 Netlify 给我的域名就好了） 配置\" 配置 大功告成，来这里看看书吧。 ","date":"2020-08-12","objectID":"/reader/:3:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"后续 如果需要对网站进行更新，只需要关注你的 Github Repo 即可。每次 commit 之后，Netlify 都会自动拉取更新并生成。 ","date":"2020-08-12","objectID":"/reader/:4:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Web"],"content":"参考 [1] koodo-reader ","date":"2020-08-12","objectID":"/reader/:5:0","tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/"},{"categories":["Network"],"content":" TCP、UDP 和 SCTP 的终极速度测试工具 ","date":"2020-08-07","objectID":"/iperf/:0:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"什么是 iPerf iPerf 是一个用于测量网络最大带宽的小工具。iPerf 可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和 UDP 特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。对于每个测试，它都会报告带宽，丢包和其他参数。 现在的版本也称 iPerf3，这是对 NLANR/DAST 开发的原始版本的重新设计。 注意：iPerf3 与此前版本的 iPerf 不兼容。 ","date":"2020-08-07","objectID":"/iperf/:1:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"安装 iPerf iPerf3 官方仅支持 CentOS Linux，FreeBSD 和 macOS，但实际上，官网提供了主流系统的预编译文件。（包括 Windows、Android、iOS、Ubuntu、Arch Linux 等） 类 UNIX 系统直接使用包管理进行安装即可，例如： $ sudo apt install iperf3 ","date":"2020-08-07","objectID":"/iperf/:2:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"使用 iPerf 首先，介绍服务端和客户端共有的参数： -p, --port n 服务器用于侦听和客户端连接的服务器端口，两者应该相同，默认值为 5201 --cport n 指定客户端端口 -f, --format 用于指定单位显示格式，支持 'k' = Kbits/sec 'K' = KBytes/sec 'm' = Mbits/sec 'M' = MBytes/sec，默认为自适应格式 -i, --interval n 设置测试信息报告之间的间隔时间（以秒为单位）。如果为零，则不打印任何定期报告。默认值为零。 -F, --file name 客户端：从文件读取并写入网络，而不是使用随机数据；服务器端：从网络读取并写入文件，而不是丢弃数据。 -A, --affinity 如果可以，设置 CPU 关联（仅限 Linux 和 FreeBSD）。 -B, --bind host 绑定到主机。对于客户端，这将设置出站接口。对于服务器，这将设置传入接口。这只适用于具有多个网络接口的多宿主主机。 -V, --verbose 提供更详细的输出 -J, --json 以 JSON 格式输出 --logfile file 输出到日志文件 --d, --debug 发出调试输出 -v, --version 输出版本信息 -h, --help 输出帮助信息 服务端特有参数： -s, --server 在服务器模式下运行 iPerf（一次只允许一个 iPerf 连接） -D, --daemon 将服务器作为守护进程在后台运行 -I, --pidfilefile 使用进程ID编写文件，这在作为守护进程运行时非常有用 客户端特有参数: -c, --client host 在客户端模式下运行 iPerf --sctp 使用 SCTP 而不是 TCP -u, --udp 使用 UDP 而不是 TCP -b, --bandwidth 将目标带宽设置为 nbits/sec（对于 UDP 默认为 1 Mbit/sec，对于 TCP 为无限制）。如果有多个流（-P 标志），则带宽限制将分别应用于每个流。您还可以在带宽说明符中添加一个 “/” 和一个数字。这称为 “突发模式”。 它会发送给定数量的数据包而不会暂停，即使该数据包暂时超过了指定的带宽限制 -t, --time 传输的时间（以秒为单位）。iPerf 通常通过在 t 时间内重复发送 len 长度的字节数组来工作。默认值为 10 秒 -n, --num 要传输的缓冲区数量。通常，iPerf 只会发送 10 秒。-n 选项覆盖此设置，并发送 len 长度字节数组 n 次，无论需要多长时间 -k, --blockcount 要传输的块（数据包）数 -l, --length 读取或写入的缓冲区的长度，iPerf 通过多次写入 len 个字节的数组来工作。TCP 的默认值为 128 KB，UDP 的默认值为 8 KB。 -P, --parallel 与服务器同时建立的连接数，默认值为 1 -R, --reverse 以反向模式运行（服务器发送，客户端接收） -w, --window 将套接字缓冲区大小设置为指定值。对于 TCP，这将设置 TCP 窗口大小（这将发送到服务器并在该侧使用） -M, --set-mss 尝试设置 TCP 最大段大小（MSS）。MSS 通常是 MTU-TCP/IP 标头的 40 个字节。对于以太网，MSS 为 1460 字节（1500 字节 MTU） -N, --no-delay 设置 “TCP no delay” 选项，禁用 Nagle 的算法。通常，仅对交互式应用程序（如 telnet）禁用此功能 -4, --version4 仅使用 IPv4. -6, --version4 仅使用 IPv6. -S, --tos 传出数据包的服务类型。(许多路由器会忽略TOS字段。）可以使用十六进制值（0x）作为前缀，使用八进制数（0）作为前缀，或者使用十进制来指定值。 例如，'0x10'十六进制='020'八进制='16'十进制。RFC 1349中指定的TOS编号为： IPTOS_LOWDELAY minimize delay 0x10 IPTOS_THROUGHPUT maximize throughput 0x08 IPTOS_RELIABILITY maximize reliability 0x04 IPTOS_LOWCOST minimize cost 0x02 -L, --flowlabel 设置 IPv6 流标签（当前仅在 Linux 上受支持） -Z, --zerocopy 使用 “零拷贝” 方法发送数据，如 sendfile（2），而不是通常的 write（2）。这样可以占用更少的 CPU -O, --omit 省略测试的前 n 秒，以跳过 TCP TCP 慢启动周期 -T, --title 为每个输出行添加此字符串前缀 -C, --linux-congestion 设置拥塞控制算法 (仅适用于 iPerf 3.1 的 Linux 和 FreeBSD)。 注意： 从客户端专有选项可以看出，iPerf 默认测试的是从客户端发送到服务端，相对于客户端来说，测试就是上行链路的带宽，对于一般参考意义更大的下行链路需要加上 -R 选项。 常用启用参数： 服务端 $ iperf3 -s -p 12345 -i 1 客户端 $ iperf3 -c 192.168.1.43 -p 12345 -i 1 -t 20 -w 100k iPerf 使用实例\" iPerf 使用实例 ","date":"2020-08-07","objectID":"/iperf/:3:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Network"],"content":"参考 [1] iPerf user docs [2] iPerf Github ","date":"2020-08-07","objectID":"/iperf/:4:0","tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/"},{"categories":["Software"],"content":" SCP 的继承者 ","date":"2020-08-06","objectID":"/sftp/:0:0","tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"什么是 SFTP 首先需要明确的是，SFTP（SSH File Transfer Protocol）不是运行在 SSH 上的 FTP，而是由 IETF（Internet Engineering Task Force）工作组设计的新协议，将其作为 SSH 2.0 版的扩展，提供安全的文件传输功能。因此，没有单独的 SFTP 端口，而是使用普通的 SSH 端口。协议本身不提供身份验证和安全性，而是期望底层协议提供。 与仅允许文件传输的 SCP 协议相比，SFTP 协议允许对远程文件进行一系列操作，这使其更像远程文件系统协议。SFTP 客户端还支持包括恢复中断的传输，目录列表和远程文件删除等功能。此外，上传的文件可以与它们的基本属性相关联，例如时间戳。相比普通 FTP 协议，这是一项优势。 尽管 SFTP 最常在 Unix 平台上实现，但 SFTP 在主流平台都可用。 有关 SFTP 详细草案参见 draft-ietf-secsh-filexfer-02 ","date":"2020-08-06","objectID":"/sftp/:1:0","tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"使用 SFTP sftp 选项 参数 ","date":"2020-08-06","objectID":"/sftp/:2:0","tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"选项 -B：指定传输文件时缓冲区的大小； -l：使用 ssh 协议版本 1； -b：指定批处理文件； -C：使用压缩； -o：指定 ssh 选项； -F：指定 ssh 配置文件； -R：指定一次可以容忍多少请求数； -v：升高日志等级。 ","date":"2020-08-06","objectID":"/sftp/:2:1","tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"参数 目标主机：指定 SFTP 服务器 IP 地址或者主机名。 ","date":"2020-08-06","objectID":"/sftp/:2:2","tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":"参考 [1] SSH File Transfer Protocol [2] SFTP Command ","date":"2020-08-06","objectID":"/sftp/:3:0","tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/"},{"categories":["Software"],"content":" SCP 的另一个绝佳替选 ","date":"2020-08-05","objectID":"/rsync/:0:0","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"什么是 rsync rsync (remote synchronize) 是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync 是类 Unix 系统下的数据镜像备份工具。它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。 rsync 中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync 可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。 rsync 默认监听 TCP 端口 873，以原生 rsync 传输协议或者透过远程 shell 如 RSH 或者 SSH 提供文件。SSH 模式下，rsync 客户端运行程序必须同时在本地和远程机器上安装。 ","date":"2020-08-05","objectID":"/rsync/:1:0","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"rsync 算法 此部分内容转载 RSYNC 的核心算法 rsync 的算法如下：（假设源文件名为 fileSrc，目的文件叫 fileDst） ","date":"2020-08-05","objectID":"/rsync/:2:0","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"分块 Checksum 算法 首先，我们会把 fileDst 的文件平均切分成若干个小块，比如每块 512 个字节，然后对每块计算两个 checksum，一个叫 rolling checksum，是弱 checksum，32 位的 checksum，其使用的是 Mark Adler 发明的 adler-32 算法，另一个是强 checksum，128 位的，以前用 md4，现在用 md5。为什么要这样？因为若干年前的硬件上跑 md4 的算法太慢了，所以，需要一个快算法来鉴别文件块的不同，但是弱的 adler-32 算法碰撞概率太高了，所以我们还要引入强的 checksum 算法以保证两文件块是相同的。也就是说，弱的 checksum 是用来区别不同，而强的是用来确认相同。 ","date":"2020-08-05","objectID":"/rsync/:2:1","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"传输算法 同步目标端会把 fileDst 的一个 checksum 列表传给同步源，这个列表里包括了三个东西，rolling checksum (32bits)，md5 checksume (128bits)，文件块编号。同步源机器拿到了这个列表后，会对 fileSrc 做同样的 checksum，然后和 fileDst 的 checksum 做对比，这样就知道哪些文件块改变了。 但是 如果我 fileSrc 这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和 fileDst 这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？ 如果这个 checksum 列表特别长，而两边相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？ ","date":"2020-08-05","objectID":"/rsync/:2:2","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"Checksum 查找算法 同步源端拿到 fileDst 的 checksum 数组后，会把这个数据存到一个 hash table 中，用 rolling checksum 做 hash，以便获得 O(1) 时间复杂度的查找性能。这个 hash table 是 16 bits 的，所以，hash table 的尺寸是 2 的 16 次方，对 rolling checksum 的 hash 会被散列到 0 到 $ 2^{16} – 1 $ 中的某个整数值。 ","date":"2020-08-05","objectID":"/rsync/:2:3","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"比对算法 取 fileSrc 的第一个文件块（我们假设的是 512 个长度），也就是从 fileSrc 的第 1 个字节到第 512 个字节，取出来后做 rolling checksum 计算。计算好的值到 hash 表中查询。 如果查到了，说明发现在 fileDst 中有潜在相同的文件块，于是就再比较 · 的 checksum，因为 rolling checksume 太弱了，可能发生碰撞。于是还要算 md5 的 128 bits 的 checksum，这样一来，我们就有 $2^{-(32+128)} = 2^{-160} $ 的概率发生碰撞，这小到可以忽略。如果 rolling checksum 和 md5 checksum 都相同，那就可以说明在 fileDst 中有相同的块，记下这一块在 fileDst 下的文件编号。 如果 fileSrc 的 rolling checksum 没有在 hash table 中找到，那就不用算 md5 checksum 了。表示这一块中有不同的信息。总之，只要 rolling checksum 或 md5 checksum 其中有一个在 fileDst 的 checksum hash 表中找不到匹配项，那么就会触发算法对 fileSrc 的 rolling 动作。于是，算法会住后 step 1 个字节，取 fileSrc 中字节 2-513 的文件块要做 checksum，然后继续第一步 – 这就是为什么叫 rolling checksum 。 这样，我们就可以找出 fileSrc 相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。 ","date":"2020-08-05","objectID":"/rsync/:2:4","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"Rolling Checksum 算法 rolling checksum 算法也叫 Rabin-Karp 算法，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它用来解决多模式串匹配问题。其最大的精髓是，当往后面 step 1 个字符的时候，不用全部重新计算所有的 checksum，也就是说，从 [0, 512] rolling 到 [1, 513] 时，不需要重新计算从 1 到 513 的 checksum，而是重用 [0，512] 的 checksum 直接算出来。 其公式可以表示为： hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0 其中的 b 是一个常数基数，在 Rabin-Karp 算法中，一般取值为 256。 于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了： hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1) + t[m] * b ^0 rsync 算法示意\" rsync 算法示意 最终，得到的数据组可以想象为 BT 协议下载 torrent ：一些文件块已下载（匹配上），其他的文件块还未下载（未匹配上）。然后，同步端将这些未匹配上的文件打上标号发送，目的端根据标号重组文件就完成了同步。 ","date":"2020-08-05","objectID":"/rsync/:3:0","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"使用 rsync rsync [OPTION]... SRC DEST rsync [OPTION]... SRC [USER@] host:DEST rsync [OPTION]... [USER@] HOST:SRC DEST rsync [OPTION]... [USER@] HOST::SRC DEST rsync [OPTION]... SRC [USER@] HOST::DEST rsync [OPTION]... rsync://[USER@] HOST [:PORT]/SRC [DEST] 对应于以上六种命令格式，rsync 有六种不同的工作模式： 拷贝本地文件。当 SRC 和 DES 路径信息都不包含有单个冒号 “:” 分隔符时就启动这种工作模式。如：rsync -a /data/backup 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 DST 路径地址包含单个冒号 “:” 分隔符时启动该模式。如：rsync -avz *.c foo:src 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将远程机器的内容拷贝到本地机器。当 SRC 地址路径包含单个冒号 “:” 分隔符时启动该模式。如：rsync -avz foo:src/bar/data 从远程 rsync 服务器中拷贝文件到本地机。当 SRC 路径信息包含 “::” 分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack 从本地机器拷贝文件到远程 rsync 服务器中。当 DST 路径信息包含 “::” 分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www 列出远程主机的文件列表。这类似于 rsync 传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www 可用选项如下： -v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -C, --cvs-exclude 使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 - rlptgoD。 -r, --recursive 对子目录以递归模式处理。 -R, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为～filename。可以使用 --suffix 选项来指定不同的备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。 -l, --links 保留软链结。 -L, --copy-links 想对待常规文件一样处理软链结。 -H, --hard-links 保留硬链结。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -D, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -S, --sparse 对稀疏文件进行特殊处理以节省 DST 的空间。 -T --temp-dir=DIR 在 DIR 中创建临时文件。 -n, --dry-run 现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是 700 字节。 -e, --rsh=command 指定使用 rsh、ssh 方式进行数据同步。 -P 等同于 --partial。 -z, --compress 对备份的文件在传输时进行压缩处理。 -h, --help 显示帮助信息。 --backup-dir 将备份文件 (如～filename) 存放在在目录下。 -suffix=SUFFIX 定义备份文件前缀。 --copy-unsafe-links 仅仅拷贝指向 SRC 路径目录树以外的链结。 --safe-links 忽略指向 SRC 路径目录树以外的链结。 --rsync-path=PATH 指定远程服务器上的 rsync 命令所在路径信息。 --existing 仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。 --delete 删除那些 DST 中 SRC 没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现 IO 错误也进行删除。 --max-delete=NUM 最多删除 NUM 个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组 id 匹配为用户名和组名。 --timeout=time ip 超时时间，单位为秒。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为 0。 --compare-dest=DIR 同样比较 DIR 中的文件来决定是否需要备份。 --progress 显示备份过程。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除 FILE 中指定模式的文件。 --include-from=FILE 不排除 FILE 指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的 rsyncd.conf 文件。 --port=PORT 指定其他的 rsync 服务端口。 --blocking-io 对远程 shell 使用阻塞 IO。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=formAT 指定日志文件格式。 --password-file=FILE 从 FILE 中得到密码。 --bwlimit=KBPS 限制 I/O 带宽，KBytes per second。 ","date":"2020-08-05","objectID":"/rsync/:4:0","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Software"],"content":"参考 [1] The rsync algorithm [2] RSYNC 的核心算法 [3] rsync wikipedia [4] rsync command ","date":"2020-08-05","objectID":"/rsync/:5:0","tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/"},{"categories":["Git"],"content":" 最常用的 Git Log 技巧令总结 ","date":"2020-08-01","objectID":"/git_log/:0:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"概览提交历史 $ git log —oneline 该命令帮助您以更清晰的方式查看提交。每个提交仅显示为一行，并且只有最少量的信息，比如提交哈希、提交消息。 ","date":"2020-08-01","objectID":"/git_log/:1:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"显示详细更改信息 $ git log -p 此命令会显示更新的详细更改信息，方便查阅。 ","date":"2020-08-01","objectID":"/git_log/:2:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"根据时间筛选 $ git log --after=\"2020-15-05\" $ git log --after=\"2020-15-05\" --before=\"2020-25-05\" $ git log --after=\"yesterday\" // 显示昨天的提交 $ git log --after=\"today\" // 显示今天的提交 $ git log --before=\"10 day ago\" // 显示最近十天的提交 $ git log --after=\"1 week ago\" // 显示上周以来的提交 $ git log --after=\"2 month ago\" // 显示近两个月的提交 上述命令将按给定的时间段过滤出提交。 例如，--after 将仅筛选给定时间段之后的提交，而 --before 将仅筛选给定时间段之前的提交。 ","date":"2020-08-01","objectID":"/git_log/:3:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"根据作者筛选 $ git log --author=\"techkoala\" 该命令会显示由 techkoala 提交的更改。当然，可以结合上面介绍的命令，进行更加精确的筛选，例如： $ git log --after=\"1 week ago\" --author=\"techkoala\" -p ","date":"2020-08-01","objectID":"/git_log/:4:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"根据 log 信息筛选 $ git log --grep=\"ISSUE-43560\" 需要注意的是，上述筛选字段区分大小写，如果需要不区分，请加上 -i 选项。 此外，还支持正则表达式： $ git log -i --grep=\"issue-43560\\|issue-89786\" ","date":"2020-08-01","objectID":"/git_log/:5:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"根据文件筛选 $ git log Git_Log.md 该命令显示针对特定文件的的提交历史。 当然，可以传入多个文件： $ git log Git_Log.md Github_Issue.md 同样的，结合别的命令可以做出更精确的筛选，例如： $ git log -i --grep=\"fix \" Git_Log.md Github_Issue.md ","date":"2020-08-01","objectID":"/git_log/:6:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"根据文件内容筛选 $ git log -S\"function login()\" 上述命令帮你在源代码中搜索已添加到提交历史记录中的特定字符串。同样的，加上 -i 可以不区分大小写。 ","date":"2020-08-01","objectID":"/git_log/:7:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"仅显示合并提交 $ git log --merges 该命令显示当前分支上合并的提交。 ","date":"2020-08-01","objectID":"/git_log/:8:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"显示不同分支间的区别 $ git log master..develop 该命令将显示所有来自 develop 但不在 master 分支的提交。 ","date":"2020-08-01","objectID":"/git_log/:9:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"自定义 log 信息格式 $ git log --pretty=format:\"%Cred%an - %ar%n %Cblue %h -%Cgreen %s %n\" Git 提供了用于自定义日志消息格式的选项，你可以查看自定义漂亮选项（custom pretty options ）以获得更多选项。 ","date":"2020-08-01","objectID":"/git_log/:10:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":["Git"],"content":"参考 [1] Ten Useful Git Log Tricks [2] Git 基础 - 查看提交历史 ","date":"2020-08-01","objectID":"/git_log/:11:0","tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/"},{"categories":null,"content":"Network Web: DigitalOcean Nginx Tool：Nginx Config 生成 cURL 命令转代码：支持将 curl 命令转换为各种代码 Turn Any Link Into Emoji：欢迎通过 http://💻💻💻🐨🐨🐨.🍕💩.ws 访问本站。 网站测速： BOCE 17CE 网络测速: CloudFlare Speed Test Speedtest by Ookla 测速网 IP\u0026DNS 测试： WHOER ipleak DnsLeakTest IPv6: IPv6 连接测试 IPv6 Test 国家 IPv6 发展检测平台 IPv6 发展监测平台目录服务 ","date":"2020-07-30","objectID":"/tools/:1:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Tools 在线格式转换工具 ","date":"2020-07-30","objectID":"/tools/:2:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Reading Epub 在线阅读 ","date":"2020-07-30","objectID":"/tools/:3:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Wireless Communication Sandesh Dhagle’s Resource Grid Tools：LTE 资源网格生成 ","date":"2020-07-30","objectID":"/tools/:4:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Linux Linux Command：Linux 命令搜索引擎命令 ","date":"2020-07-30","objectID":"/tools/:5:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Pics webp2jpg：图片格式转换 squoosh：谷歌图片压缩 sm.ms：图床 Favicon Generator：网站图标生成 isoflow：好看的拓扑图绘制 Full Emoji List ","date":"2020-07-30","objectID":"/tools/:6:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Security 文件安全在线检测： Virustotal 微步在线威胁情报社区 ","date":"2020-07-30","objectID":"/tools/:7:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"File Share TMP.LINK：文件上传分享 transfer.sh：命令行文件上传分享 Unicode Text Converter：Unicode 文本转换 ","date":"2020-07-30","objectID":"/tools/:8:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Temporary service 临时短信： Z-SMS： It233 Materialtools Freeonlinephone 临时邮箱： Yopmail 24mail ","date":"2020-07-30","objectID":"/tools/:9:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":null,"content":"Others 能不能好好说话？：网络缩写翻译 ","date":"2020-07-30","objectID":"/tools/:10:0","tags":null,"title":"工具","uri":"/tools/"},{"categories":["Algorithm"],"content":" 最常见的 SHA-2 算法是如何实现的？本文逐步为你讲解。 SHA-2 (Secure Hash Algorithm 2)，是最流行的哈希算法之一，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。 SHA-2 以安全和速度著称，在未生成密钥的情况下（例如挖掘比特币），像 SHA-2 这样的快速哈希算法通常占据上风。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:0:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"哈希函数（Hash Function） 如果，你还不清楚哈希是什么，可以参见我的另外一篇文章 简单来说，哈希函数的拥有如下三个重要特性： 哈希函数对数据进行确定性加扰。 无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。 无法从加扰数据中检索原始数据（单向函数）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:1:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"SHA-2 vs SHA-256 有人可能会困惑：欸？我平时看到的都是 SHA-128、SHA-256 等等，这个 SHA-2 又是什么？ SHA-2 是一种算法，一种关于如何哈希数据的广义思想。SHA-256 设置了定义 SHA-2 算法行为的附加常量。其中一个常量是输出大小，“256” 和 “512” 是指它们各自的输出摘要大小（以位为单位）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:2:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"逐步详解 SHA-256 接下来举例说明 SHA-256 如何工作: ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第一步：消息预处理 将 hello world 转换为二进制 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 尾部追加单独的 1 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 1 填充 0 直到数据为 512 的整数倍，再减去 64 位（在本例中剩下 448 位）： 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 在末尾附加新的 64 位，这 64 位是一个大端整数，用于表示原始二进制输入的长度。在本文的例子中，是 88，或者二进制，1011000。 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01011000 现在，得到了初始的输入值（通过对消息进行补位处理，最终的长度应该是 512 位的倍数）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:1","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第二步：初始化哈希值（h） 现在，初始化 8 个哈希值。这些是硬编码的常数，分别代表前 8 个素数（2、3、5、7、11、13、17、19）的平方根的小数部分的前 32 位： h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:2","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第三步：初始化圆常数(k) 与步骤 2 类似，初始化一些常量，一共有 64 个。每个值（0-63）是前 64 个素数（2-311）的立方根分数部分的前 32 位。 0x428a2f98 0x71374491 0xb5c0fbcf 0xe9b5dba5 0x3956c25b 0x59f111f1 0x923f82a4 0xab1c5ed5 0xd807aa98 0x12835b01 0x243185be 0x550c7dc3 0x72be5d74 0x80deb1fe 0x9bdc06a7 0xc19bf174 0xe49b69c1 0xefbe4786 0x0fc19dc6 0x240ca1cc 0x2de92c6f 0x4a7484aa 0x5cb0a9dc 0x76f988da 0x983e5152 0xa831c66d 0xb00327c8 0xbf597fc7 0xc6e00bf3 0xd5a79147 0x06ca6351 0x14292967 0x27b70a85 0x2e1b2138 0x4d2c6dfc 0x53380d13 0x650a7354 0x766a0abb 0x81c2c92e 0x92722c85 0xa2bfe8a1 0xa81a664b 0xc24b8b70 0xc76c51a3 0xd192e819 0xd6990624 0xf40e3585 0x106aa070 0x19a4c116 0x1e376c08 0x2748774c 0x34b0bcb5 0x391c0cb3 0x4ed8aa4a 0x5b9cca4f 0x682e6ff3 0x748f82ee 0x78a5636f 0x84c87814 0x8cc70208 0x90befffa 0xa4506ceb 0xbef9a3f7 0xc67178f2 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:3","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第四步：块循环 对输入的每 512 位分为一块，执行以下步骤： 注意 在本文的例子中，因为 “hello world” 太短了，所以只有一个块。在循环的每一次迭代中，都将对哈希值 h0-h7 进行变更，最终作为结果输出。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:4","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第五步：重组信息数组（w） 将步骤 1 中的输入数据重新排列到新数组中，其中每个条目都是一个 32 位字： 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 再加上 48 个初始化为零的字，这样就有了一个数组 w [0…63] 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 … … 00000000000000000000000000000000 00000000000000000000000000000000 使用以下算法修改数组末尾的零索引： For i from w[16…63]: s0 = (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 = (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10) w[i] = w[i-16] + s0 + w[i-7] + s1 以 w[16] 举例说明： w[1] rightrotate 7: 01101111001000000111011101101111 -\u003e 11011110110111100100000011101110 w[1] rightrotate 18: 01101111001000000111011101101111 -\u003e 00011101110110111101101111001000 w[1] rightshift 3: 01101111001000000111011101101111 -\u003e 00001101111001000000111011101101 s0 = 11011110110111100100000011101110 XOR 00011101110110111101101111001000 XOR 00001101111001000000111011101101 = 11001110111000011001010111001011 w[14] rightrotate 17: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 w[14] rightrotate19: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 w[14] rightshift 10: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 s1 = 00000000000000000000000000000000 XOR 00000000000000000000000000000000 XOR 00000000000000000000000000000000 = 00000000000000000000000000000000 w[16] = w[0] + s0 + w[9] + s1 = 01101000011001010110110001101100 11001110111000011001010111001011 00000000000000000000000000000000 00000000000000000000000000000000 = 00110111010001110000001000110111 // addition is calculated modulo $ 2^{32} $ 总的结果就是： 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 00110111010001110000001000110111 10000110110100001100000000110001 11010011101111010001000100001011 01111000001111110100011110000010 00101010100100000111110011101101 01001011001011110111110011001001 00110001111000011001010001011101 10001001001101100100100101100100 01111111011110100000011011011010 11000001011110011010100100111010 10111011111010001111011001010101 00001100000110101110001111100110 10110000111111100000110101111101 01011111011011100101010110010011 00000000100010011001101101010010 00000111111100011100101010010100 00111011010111111110010111010110 01101000011001010110001011100110 11001000010011100000101010011110 000001101010111110011011","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:5","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第六步：压缩 初始化变量 a，b，c，d，e，f，g，h，并将它们分别设置为等于当前的哈希值：h0，h1，h2，h3，h4，h5，h6，h7 进行压缩循环。 压缩循环将改变 a…h 的值。压缩循环如下： for i from 0 to 63: S1 = (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) ch = (e and f) xor ((not e) and g) temp1 = h + S1 + ch + k[i] + w[i] S0 = (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) maj = (a and b) xor (a and c) xor (b and c) temp2 := S0 + maj h = g g = f e = d + temp1 d = c c = b b = a a = temp1 + temp2 下面演示第一次迭代，所有加法都是以 $ 2^{32} $ 为模的： a = 0x6a09e667 = 01101010000010011110011001100111 b = 0xbb67ae85 = 10111011011001111010111010000101 c = 0x3c6ef372 = 00111100011011101111001101110010 d = 0xa54ff53a = 10100101010011111111010100111010 e = 0x510e527f = 01010001000011100101001001111111 f = 0x9b05688c = 10011011000001010110100010001100 g = 0x1f83d9ab = 00011111100000111101100110101011 h = 0x5be0cd19 = 01011011111000001100110100011001 e rightrotate 6: 01010001000011100101001001111111 -\u003e 11111101010001000011100101001001 e rightrotate 11: 01010001000011100101001001111111 -\u003e 01001111111010100010000111001010 e rightrotate 25: 01010001000011100101001001111111 -\u003e 10000111001010010011111110101000 S1 = 11111101010001000011100101001001 XOR 01001111111010100010000111001010 XOR 10000111001010010011111110101000 = 00110101100001110010011100101011 e and f: 01010001000011100101001001111111 \u0026 10011011000001010110100010001100 = 00010001000001000100000000001100 not e: 01010001000011100101001001111111 -\u003e 10101110111100011010110110000000 (not e) and g: 10101110111100011010110110000000 \u0026 00011111100000111101100110101011 = 00001110100000011000100110000000 ch = (e and f) xor ((not e) and g) = 00010001000001000100000000001100 XOR 00001110100000011000100110000000 = 00011111100001011100100110001100 // k[i] 是圆常数 // w[i] 信息数组 temp1 = h + S1 + ch + k[i] + w[i] = 01011011111000001100110100011001 + 00110101100001110010011100101011 + 00011111100001011100100110001100 + 1000010100010100010111110011000 + 01101000011001010110110001101100 = 01011011110111010101100111010100 a rightrotate 2: 01101010000010011110011001100111 -\u003e 11011010100000100111100110011001 a rightrotate 13: 01101010000010011110011001100111 -\u003e 00110011001110110101000001001111 a rightrotate 22: 01101010000010011110011001100111 -\u003e 00100111100110011001110110101000 S0 = 11011010100000100111100110011001 XOR 00110011001110110101000001001111 XOR 00100111100110011001110110101000 = 11001110001000001011010001111110 a and b: 01101010000010011110011001100111 \u0026 10111011011001111010111010000101 = 00101010000000011010011000000101 a and c: 01101010000010011110011001100111 \u0026 00111100011011101111001101110010 = 00101000000010001110001001100010 b and c: 10111011011001111010111010000101 \u0026 00111100011011101111001101110010 = 00111000011001101010001000000000 maj = (a and b) xor (a and c) xor (b and c) = 00101010000000011010011000000101 XOR 00101000000010001110001001100010 XOR 00111000011001101010001000000000 = 00111010011011111110011001100111 temp2 = S0 + maj = 11001110001000001011010001111110 + 00111010011011111110011001100111 = 00001000100100001001101011100101 h = 00011111100000111101100110101011 g = 10011011000001010110100010001100 f = 01010001000011100101001001111111 e = 10100101010011111111010100111010 + 01011011110111010101100111010100 = 00000001001011010100111100001110 d = 00111100011011101111001101110010 c = 10111011011001111010111010000101 b = 01101010000010011110011001100111 a = 01011011110111010101100111010100 + 00001000100100001001101011100101 = 01100100011011011111010010111001 整个计算会继续循环进行了 63 次，期间不断修改了变量 a-h 的值。最终结果为： a = 4F434152 = 001001111010000110100000101010010 b = D7E58F83 = 011010111111001011000111110000011 c = 68BF5F65 = 001101000101111110101111101100101 d = 352DB6C0 = 000110101001011011011011011000000 e = 73769D64 = 001110011011101101001110101100100 f = DF4E1862 = 011011111010011100001100001100010 g = 71051E01 = 001110001000001010001111000000001 h = 870F00D0 = 010000111000011110000000011010000 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:6","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第七步：修改最终值 压缩循环完成后，仍然处于在块循环中，通过向哈希值中添加它们各自的变量 a-h 来修改哈希值。同样的，所有的加法都是模 $ 2^{32} $。 h0 = h0 + a = 10111001010011010010011110111001 h1 = h1 + b = 10010011010011010011111000001000 h2 = h2 + c = 10100101001011100101001011010111 h3 = h3 + d = 11011010011111011010101111111010 h4 = h4 + e = 11000100100001001110111111100011 h5 = h5 + f = 01111010010100111000000011101110 h6 = h6 + g = 10010000100010001111011110101100 h7 = h7 + h = 11100010111011111100110111101001 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:7","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"第八步: 组成最终的哈希值 digest = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 = B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9 搞定！至此，本文非常详细地实现了 SHA-256 中的每一步 🙂。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:8","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"附录 SHA-2 的第 t 个加密循环\" SHA-2 的第 t 个加密循环 下面这段伪代码总结了上面执行的所有步骤： 几点说明 所有变量均为 32 位无符号整数，加法以 $ 2^{32} $ 为模 对于每一轮，在消息调度数组 w [i]，0≤i≤63 中有一个循环常数 k [i] 和一个条目。 压缩函数使用 8 个工作变量，a 到 h。 在此伪代码中表示常量时使用大端约定，并且当将消息块数据从字节解析到字时，例如，填充后的输入消息 “abc” 的第一个字是 0x61626380 Initialize hash values: (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19): h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 Initialize array of round constants: (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311): k[0..63] := 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 Pre-processing (Padding): begin with the original message of length L bits append a single '1' bit append K '0' bits, where K is the minimum number \u003e= 0 such that L + 1 + K + 64 is a multiple of 512 append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits Process the message in successive 512-bit chunks: break message into 512-bit chunks for each chunk create a 64-entry message schedule array w[0..63] of 32-bit words (The initial values in w[0..63] don't matter, so many implementations zero them here) copy chunk into first 16 words w[0..15] of the message schedule array Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array: for i from 16 to 63 s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10) w[i] := w[i-16] + s0 + w[i-7] + s1 Initialize working variables to current hash value: a := h0 b := h1 c := h2 d := h3 e := h4 f := h5 g := h6 h := h7 Compression function main loop: for i from 0 to 63 S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) ch := (e and f) xor ((not e) and g) temp1 := h + S1 + ch + k[i] + w[i] S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) maj := (a and b) xor (a and c) xor (b and c) temp2 := S0 + maj h := g g := f f := e e := d + temp1 d := c c := b b := a a := temp1 + temp2 Add the compressed chunk to the current hash value: h0 := h0 + a h1 := h1 + b h2 := h2 + c h3 := h3 + d h4 := h4 + e h5 := h5 + f h6 := h6 + g h7 := h7 + h Produce the final hash value (big-endian): digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:4:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":"参考 [1] How SHA-2 Works Step-By-Step (SHA-256) [2] SHA-2 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:5:0","tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/"},{"categories":["Algorithm"],"content":" 哈希函数入门介绍。 一点说明 本文中英文和二进制之间的相互转换并没有遵循任何模式，请读者不要纠结于这一点。当然，实际中，有很多方法用于将我们熟知的字符（例如中文、英语等）转换为二进制（十六进制），如果感兴趣，可以点击下面的参考中的内容 ","date":"2020-07-25","objectID":"/hash_functions/:0:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"哈希函数（Hash Function）用来做什么？ 哈希函数，又称散列函数，广泛应用于互联网的各处，包括但不限于安全地存储密码、查找重复记录、快速存储和检索数据等。例如，Qvault 应用使用哈希将主密码扩展为私人加密密钥。你还可以 点击这里 查看哈希函数用于何处。 ","date":"2020-07-25","objectID":"/hash_functions/:1:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"重要特性 哈希函数的拥有如下三个重要特性，这些特性可以说是最重要的特性： 哈希函数对数据进行确定性加扰。 无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。 无法从加扰数据中检索原始数据（单向函数）。 ","date":"2020-07-25","objectID":"/hash_functions/:2:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"确定性加扰 想象一下，如果随机扭动一个魔方，到最后会得到一些和开始时不一样的东西。但是，如果重新开始，并做完全相同的一系列动作，那么将能够反复得到完全相同的结果。尽管结果可能看起来是随机的，但它其实是严格按照一定的规则进行变幻地，这就是确定性加扰的含义。 确定性对于安全存储密码很重要。例如，假设我的密码是 iLoveBitcoin，我可以使用哈希函数对其进行加扰： iLoveBitcoin → “2f5sfsdfs5s1fsfsdf98ss4f84sfs6d5fs2d1fdf15” 现在，任何人看到加扰后的版本，他们都不会知道我的原始密码！这一点很重要，因为这意味着作为一个网站开发人员，我只需要存储我用户密码的哈希(加扰数据)就可以验证它们。当用户注册时，我将用户密码进行哈希运算然后将其存储在我的数据库中。当用户登录时，我只是对他们输入的内容再次进行哈希运算，并比较两个哈希值。因为给定的输入总是生成相同的哈希值，所以能够很方便地进行验证。 ","date":"2020-07-25","objectID":"/hash_functions/:2:1","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"输出定长 如果对单个单词进行哈希处理，则输出将具有一定的大小（对于 SHA-256，则为特定的哈希函数，大小为 256 位）。即便我对一本书进行哈希处理，输出同样将是相同的大小。 这是另一个重要的功能，因为它可以节省我们的计算时间。 一个典型的例子是使用哈希作为数据映射中的键。 数据映射是计算机科学中用来存储数据的一种简单结构。 数据映射\" 数据映射 当程序在映射中存储数据时，会为映射指定一个键和值。当程序想要访问该值时，它只要提供适当的键就能接收相应的值。数据映射很好，因为它们可以立即找到数据。计算机通过键可以立即找到对应的值，而不是花费数小时在数百万条记录中搜索。 因为键类似于地址，所以它们不能太大。如果我想将图书存储在数据映射中，我可以对图书的内容进行哈希，并使用该哈希作为键。 ","date":"2020-07-25","objectID":"/hash_functions/:2:2","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"哈希处理如何进行？ 接下来，以 LANEHASH 算法为例，简要讲解哈希处理是如何完成的。 首先，选取下面的数据进行哈希处理 iLoveBitcoin 将字母转换成二进制 iLoveBitcoin→ 100010100000101111 注意 在这一步中，我们通过各种预定的步骤来转换我们的原始数据。转换方式可以采用各种方式，但重要的是，每当我们使用 LANEHASH 时，都需要使用相同的步骤，以便我们的算法是确定性的。 将比特前四位从左移到右边 100010100000101111 → 101000001011111000 奇偶分离比特 101000001011111000 → 110011110 \u0026 000001100 分别转化为十进制数 110011110 → 414 000001100→ 12 两数相乘 414 *12 = 4968 乘积平方 4968 ^ 2 = 24681024 再次转换为二进制 24681024 →1011110001001101001000000 剥离右边的 9 个比特以得到 16 位比特 1011110001001101001000000 → 1011110001001101 转换回字母/数字 1011110001001101 → “8sj209dsns02k2” 正如你所看到的，如果在开始时使用相同的单词，则在结束时将始终得到相同的输出。然而，即使你改了一个字母，结果也会发生很大的变化。 ","date":"2020-07-25","objectID":"/hash_functions/:3:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"总结 哈希函数实际上就是按照特定的规则将数据进行一系列转换，最后得到一串键值用来代替/指代原始数据，但是需要注意的是，哈希函数需要满足确定性、定长性、不可逆性。 ","date":"2020-07-25","objectID":"/hash_functions/:4:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Algorithm"],"content":"参考 [1] (Very) Basic Intro to Hash Functions (SHA-256, MD5, etc) [2] Hash Function [3] ASCII [4] Unicode ","date":"2020-07-25","objectID":"/hash_functions/:5:0","tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/"},{"categories":["Software"],"content":" SCP 就是 SSH 协议的文件传输功能吗？ ","date":"2020-07-18","objectID":"/scp/:0:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"什么是 SCP SCP（Secure Copy Protocol，安全复制协议）允许我们在两台计算机之间复制文件（和目录）。 使用起来特别方便： $ scp local_file remote_host:/home 这将把本地文件 localfile 复制到远程主机的 /home 文件之下。 SCP 使用起来特别便利，因为他能工作在几乎所有的 Unix-like 的系统中，并且 Windows 下拥有许多客户端。但是仅仅复制文件并不是关键。SCP 真正的价值是对 计算机的身份进行验证 以及对 传输文件进行加密（也就是 S 代表的含义）。 使用前需要首先配置到远程主机的 SSH 连接权限。SCP 的验证提示和 SSH 看起很像，因为 SCP 跑在 SSH 的上层，仅仅把它作为文件数据的管道。事实上，SSH 负责处理所有安全相关的任务，SCP 只是将一些文件扔到 SSH 连接上。 维基百科上的条目讲述了 SCP 的历史，简而言之：在旧的 BSD 系统上曾经有一个叫 RCP 的工具，可以在电脑之间移动文件。在当时受信任的网络时代，每个人都是别人的朋友。后来人们意识到，也许并不是每个人在他们的网络上都是这么好的朋友。于是有人把 RCP 的实现复制到 OpenSSH 的前身上，然后简单地在 SSH 会话上运行它，以保护文件不被非好友发现。问题解决了！从此以后，它就留在了 OpenSSH 中。 ","date":"2020-07-18","objectID":"/scp/:1:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"SCP 工作原理 SCP 并不是一个标准协议，并没有一个 RFC 或者任何官方描述如何实现它。OpenSSH 实现是一个事实上的规范。此实现有两个部分：连接建立和之后的传输协议。 ","date":"2020-07-18","objectID":"/scp/:2:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"建立连接 实际上，这并不是真正的连接。因为它只是利用 SSH 执行命令后的 STDIN/STDOUT ，有点类似 Unix 管道。OpenSSH 中包含两个程序来完成:sshd 和 scp。sshd 是始终运行的服务器守护进程，接受新的 SSH 连接。SCP 是伪装成 SSH 的客户端程序，发送和接受文件。 当 SCP 运行时，他将开启一个新的 SSH 连接。在该连接上，它会在服务端执行另一个带有特殊标志的 SCP 程序。你可以认为是 ssh exec scp [flags]。主要的标志包含 -t（“to”）和 -f（“from”）用于代表接受和发送，而 -d 表示文件夹，-r 表示递归。 建立连接\" 建立连接 值得注意的是，SCP 协议是单向的，一端发送文件，另一端接收文件。在远程端 SCP 开始运行后，实际的 SCP 协议命令开始通过 STDIN 和 STDOUT 运行。 ","date":"2020-07-18","objectID":"/scp/:2:1","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"传输协议 现在，安全的 I/O 通道建立起来，并且已经有效地切换到 RCP 协议上。该协议是 顺序（一次一个操作）和 同步（每个命令执行完后才执行下一个命令）执行的。 命令格式大致为（不带括号或空格）：[command type][arguments]\\n [optional data] [command type] 通常是一个 ASCII 字符： ‘C’- 写入文件 ‘D’- 输入目录 ‘E’- 退出最后一个目录 ‘T’- 设置下一个文件或目录的创建 / 更新时间戳 [arguments] 是特定于命令的，如文件 / 目录名称、文件大小或时间戳。“E” 命令没有参数。 [optional data] 在上一个命令为 “C”（创建文件）时发送。数据的大小指定为 “C” 的参数。 此外，还有控制字节，这些字节是在没有新行的情况下自己发送的： ‘0x00’-“OK”，确认完成最后一个命令（如编写本地文件）。接收方也会在启动时发送此消息，让发送方知道它已准备好接收命令。 ‘0x00’-“警告”，后面是要向用户显示的行（由新行终止）。 ‘0x00’-“错误” 后跟随可选消息（和警告相同），但连接随后终止。 下面这个带有注释的图片实例，详细讲述了这个过程： 传输过程\" 传输过程 ","date":"2020-07-18","objectID":"/scp/:2:2","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"使用 SCP $ scp 选项 参数 其中选项如下： -1：使用ssh协议版本1； -2：使用ssh协议版本2； -4：使用ipv4； -6：使用ipv6； -B：以批处理模式运行； -C：使用压缩； -F：指定ssh配置文件； -l：指定宽带限制； -o：指定使用的ssh选项； -P：指定远程主机的端口号； -p：保留文件的最后修改时间，最后访问时间和权限模式； -q：不显示复制进度； -r：以递归方式复制。 参数分别为： 源文件：指定要复制的源文件。 目标文件：格式为 user@host：filename（文件名为目标文件的名称）。 ","date":"2020-07-18","objectID":"/scp/:3:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"SCP 的问题 看起来，SCP 听起来似乎没什么问题。它是一个简单易用的工具，然而存在一些现实问题。 ","date":"2020-07-18","objectID":"/scp/:4:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"性能 传输协议的顺序性：每个命令的强制确认都会增加大量开销。例如，如果沿途丢弃单个确认数据包，则整个连接将暂停，直到重新传输开始。最重要的是，发送所有数据而不压缩或询问接收方是否已经拥有该文件并不理想。 有经验的系统管理员可以告诉您，使用 tar 归档文件并发送比使用 scp 递归命令传输要快得多。事实上，这样的话你甚至无需使用 SCP： # Copy a local folder with 10000 files $ find /tmp/big_folder/-type f | wc -l 10000 # Using scp $ time scp -r -q /tmp/big_folder/server:/tmp/big_folder ________________________________________________________ Executed in 882.99 millis fish external usr time 114.09 millis 0.00 micros 114.09 millis sys time 278.46 millis 949.00 micros 277.51 millis # Using tar over ssh $ time sh -c \"tar cf - /tmp/big_folder | ssh server 'tar xC /tmp/-f -'\" tar: Removing leading '/' from member names ________________________________________________________ Executed in 215.68 millis fish external usr time 93.22 millis 0.00 micros 93.22 millis sys time 66.51 millis 897.00 micros 65.62 millis 在这种比较糟糕的情况下，tar\u0026ssh 的 215.68ms 对比 SCP 的 882.99ms，足足有四倍的速度提升。 ","date":"2020-07-18","objectID":"/scp/:4:1","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"安全 我们已经知道，SCP 靠 SSH 负担安全工作，因此它完全安全… 吗？ OpenSSH 的发行说明提到： scp 协议已经过时、不灵活且不容易修复。我们建议使用更现代的协议，如 sftp 和 rsync 来传输文件。 如果远程端的 shell 打印出任何非交互式会话，则本地 SCP 进程将愉快地将该输出解释为 SCP 命令。好的话，这仅仅是打破 SCP 协议中模糊的错误。但在最坏的情况下，远程 shell 启动脚本是恶意的，并向你发送恶意文件，而不是所需的文件。 此外，早在 2018 年，Harry Sintonen 就发现了流行的 SCP 实现（包括 OpenSSH）中的一堆漏洞。包括从修改目录的权限到覆盖任意文件（由于 ～/.ssh/authorized_keys 或 ～/.bashrc）、有效地执行代码，以及注入终端转义序列来隐藏任何追踪。这些漏洞对于任何构建网络 CLI 应用程序的人来说都是一个很好的教训。 ","date":"2020-07-18","objectID":"/scp/:4:2","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"SCP 的替代方案 SFTP 被广泛认为是 SCP 的继承者。为了传输层安全性，它仍然在 SSH 上运行，并且不需要单独设置访问。它可以为您提供一个自定义交互式提示来探索远程文件系统，或者您可以使用预先编写的一系列命令编写脚本。 缺点是，您需要学习 SFTP 提示命令，协议本身尚未完全标准化（有很多 RFC 草稿，但作者最终放弃了）。 Rsync 是另一个很好的选择。使用与 SCP 命令完全相同 - 它也利用 SSH。Rsync 着重优化性能 - 它执行大量的复杂本地计算从而通过网络发送尽可能少的数据。从技术上讲，它致力于数据同步而不是纯传输文件 - 如果远程和本地内容相似，则只会发送增量。 同样，它也有其自身的缺点：发送方使用大量的 CPU 资源来计算要发送什么，并且接收方使用大量磁盘 IO 将数据按正确的顺序放在一起。与 OpenSSH 不同，Rsync 在大多数系统上并不预安装。 ","date":"2020-07-18","objectID":"/scp/:5:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"结论 SCP 是一个简单的工具，它在复制文件方面做得很好，但较新的软件在很多方面都优于它。对于您信任的计算机之间的个人简单使用，SCP 仍然适合。 但是，如果您遇到性能问题或需要满足更高的安全标准，则上面列出的任何备选方案都比 SCP 更可取。选择最适合您需求的，然后试着开始使用。 ","date":"2020-07-18","objectID":"/scp/:6:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"另见 rsync SFTP ","date":"2020-07-18","objectID":"/scp/:7:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Software"],"content":"参考 [1] SCP - Familiar, Simple, Insecure, and Slow [2] Wikipedia Secure copy [3] Call for testing: OpenSSH 8.0 [4] Scp ","date":"2020-07-18","objectID":"/scp/:8:0","tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/"},{"categories":["Network"],"content":" NAT 引发的问题以及解决方法 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:0:0","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"问题 对称型 NAT（Symmetric NAT）常常在游玩联机游戏（尤其是 P2P 联机方式）时候给我们造成困扰。如果 Xbox、PS、switch 或者 PC 上的应用程序报告 NAT 是严格、类型 3、类型 D、对称这样的字样，那么就意味着你将会出现联机问题。 理解这个问题之前，首先要认识到，这些设备及软件是无法感知它们是否被 NAT 化的。但是，在 Internet 上与之通信的任何设备都应该使用公共 IP 地址，例如 1.1.1.1。在进行任何连接尝试时，都必须知道目标公共 IP 地址和端口。在上面的所有示例中，你应该发现了网站 IP 地址和端口均已知，这些地址是固定的，并且未曾发生更改。但是，某些程序会使用一系列动态端口。在运行游戏时，你的主机选择一个随机端口来进行游戏。由于其他主机不知道你的 IP 地址或端口，因此必须在连接之前以某种方式了解它。你的主机会将游戏的 IP 地址和端口发送到 Xbox Live 或 PS 网络，这样其他主机便可以在其中检索它，然后直接与你连接。但问题是，它发送的是内部 IP 地址 192.168.0.1 和端口 54324，而不是 Nat 后的公共 IP。它应该发送的是（例如）1.1.1.1 的公共 IP 地址和端口 54324。而且当处于对称型 NAT 时，该端口也会发生更改，因此它必须发送经过 NAT 处理的端口，例如 54254，而不是主机本身的内部端口（54324）。 这不仅仅是游戏面对的问题，这一直是 NAT 的问题。 那么，主机如何得知它位于 NAT 之后，并告诉其他主机将数据发送到 NAT 后的 IP 地址和端口而不是其自身的内部 IP 地址和端口？ ","date":"2020-07-15","objectID":"/nat_issues_solutions/:1:0","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"解决办法 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:0","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"STUN（Session Traversal Utilities） STUN 是 NAT 的 Session Traversal Utilities 的缩写，你可能已经猜到了它的名字，它是一个实用工具的集合，以帮助 NAT 设备穿越内网。简单地说，STUN 允许你的主机 / PC 或内部设备了解它的公共 NAT 的 IP 地址和端口是什么。一旦实现了这一点，你的设备现在可以发送正确的 IP 和端口，其他设备也可以连接到你。但是，它在对称型 NAT 下无法工作，在对称型 NAT 中，你的主机可以得知它的公共 IP 地址，但无法得知它的公共端口（因为，端口是 NAT 随机生成的）。 STUN 的工作原理很简单。你连接到一个运行 STUN 协议的服务器 (Xbox Live Servers)，它从接收的数据包中读取源 IP 地址和源端口，这些当然会是 NAT 后的（这是我们需要的）。然后 STUN 将这些信息返回给客户端，它的工作就完成了。你的主机现在知道了它的 NAT 后的 IP 和端口，并且会把这些信息发送到其他设备上。 STUN 算法\" STUN 算法 如果你还记得，除了对称型 NAT 之外，所有其他类型的 NAT 都不会改变源端口。这意味着当我的主机创建一个 NAT 映射时，它将对所有这种类型的连接使用它，当向互联网上的个设备发送和接收数据包时，它使用同一个映射，因此它使用相同的公共 IP 地址和端口； 但在对称型 NAT 的情况下，每一个连接都有一个不同的映射，有一个不同的（随机生成的）端口，意味着连接到 STUN 服务器也将有它自己独特的映射，表现的就像一个新的设备接入一样。这意味着每个映射都有不同的端口，在这种情况下，STUN 检测到的端口现在已经没有用了，因为这个映射是 STUN 服务器独有的。无论映射到其他设备的端口是什么，都是未知的，STUN 也没有办法检测到它。由于你的主机无法得知每个映射到每个主机的公共 NAT 化端口，因此无法将这些信息传递给你，也就意味着没有设备可以连接到你的游戏，这就是对称型 NAT 导致如此多游戏联机问题的原因。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:1","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"DMZ（Demilitarized zone) 路由器上的外围网络（也称 DMZ）功能用于消除对 Internet 的限制。它主要是将你的设备移到你的网络防火墙之外的区域，将部分用于提供对外服务的服务器主机划分到一个特定的子网 —— DMZ 内，在 DMZ 的主机能与同处 DMZ 内的主机和外部网络的主机通信，而同内部网络主机的通信会被受到限制。这使 DMZ 的主机能被内部网络和外部网络所访问，而内部网络又能避免外部网络所得知。 注意 当你设置外围网络时在主机上使用静态 IP 地址十分重要。要设置静态 IP 地址，请使用路由器的 DHCP 预留功能（如果可用）。如果该功能不可用，你将需要在你的设备 上配置手动 IP 设置。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:2","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"UPnP（Universal Plug and Play） UPnP（Universal Plug and Play）是帮助路由器有效通信的一个标准。如果路由器或网关支持 UPnP，则它在默认情况下可能已启用。开启 UPnP 功能后，局域网中的计算机可以请求路由器自动进行端口转换。这样，互联网上的计算机就能在需要时访问局域网计算机上的资源（如 MSN Messenger 或迅雷、BT、PPLive 等支持 UPnP 协议的应用程序）。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:3","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":"参考 [1] Symmetric NAT and It’s Problems | Think Like A Computer [2] Wikipedia STUN [3] Wikipedia DMZ [4] 解决 NAT 错误和多人游戏问题 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:3:0","tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/"},{"categories":["Network"],"content":" 一文概览 NAT ","date":"2020-07-14","objectID":"/nat/:0:0","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"NAT NAT（Network Address Translation，网络地址转换）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。 NAT 从大类上都可以分为两类：静态 NAT 和 动态 NAT。 静态 NAT 是管理员手动创建和维护映射，通常与 NAT 的入站类型相关联。 动态 NAT 是路由器根据需要自动创建和维护映射，通常与 NAT 的出站类型相关联。 每个 TCP/IP 数据包都包含一个 源 IP 地址、源端口、目的 IP 地址 和 目的端口。所有类型的 NAT 都会使用这些值创建 NAT 映射。 例如，一个 IP 为 192.168.0.1 的内部客户机使用端口 56876，经过 NAT 转变后 IP 变为 3.3.3.3（翻译后的源 IP）和端口 56876（源端口）连接到 IP 2.2.2.2（目的 IP 地址）的 80 端口（目的端口）。NAT 使用原始内部 IP 和端口、翻译后 IP 和端口这 4 个值创建一个映射。当数据包从网站返回到路由器时，使用与该映射相关值，NAT 将数据包转发到内部客户端。 ","date":"2020-07-14","objectID":"/nat/:1:0","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"NAT 的四种类型 ","date":"2020-07-14","objectID":"/nat/:2:0","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"全锥型 NAT（Full Cone NAT) 全锥型 NAT\" 全锥型 NAT 全锥型 NAT 是静态 NAT，也是唯一一种永久开放端口的 NAT，允许从 任何外部主机 进行入站连接。全锥型 NAT 将一个公共 IP 地址和端口映射到 LAN IP 和端口。任何外部主机都可以通过映射的 NAT IP 和端口向 LAN IP 发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的 NAT 也被称为端口转发。这是受限制最少的 NAT 类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。 例如，我的电脑有一个网站在 80 端口上运行，我创建了一个一对一的规则，将路由器的 WAN IP 1.1.1.1 映射到 192.168.0.1，端口 80 映射到 80 端口。凡是在 80 端口向 1.1.1.1 发送数据的外部主机都会被 NAT 转发到 192.168.0.1 80 端口。 注意： 端口号不必相同；我可以在 56456 端口上运行我的网站，但创建 NAT 映射，将 80 端口转发到 56456 端口。这样，外部客户端就会认为我的网站在 80 端口上，而在任何其他端口上的连接尝试都会被丢弃。 ","date":"2020-07-14","objectID":"/nat/:2:1","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"受限锥形 NAT（Restricted Cone NAT） 受限锥形 NAT\" 受限锥形 NAT 受限锥体 NAT 是动态 NAT，它的工作方式与全锥型 NAT 相同，但会对进站的 IP 地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的 IP 地址。亦即需要内部主机首先发起连接的外部主机，才能被接受入站。 例如，我的电脑与一个网站 (56.45.34.78) 进行外向连接，源 IP 为 192.168.0.1，源端口为 56723。NAT 使用源端口 56723 创建一个（动态）映射到我的电脑。使用目的端口 56723（这是出站 NAT 的源端口）到达的源 IP 为 56.45.34.78（网站 IP）的数据包将被接受，接着网站返回数据至我的 PC。任何其他 IP 即使使用正确的 56723 端口进行连接尝试将被丢弃。同样，即使正确的 IP 使用 56723 以外的目的端口进行的连接尝试也将被丢弃。 ","date":"2020-07-14","objectID":"/nat/:2:2","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"端口受限锥型 NAT（Port Restricted Cone NAT) 端口受限锥型 NAT\" 端口受限锥型 NAT 端口受限锥型 NAT 是动态 NAT，它的作用与受限锥形 NAT 完全相同，但同时对端口进行限制。受限锥形 NAT 接受来自外部主机任何源端口的连接，而端口受限锥型 NAT 则进一步要求外部主机的源端口是固定的。 例如，我的电脑在 80 端口（目标端口）上向网站 IP 217.87.69.8 建立了一个外向连接。NAT 将我的源 IP 192.168.0.1 映射到 WAN IP 1.1.1.1 和源端口 56723。当网站发回数据包时，它的源 IP 必须是 217.87.69.8，目的端口是 56723（就像一个受限锥型 NAT），但除此之外，还要求源端口必须是 80。如果这三者中的任何一个不一样，端口受限锥型 NAT 就会放弃连接。 ","date":"2020-07-14","objectID":"/nat/:2:3","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"对称型 NAT（Symmetric NAT） 对称型 NAT\" 对称型 NAT 对称型 NAT 是动态 NAT，它限制的方式与端口受限锥型 NAT 完全相同，但处理 NAT 转换的方式不同。目前讨论的所有类型的 NAT 在 NAT 连接时都 不会改变源端口。 例如，当客户端使用 IP 192.168.0.1 和源端口 56723 访问互联网时，NAT 将源 IP 改变为 56.35.67.35，但保持端口号不变，这被称为端口保留。 而对称型 NAT 会将端口改为 随机生成的新端口，甚至是同一客户端到不同目的地的连接也会发生。亦即为每个连接创建唯一的映射 例如，在端口受限锥型 NAT 的例子上进行扩展，我的 PC 向网站 IP 217.87.69.8 和 56.76.87.98 建立两个出站连接。我的电脑使用源 IP 192.168.0.1 和源端口 56723 进行两个连接。到目前为止，在所有类型的 NAT 上，这两个连接都会被 NAT 化，只改变源 IP 地址而保持源端口不变。然而这次，对称型 NAT 没有将源端口保留为 56723，而是将其中一个连接的源端口改为 45765，另一个连接的源端口改为 53132（随机）。这就为每个连接创建了唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以 217.87.69.8 必须将数据包发送到目的端口 45765，56.76.87.98 必须将数据包发送到端口 53132，此外还需要遵循端口受限锥型 NAT 的要求。 ","date":"2020-07-14","objectID":"/nat/:2:4","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"对 NAT 的正面评价 NAT 在一定程度上缓解了 IPv4 地址短缺的问题，让更多的设备（间接）接入了互联网。 NAT 全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT 依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为 UDP 的跨局域网的传输提供了方便。 ","date":"2020-07-14","objectID":"/nat/:3:0","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"对 NAT 的批评 在一个具有 NAT 功能的路由器下的主机并没有获得真正的 IP 地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的 TCP 连接和无状态协议（比如 UDP）无法实现。除非 NAT 路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。 端对端连接是被 IAB 委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为 NAT 是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地 IP 地址，所以他们必须通过 NAT 来访问 ISP 网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。 NAT 使得 IP 协议从面向无连接变成立面向连接。NAT 必须维护专用 IP 地址与公用 IP 地址以及端口号的映射关系。在 TCP/IP 协议体系中，如果一个路由器出现故障，不会影响到 TCP 协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在 NAT 时，最初设计的 TCP/IP 协议过程将发生变化，Internet 可能变得非常脆弱。 NAT 违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第 N 层是不能修改第 N+1 层的报头内容的。NAT 破坏了这种各层独立的原则。 NAT 同时存在对高层协议和安全性的影响问题。RFC 对 NAT 存在的问题进行了讨论。NAT 的反对者认为这种临时性的缓解 IP 地址短缺的方案推迟了 IPv6 迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。 ","date":"2020-07-14","objectID":"/nat/:4:0","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":"参考 [1] Wikipedia NAT [2] What you need to know about symmetric NAT | Think Like A Computer [3] NAT Types Defined ","date":"2020-07-14","objectID":"/nat/:5:0","tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/"},{"categories":["Network"],"content":" DNS 如何工作？更新网站的 DNS 记录的时候发生了什么？更新后必须等待 48 小时才能生效吗？为什么有人看到的是新 IP，有人看到的是旧 IP？ ","date":"2020-07-02","objectID":"/dns_update/:0:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"DNS 分类 我们知道，DNS 服务器有两种：权威服务器（authoritative）和递归服务器（recursive） 权威 DNS 服务器（也称为名称服务器，NS，nameserver） 具有其所负责的每个域的 IP 地址数据库。 例如，github.com 的权威 DNS 服务器是 NS-421.awsdNS-52.com 您可以像这样要求它提供 github.com 的 IP: $ dig @NS-421.awsdNS-52.com github.com 递归 DNS 服务器，本身并不知道谁拥有什么 IP 地址。它们通过询问正确的权威 DNS 服务器，找出域名的 IP 地址，然后缓存这个 IP 地址，以备再次询问。8.8.8.8 是一个递归 DNS 服务器。 当人们访问你的网站时，他们可能会向递归 DNS 服务器进行 DNS 查询。那么，递归 DNS 服务器是如何工作的呢？ ","date":"2020-07-02","objectID":"/dns_update/:1:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"递归 DNS 服务器如何工作 以 8.8.8.8 为例，如果我们向其请求 github.com 的 IP 地址（A 记录），如果它存在缓存，那么就直接返回缓存结果。然而，缓存是有期限的，如果所有缓存都过期了呢？那么情况是这样的： 递归服务器内部硬编码（hardcoded）有根 DNS 服务器 . 的 IP 地址（参见 [2][3]），选择一个根 DNS 服务器，例如 198.41.0.4 询问根 DNS 服务器有关 com. 的 NS 此步可以使用如下方法模拟： $ dig @198.41.0.4 github.com ... com. 172800 IN NS a.gtld-servers.net. ... a.gtld-servers.net. 172800 IN A 192.5.6.30 ... 可以看到，这里我们得到一个 com. 的权威 NSa.gtld-servers.net. 及其 IP 地址 192.5.6.30 注：实际上，99.99% 的情况下，此步我们就将得到 github.com 的 A 记录，但为了展示 DNS 解析进程，我们假设这里没有得到。 询问该权威 NS 有关 github.com 的 NS $ dig @192.5.6.30 github.com ... github.com. 172800 IN NS NS-421.awsdNS-52.com. NS-421.awsdNS-52.com. 172800 IN A 205.251.193.165 ... 这里，我们得到的 github.com.NSNS-421.awsdNS-52.com. 及其 IP 地址 205.251.193.165 询问该 NS 有关 github.com 的 A 记录 $ dig @205.251.193.165 github.com github.com. 60 IN A 140.82.112.4 至此，在假设没有缓存的情况下，我们通过完整的流程（实际上绝大多数情况不需要完整进行）获得了 github.com 的 IP 地址。 此外，使用 $ dig @8.8.8.8 +trace github.com 可以一次性显示上述所有步骤。 ","date":"2020-07-02","objectID":"/dns_update/:1:1","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"更新 DNS 记录 更新 DNS 记录时，有两种情况： 保持相同的 NS 变更 NS ","date":"2020-07-02","objectID":"/dns_update/:2:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"首先谈谈生存时间（TTLs，time to live） 上面已经说到，DNS 服务器一般存有缓存，而控制缓存是否过期的参数就是 TTL。 我们假设得到一个查询结果： $ dig @205.251.193.165 github.com github.com. 60 IN A 140.82.112.4 这里的 60（秒）即表示 TTL，这是一个很短的 TTL。理论上，如果每个用户都遵循 DNS 标准，那么 github.com 在更改了 IP 地址后，每个用户都应该在 60 秒内得到这个新的地址。但实际上呢？ ","date":"2020-07-02","objectID":"/dns_update/:2:1","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"更新同一 NS 上的 DNS 记录 假设我们已经在域名商处更新了新的 DNS 记录 test.jvNS.ca–\u003e1.2.3.4，试着查询： $ dig @8.8.8.8 test.jvNS.ca test.jvNS.ca. 299 IN A 1.2.3.4 如果此前没有设置过 DNS 记录，因为没有缓存，所以立刻生效了。这里可以看到 TTL 是 299。那么，修改 IP 为 5.6.7.8 呢。 $ dig @8.8.8.8 test.jvNS.ca test.jvNS.ca. 144 IN A 1.2.3.4 可以看到，IP 并没有发生改变且 TTL 表示缓存还将存在 144 秒。而且，多次查询，你可能会发现，有时候可以得到新的 IP，但有的时候又是旧的 IP。 这里是因为像 8.8.8.8 这样的 DNS 服务器采用了负载均衡，每次查询可能被分配到不同的后端服务器，而他们的缓存不尽相同。 等待 5 分钟后，所有的缓存都更新了，再次查询，将会始终返回新 IP。 ","date":"2020-07-02","objectID":"/dns_update/:2:2","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"TTL 并非总是可靠 与大多数互联网协议一样，并不是所有的终端都服从 DNS 规范（包括 8.8.8.8 这样的大型 DNS 也不尊重 TTL）。一些 ISP 的 DNS 服务器会将缓存记录的时间比 TTL 规定的时间长，比如可能是 2 天而不是 5 分钟。而且人们总是可以在他们的 /etc/hosts 中硬编码旧的 IP 地址。 此外，应用程序（例如浏览器）都内置了自己的 DNS 缓存，或者本地网关也存在缓存。 这也是为什么，即便正确地设置了对应的 TTL（大部分 DNS 将会在短时间内更新缓存），有些 DNS 服务器仍然需要更长时间生效，这也导致我们的查询也并不总是会得到新的 IP 地址。 ","date":"2020-07-02","objectID":"/dns_update/:2:3","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"连同 NS 一起更新 假设此前的 NS 为 dNS1.p01.NSone.net，现在我们把他修改为谷歌的 NSNS-cloud-b1.googledomaiNS.com。 通常，当你修改完成后，你的域名商会提示你：“修改将在 48 小时内生效”。 然后设置一个新的 A 记录指向 1.2.3.4 dig 看看： $ dig @8.8.8.8 examplecat.com examplecat.com. 17 IN A 104.248.50.87 8.8.8.8 没有变化，询问别的 DNS： $ dig @1.1.1.1 examplecat.com examplecat.com. 299 IN A 1.2.3.4 1.1.1.1 更新了。 造成这样不同结果的原因，可能是此前并没有人询问过 1.1.1.1，所以他没有缓存，能立刻得到新的 IP。 而如果我们向新的 NS 查询，肯定会得到新的 IP 记录： $ dig @NS-cloud-b1.googledomaiNS.com examplecat.com examplecat.com. 300 IN A 1.2.3.4 ","date":"2020-07-02","objectID":"/dns_update/:2:4","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"NS 的 TTL 要长很多 域名商提示：“修改将在 48 小时内生效” 的原因是 NS 记录（告诉递归 NS 应该向哪个 NS 查询）的 TTL 要长的多。 回到上一节中，我们的查询结果显示： $ dig @192.5.6.30 github.com ... github.com. 172800 IN NS NS-421.awsdNS-52.com. NS-421.awsdNS-52.com. 172800 IN A 205.251.193.165 ... 172800 秒是 48 小时！这就是为什么更改 NS 后需要更长的时间来生效。 ","date":"2020-07-02","objectID":"/dns_update/:2:5","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"NS 如何得到更新？ 更新 NS 后，我们向根服务器查询的话就会到得到这样的结果： $ dig NS @j.gtld-servers.net examplecat.com examplecat.com. 172800 IN NS NS-cloud-b1.googledomaiNS.com 你可能会疑惑，新的 NS 记录是如何在根服务器处更新的呢？是因为当你在域名商那里更改你域名的 NS 后，他们会负责将这个给更改告知根服务器。 通常这个更新将在几分钟内就生效，但是对于其他一些顶级域名（TLD）（非.com）可能速度稍微慢一些。 ","date":"2020-07-02","objectID":"/dns_update/:2:6","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"总结 本文展示了 DNS 的解析过程以及我们更新 DNS 记录时发送了什么，希望有助于你理解这一过程。 ","date":"2020-07-02","objectID":"/dns_update/:3:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":"参考 [1] What happens when you update your DNS? [2] unbound’s source code [3] iana root files ","date":"2020-07-02","objectID":"/dns_update/:4:0","tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/"},{"categories":["Network"],"content":" 简要介绍 Nagle 算法 ","date":"2020-06-28","objectID":"/nagle/:0:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Network"],"content":"Nagle 算法 Nagle 算法通过减少网络发包频率从而提高 TCP/IP 网络的效率。 主要解决由于 TCP 包头大小，导致频繁发送小数据包有效数据内容太少，开销过大段的问题。 Nagle 算法是将大量等待发送的小数据包合并起来，然后一次性全部发送出去。具体地说，只要有一个发送方没有收到任何确认的数据包，发送方就应该一直缓冲它的输出，直到它有一个完整的数据包的输出，这样就允许一次发送所有的输出。 其思路可以由下面的步骤所描述： if there is new data to send then if the window size ≥ MSS and available data is ≥ MSS then send complete MSS segment now else if there is unconfirmed data still in the pipe then enqueue data in the buffer until an acknowledge is received else send data immediately end if end if end if Nagle 算法可能导致期望实时响应和低延迟的应用程序体验不佳。 诸如网络多人视频游戏或鼠标在远程控制的操作系统中移动等应用程序，期望立即发送操作，而算法故意延迟传输，以牺牲延迟为代价提高带宽效率。因此，具有低带宽时间敏感传输的应用程序通常用于绕过 Nagle 延迟的 ACK 延迟。 ","date":"2020-06-28","objectID":"/nagle/:1:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Network"],"content":"Windows 下关闭 Nagle 算法 打开注册表编辑器 打开如下路径 计算机 \\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces 注册表界面\" 注册表界面 依次点击下方注册表项，检查右窗格中是否包含 DhcpIPAddress 值； 在包含有 DhcpIPAddress 的子项下，分别建立两个 DWORD (32) 值，依次命名为 TcpAckFrequency 和 TCPNoDelay，键值全部设为 1。 注意 包含 DhcpIPAddress 的子项可能不只一个，所有的都要添加。 ","date":"2020-06-28","objectID":"/nagle/:2:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Network"],"content":"参考 [1] Nagel 算法维基百科 [2] RFC896 ","date":"2020-06-28","objectID":"/nagle/:3:0","tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/"},{"categories":["Linux"],"content":"Linux\" Linux 记录一些常见的 Linux 服务器安全问题分析以及防护措施 ","date":"2020-06-07","objectID":"/linux_security/:0:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"日志分析 ","date":"2020-06-07","objectID":"/linux_security/:1:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"常用日志文件 Debian 以及 RHEL 系的系统日志是由一个名为 syslog 的服务管理的，如以下日志文件都是由 syslog 日志服务驱动的： /var/log/boot.log：记录了系统在引导过程中发生的事件，就是 Linux 系统开机自检过程显示的信息 /var/log/lastlog ：记录最后一次用户成功登陆的时间、登陆 IP 等信息 /var/log/messages ：记录 Linux 操作系统常见的系统和服务错误信息 /var/log/secure ：Linux 系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 /var/log/syslog：只记录警告信息，常常是系统出问题的信息，使用 lastlog 查看 /var/log/wtmp：该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，使用 last 命令查看 /var/run/utmp：该日志文件记录有关当前登录的每个用户的信息。如 who、w、users、finger 等就需要访问这个文件 /var/log/btmp：记录 Linux 登陆失败的用户、时间以及远程 IP 地址 /var/log/auth.log 或 /var/log/secure 存储来自可插拔认证模块 (PAM) 的日志，包括成功的登录，失败的登录尝试和认证方式。 注：Debian 系在 /var/log/auth.log 中存储认证信息而 RHEL 系则在 /var/log/secure 中存储。 Archlinux 使用 systemd 提供的日志系统（logging system），称为 journal。使用 systemd 日志，无需额外安装日志服务（syslog）。 ","date":"2020-06-07","objectID":"/linux_security/:1:1","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"相关日志查看命令 $ cat /var/log/secure | awk '/Failed/{print $(NF-3)}' | sort | uniq -c | awk '{print $2\"=\"$1;}' 查看尝试暴力登录 root 的 IP 及次数 $ grep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more ","date":"2020-06-07","objectID":"/linux_security/:1:2","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"常见防护措施 ","date":"2020-06-07","objectID":"/linux_security/:2:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"SSH 编辑 SSH 配置文件 $ vim /etc/ssh/sshd_config 1、修改端口 #Port 22 —\u003e Port xxxx 2、关闭 root 登录 PermitRootLogin yes -\u003e PermitRootLogin no 3、使用证书登录 若不存在证书首先执行下面步骤 在客户端生成密钥: $ ssh-keygen -t rsa 把公钥拷贝至服务器: $ ssh-copy-id -i .ssh/id_rsa.pub server 或手动将 id_rsa.pub 拷贝至服务器用户目录的.ssh 中，并修改访问权限： $ scp .shh/id_rsa.pub server:~/.ssh 服务器中： $ chmod 400 authorized_keys 打开证书登录： RSAAuthentication yes 开启公钥验证： PubkeyAuthentication yes 验证文件路径： AuthorizedKeysFile .ssh/authorized_keys 禁止密码认证： PasswordAuthentication no 禁止空密码： PermitEmptyPasswords no 最后，重启 SSHD 服务 $ systemctl restart sshd ","date":"2020-06-07","objectID":"/linux_security/:2:1","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"用户以及用户组管理 无用用户、用户组 Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户 使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时 在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限 可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"关闭不必要的服务 例如 某台 Linux 服务器用于 www 应用，那么除了 httpd 服务和系统运行是必须的服务外，其他服务都可以关闭。下面这些服务一般情况下是不需要的，可以选择关闭： anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv ","date":"2020-06-07","objectID":"/linux_security/:2:3","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"文件系统安全 文件权限检查和修改 （1）查找系统中任何用户都有写权限的文件或目录 $ find / -type f -perm -2 -o -perm -20 |xargs ls -al //查找文件 $ find / -type d -perm -2 -o -perm -20 |xargs ls –ld //查找目录 （2）查找系统中所有含 “s” 位的程序 $ find / -type f -perm -4000 -o -perm -2000 -print | xargs ls –al 含有 “s” 位权限的程序对系统安全威胁很大，通过查找系统中所有具有 “s” 位权限的程序，可以把某些不必要的 “s” 位程序去掉，这样可以防止用户滥用权限或提升权限的可能性。 （3）检查系统中所有 suid 及 sgid 文件 $ find / -user root -perm -2000 -print -exec md5sum {} ; $ find / -user root -perm -4000 -print -exec md5sum {} ; 将检查的结果保存到文件中，可在以后的系统检查中作为参考。 （4）检查系统中没有属主的文件 $ find / -nouser -o –nogroup 没有属主的孤儿文件比较危险，因此找到这些文件后，要么删除掉，要么修改文件的属主，使其处于安全状态。 ","date":"2020-06-07","objectID":"/linux_security/:2:4","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Linux"],"content":"参考 [1] Linux 服务器为什么被黑？ [2] linux 系统安全加固 – 账号相关 [3] Security - Archlinux Wiki ","date":"2020-06-07","objectID":"/linux_security/:3:0","tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/"},{"categories":["Software"],"content":"Huginn\" Huginn 简单介绍使用 Docker 运行的 Huginn 数据的备份与恢复 ","date":"2020-05-27","objectID":"/huginn_backup/:0:0","tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/"},{"categories":["Software"],"content":"备份数据 使用命令在容器中生成备份： $ docker exec -it huginn mysqldump --single-transaction --opt -u root -ppassword huginn_production \u003e huginn_backupfile.sql 或直接拷贝数据到容器外： $ docker exec -it huginn mysqldump -u root -ppassword huginn_production \u003e /root/test_db.sql ","date":"2020-05-27","objectID":"/huginn_backup/:0:1","tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/"},{"categories":["Software"],"content":"恢复数据 首先复制文件到 docker 中： $ docker cp /home/xxxx/huginn_backupfile.sql huginn: /app/xxxxx/huginn_backupfile.sql 然后进入 docker： $ docker exec -ti huginn bash 接下来恢复数据库: $ mysql -u root -ppassword huginn_production \u003c huginn_backupfile.sql ","date":"2020-05-27","objectID":"/huginn_backup/:0:2","tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/"},{"categories":["VM"],"content":" PVE 安装过程中遇到的问题以及解决方法 PVE 安装 Q\u0026A 近期将家里的服务器从 Hyper-V 迁移到 PVE 上。 目前安装有黑群晖、Openwrt、Ubuntu 18.09LTS 目前的网络拓扑图如下： 网络拓扑图\" 网络拓扑图 将安装过程中遇到的问题以及解决方法整理如下： ","date":"2020-05-19","objectID":"/pve_q_a/:0:0","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"1. Temporary failure in name resolution： 由于开始使用路由器拨号，因此初次安装设置的 DNS 服务器为路由器地址，安装软路由后更改了地址，所以导致 DNS 服务器设置错误 192.168.1.190 \u003e 192.168.1.1 ","date":"2020-05-19","objectID":"/pve_q_a/:0:1","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"2. 群晖挂载硬盘： PVE 正确识别到了 NTFS 的一硬盘，但是群晖不能自动挂载。需要关机后，在 PVE 虚拟机管理界面，添加，然后重启才能识别。(否则显示为红色，同样的，移除硬件需要同样的操作) ","date":"2020-05-19","objectID":"/pve_q_a/:0:2","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"3. PVE 节点监视图不显示，时间为 1970-1-1： 删除界面缓存文件即可： $ rm /var/lib/rrdcached/db/pve2-node ","date":"2020-05-19","objectID":"/pve_q_a/:0:3","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["VM"],"content":"4. 群晖 socks 代理 Openwrt 安装 luci-app-Privoxy，设置转发规则： $ /ip:port . ","date":"2020-05-19","objectID":"/pve_q_a/:0:4","tags":["Q\u0026A","PVE"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/"},{"categories":["Web"],"content":" 记录使用 Hugo 搭配 LoveIt 搭建本博客遇到的问题以及解决方案 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:0","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"1. 虚拟机中 Hugo server 无法远程访问 hugo server 默认只会 bind localhost 使用： $ Hugo server --bind xxx.xxx.xxx.xxx 指定虚拟机 IP，即可通过同网域机器访问该 web 服务 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:1","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"2. 使用 git 信息生成文章上一次修改时间 首先，启用 git 信息： enableGitInfo = true 然后，启用 gitRepo 参数： gitRepo = “/xxx/xxxx/.git/” 需要注意的是： 这里 .git 应该 init 在 Hugo 生成的项目根目录中 但是这样，如果只 push public 文件夹到 Github 上部署的话，网页上无法正确跳转对应的 commit 详情页。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:2","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"3. 页面出现 %!(EXTRA string=xxxx) LoveIt Github Issue 提到该问题的解决方案 但实际通过修改 config.toml 中的defaultContentLanguage = \"zh\"为defaultContentLanguage = \"zh-cn\"即可解决。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:3","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"4.开启 Gitalk 评论 Gitalk 使用 Github 仓库的 Issue 页面存储评论内容。 因此，首先我们需要在 Github 新建一个仓库（推荐）用于存储评论。 接着打开 Settings \u003e Developer settings \u003e OAuth Apps ，点击 New OAuth App 新建 OAuth App\" 新建 OAuth App 然后填写信息： Application name : 随便填写 Homepage URL : 随便填写 Application description : 随便填写 Authorization callback URL : 一定要填写你的博客地址 完成后，点击 Register application 完成注册。 然后找到博客项目根目录中的 config.toml ，修改以下字段： [params.page.comment.gitalk] enable = true owner = “techkoala” # 你的 Github 用户名 repo = “commets_of_blog” # 用于存储评论的仓库名 clientId = “xxxxxx” # 请于 OAuth App 页面获取 clientSecret = “xxxxxx” # 请于 OAuth App 页面获取 完成上述设置后，现在就可以正常使用 Gitalk 评论系统了。评论内容可以通过 Github 对应仓库的 Issue 页面进行管理。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:4","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"5.CDN 配置 LoveIt 的默认的 CDN 数据文件位于 themes/LoveIt/assets/data/cdn/ 目录。 将该目录下的 jsdelivr.yml 移动到你的项目下相同路径： assets/data/cdn/。（如果需要使用别的 CDN，可以执行参考 CDN 网站的配置说明对 jsdelivr.yml 进行修改 然后修改 config.toml 文件中的： CSS 和 JS 文件的 CDN 设置 [params.cdn] CDN 数据文件名称, 默认不启用 (“jsdelivr.yml”) data = “jsdelivr.yml” ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:5","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Web"],"content":"6.Hugo 矩阵渲染 因为 hugo 默认的 Markdown 引擎先处理 Markdown，而反斜杠\\在 Markdown 中代表转义字符，所以双斜杠无法正确渲染矩阵， $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\ 0\u00261\\end{bmatrix}$ 解决办法是在 Katex 原始语法再加入一个斜杠就好了 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:6","tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/"},{"categories":["Git"],"content":" 总结使用 Github 时遇到的问题以及解决方法 ","date":"2020-05-10","objectID":"/github_issue/:0:0","tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["Git"],"content":"无法推送 ​ 首先，使用如下命令检查问题详情： $ ssh -vT git@github.com ​ 然后确认您的私钥已生成并加载到 SSH。 如果使用的是 OpenSSH 6.7 或更早版本： # 在后台启动 ssh-agent $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 $ ssh-add -l \u003e 2048 a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/you/.ssh/id_rsa (RSA) ​ 如果使用的是 OpenSSH 6.8 或更新版本： # 在后台启动 ssh-agent $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 $ ssh-add -l -E md5 \u003e 2048 MD5:a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/you/.ssh/id_rsa (RSA) ","date":"2020-05-10","objectID":"/github_issue/:1:0","tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["Git"],"content":"确认公钥已附加到账户 ​ 在后台启动 SSH 代理程序。 $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 ​ 找到并记录公钥指纹。 如果使用的是 OpenSSH 6.7 或更早版本： $ ssh-add -l \u003e 2048 a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/USERNAME/.ssh/id_rsa (RSA) ​ 如果使用的是 OpenSSH 6.8 或更新版本： $ ssh-add -l -E md5 \u003e 2048 MD5:a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/USERNAME/.ssh/id_rsa (RSA) 如果没有添加，则 $ ssh-add /xxx/.ssh/xxx 注意 不知为何，使用自定义名字的密钥，每次 git 操作都要重新添加一次，尚不明确原因。 ","date":"2020-05-10","objectID":"/github_issue/:1:1","tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["Git"],"content":"添加到 Github ​ Settings \u003e SSH and GPG keys \u003e 添加公钥即可 ","date":"2020-05-10","objectID":"/github_issue/:1:2","tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/"},{"categories":["WirelessCommunication"],"content":" LTE 物理信号详解 ","date":"2020-02-20","objectID":"/lte_physical_signals/:0:0","tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/"},{"categories":["WirelessCommunication"],"content":"导频信号 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:0","tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/"},{"categories":["WirelessCommunication"],"content":"下行导频信号 物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列 使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案 导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号 小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS）\" 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频 MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案\" 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频 LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案\" 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/"},{"categories":["WirelessCommunication"],"content":"上行导频信号 物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列 使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频 上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频\" 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频 上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP）\" PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP）\" PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号 上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置\" 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置\" 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案\" Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/"},{"categories":["WirelessCommunication"],"content":"同步信号（PSS/SSS） 下行同步信号用于支持物理层的小区搜索，实现用户终端对小区的识别以及对系统下行信号的频率和时间同步。 同步信号包括： 主同步信号（Primary Synchronization Signal，PSS） 辅同步信号（Secondary Synchronization Signal，SSS） PSS 和 SSS 的传输周期都是 5ms，每个同步信号的时间长度为 1 个 OFDM 符号，在频域上占用下行频带中心 1.08MHz 的带宽。 PSS/SSS 信号使用的序列与物理层小区 ID 相关，因此可用于终端对小区的识别。 物理层支持 504 个小区 ID：分为 168 个组（0 ～ 167），每个组包含 3 个小区 ID（0 ～ 2）。 主同步信号 PSS 序列包含 3 种可能性，指示小区的组内 ID 辅同步信号 SSS 序列包含 168 种可能性，指示小区的组 ID FDD Type 1 和 TDD Type 2 帧结构中，同步信号具有不同的时间位置。 在 FDD Type 1 帧结构中，PSS/SSS 信号位于第 0 和第 5 子帧 在 TDD Type 2 中，PSS 信号位于第 1 和第 6 子帧（即特殊子帧），SSS 信号位于第 0 和第 5 子帧。 因此，两种帧结构下 PSS 与 SSS 的相对位置有所不同： FDD Type 1 帧结构中，PSS/SSS 位于两个连续的 OFDM 符号 TDD Type 2 帧结构中，PSS/SSS 之间有两个 OFDM 符号的间隔 这种同步信号相对位置的区别，可用于终端在小区搜索的最初阶段检测 LTE 系统的双工方式。 LTE 下行同步信号（FDD Type 1 帧结构）\" LTE 下行同步信号（FDD Type 1 帧结构） LTE 下行同步信号（TDD Type 2 帧结构）\" LTE 下行同步信号（TDD Type 2 帧结构） PSS 和 SSS 在相同的某一根天线上发送，对于各种不同的系统带宽（1.4MHz、3MHz、5MHz、10MHz、15MHz、20MHz），同步信号的传输带宽相同： 占用频带中心的 1.08MHz 带宽，其中同步序列占用 62 个子载波，两边各预留 5 个子载波作为保护带。 同步信号 PSS/SSS 频域结构\" 同步信号 PSS/SSS 频域结构 ","date":"2020-02-20","objectID":"/lte_physical_signals/:2:0","tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-02-20","objectID":"/lte_physical_signals/:3:0","tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/"},{"categories":["WirelessCommunication"],"content":" LTE 多天线技术（MIMO）详解 ","date":"2020-02-01","objectID":"/lte_mimo/:0:0","tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/"},{"categories":["WirelessCommunication"],"content":"多天线技术（MIMO） 在收到信道编码后的数据（codeword）之后，物理层进一步的处理过程包括加扰、调制、层映射、预编码（precoding）以及针对各个物理天线端口的资源映射和 OFDM 信号生成的过程。 物理层数据处理过程\" 物理层数据处理过程 加扰操作是指使用扰码对经过信道编码后的数据进行逐比特的加扰，实现数据间干扰的随机化。采用伪随机码作为扰码，在每个子帧的起始位置，根据 RNTI（Radio Network Temporary Identifier）、Cell ID、Codeword 的编号以及无线帧内的时隙编号等信息，对扰码的 PN 序列 进行初始化。 调制指的是对比特数据进行复数调制，包括 QPSK、16QAM 或者 64QAM。 在完成调制后，物理层的基带处理过程将进行 MIMO 相关的处理，包括 层映射 和 预编码 。LTE Release 8 版本支持不同的发射天线数目（1 / 2 / 4），以及多种不同的 MIMO 方案，包括单天线发送、空间复用和发送分集。 ","date":"2020-02-01","objectID":"/lte_mimo/:1:0","tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/"},{"categories":["WirelessCommunication"],"content":"层映射 层映射实现信道编码之后的码字（Codeword）向空间多天线形成的多个层（layer）之间的映射。 对于单天线的情况，直观地可以得到：物理层使用 1 个码字，并且这个码字直接映射到单天线的 1 个层上 对于多天线实现空间复用的情况，当空间复用的层数目大于 1 的时候，可以同时发送 2 个码字 以 4×4 天线配置的情况为例，根据无线信道的情况可以支持 1、2、3 或者 4 个层的空间复用，当空间复用的层数目大于 1 的时候，可以将 2 个码字映射在这些层上采用空间复用的方式同时进行发送。对于发送分集的情况，使用 1 个码字，按照发送天线数目的不同（2 或者 4），对应于 2 或者 4 个层，此时这 1 个码字将以逐比特转换的方式映射到这些层上。 ","date":"2020-02-01","objectID":"/lte_mimo/:1:1","tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/"},{"categories":["WirelessCommunication"],"content":"预编码 预编码（precoding）实现层到物理天线端口的映射。物理层使用不同的预编码方案，实现不同的 MIMO 模式：单天线发送、空间复用或者发送分集。 单天线发送 对于单天线发送的情况，直观的可以得出，1 个层将直接映射到 1 个物理天线端口上。 空间复用 对于多天线实现空间复用的情况，LTE 中采用基于码本（codebook）进行预编码向量选择的机制，分为开环和闭环两种复用传输模式，分别采用无循环延迟的预编码和大循环延迟的预编码。 在 2 个发送天线的情况时，基站一般使用线性阵列（Uniform LinearArray，ULA）的天线配置，因此，相对应地采用基于 DFT 正交距阵的码本设计方法。 对应于 1 个层的传输，设计了 4 个可供选择的预编码向量 对应于 2 个层的传输，设计了 3 个可供选择的预编码向量。 对于 4 个发送天线的情况，天线的部署要更为复杂，实际情况下可能不使用线性阵列的天线配置，而采用例如双极化天线 所以，基于对各种场景下的性能和复杂度等因素的综合考虑，选择了采用基于 householder 变换 的码本设计方法。对应于 1/2/3/4 个层的传输，均有 16 个可供选择的预编码向量。 预编码向量选取常用的两个准则： 信噪比最大化，对应于容量最大化。将每个可选择的项代入，得到一个等效信道矩阵，计算等效信噪比，选择对应 SNR 最大的向量元素。 最小码距，对应于最小误码率。计算信道信息给出的加权矩阵与码本中元素的距离，选择距离最小的作为预编码向量。 无循环延迟的预编码用于闭环的 MIMO 空间复用。闭环模式下，终端通过对下行信道状态的测量选择适当的空间复用的层数目，并且从码本集合中选择预编码向量，分别表示为 RI（Rank Indicator）和 PMI（Precoding Matrix Indicator）的形式通过上行链路反馈给基站。基站根据这些信息进行预测，确定随后的下行发送中将采用的空间复用方案（包括采用的层数目和预编码向量）。 大循环延迟的预编码用于开环的 MIMO 空间复用。开环模式下，终端不再向基站反馈预编码向量 PMI 的信息，但仍可以根据基站的配置测量并且反馈下行信道的 RI 信息，即空间复用的层数目。基站根据终端上报的 RI 信息或者自行确定的层数目，选择在下行发送中所采用的预编码方案，包括采用发送分集，或者空间复用以及相应的层数目。 在开环空间复用中，采用的预编码向量是固定的。 在使用 2 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案。 当选择 RI=2 时，采用对应码本的第一个元素，即 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ 作为预编码向量。 在使用 4 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案 当选择 RI=2/3/4 时，采用对应的码本，以发送时刻为单位，固定的循环使用码本中序号为 12/13/14/15 的元素作为预编码向量。 对于大循环延迟的预编码，除了预编码向量 $W (i)$ 之外，有两个用于完成循环延迟（Cyclic Delay Diversity，CDD）功能的矩阵，即 $U$ 和 $D (i)$。 假设层数目为 v，那么这两个矩阵的大小都是 $v×v$ 的，其中 $U$ 是 DFT 矩阵，通过对输入信号进行 DFT 变换实现层到虚拟天线的映射，将每个层的信号能量均匀地分布在虚拟天线上 $D (i)$是 CDD 矩阵，实现虚拟天线间增量为 $\\frac{1}{v}$ 的时延。 发送分集 对于多天线实现发送分集的情况，分别采用 SFBC（Space Frequency Block Codiing）和 SFBC+FSTD（Frequency Switched Transmit Diversity）的方案支持 2 和 4 个发送天线的场景。 在 2 个发送天线时，使用 SFBC 的发送分集方案，实现“层”到物理天线映射的预编码操作。 SFBC 发送分集\" SFBC 发送分集 在 4 个发送天线时，使用 SFBC+FSTD 的发送分集方案。相应地，实现层到物理天线映射的预编码操作可以表示为下图所示的形式，即 SFBC 结合 FSTD 在天线间频域的位置转换。 SFBC+FSTD 发送分集\" SFBC+FSTD 发送分集 ","date":"2020-02-01","objectID":"/lte_mimo/:1:2","tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-02-01","objectID":"/lte_mimo/:2:0","tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/"},{"categories":["WirelessCommunication"],"content":" LTE 数据的编码、复用和交织 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:0:0","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"数据的编码、复用和交织 为了进行传输信道向物理信道的映射，提高数据传输的性能，并且将数据是否正确传输的情况向高层报告，物理层需要对传输信道的数据进行一系列信道编码相关的处理，通常的过程包括： 码字 CRC 计算 码块分割和码块 CRC 计算 码块信道编码 码块交织和速率匹配 码块连接的过程 传输块物理层信道编码的过程\" 传输块物理层信道编码的过程 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:0","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"CRC 计算 循环冗余校验码（Cyclic Redundancy Check，CRC）是数据通信领域中最常用的一种差错校验码，接收端通过对所接收到的数据信息和相应的 CRC 信息进行校验，可以判断接收到的数据是否正确。 物理层提供了 4 种 CRC 计算方法，分别用于不同信息的处理过程，其中包括 2 种长度为 24 比特的 CRC 计算方法，1 种长度为 16 比特的 CRC 计算方法，和 1 种长度为 8 比特的 CRC 计算方法。 长度为 24 比特的 CRC 用于下行共享信道（DL-SCH）、寻呼信道（PCH）、多播信道（MCH）和上行共享信道（UL-SCH）等传输信道信息的处理过程 长度为 16 比特的 CRC 用于广播信道（BCH）和下行控制信息（DCI）的处理过程 长度为 8 比特的 CRC 用于上行控制信息（UCI）在上行物理共享信道（PUSCH）中传输时可能需要的 CRC 操作，对应的计算多项式为： $gCRC8 (D)=[D8 +D7 +D4 +D3 +D+1]$ CRC 计算（gCRC8）\" CRC 计算（gCRC8） ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:1","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"码块分割 传输信道中的 1 个传输块（transport block）对应于物理层的 1 个码字（codeword），码字是物理层进行信道编码等相关操作的单位。 当收到来自 MAC 层的 1 个传输块后，物理层将其对应为 1 个码字，首先对整个码字进行 CRC 的计算，得到添加了 CRC 比特后的码字数据流。 考虑到信道纠错编码的性能与处理时延的因素，标准中定义了最大的编码长度为 6144。也就是说，如果添加 CRC 比特后 1 个码字数据流的长度大于 6144 个比特，那么需要对码字进行分割，将 1 个码字分割为若干个码块（code block），这时候需要对每个码块再添加相应的 CRC 比特，然后以码块为单位进行后续的信道纠错编码，以满足信道纠错编码最大长度的限制。 码块分割\" 码块分割 物理层采用的 Turbo 编码的内交织器对数据的长度有一定的要求，标准中以列表的方式给出了所支持的数值，因此，在分块过程中，可能需要进行一定的填充，保证每一个码块的长度符合内交织器的要求。 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:2","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"信道编码 物理层支持包括块编码、截尾的卷积编码和 Turbo 码 3 种不同的信道纠错编码方法。 Turbo 码由于其良好的性能，用于大部分传输信道数据信息的信道编码方法 卷积码的译码复杂度比较低，另外在码长比较短的时候，卷积码的性能与 Turbo 码相近，因此采用截尾的卷积码作为广播信道和物理层下行控制信息主要的信道编码方法 使用块编码作为一些长度更短的信息的信道编码方法，包括控制格式指示信息（PCFICH）、下行 HARQ 指示信息（PHICH）和物理层上行控制信息（上行 ACK 信息、CQI 信息等）。 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:3","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"速率匹配 在速率匹配的过程中，对信道编码后形成的比特流进行选取，以匹配于最终实际使用的物理资源。根据所选取的数据数量的不同，形成不同的编码速率。在这个过程中，以信道编码的每个码块为单位。 Turbo 码速率匹配的数据选择\" Turbo 码速率匹配的数据选择 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:4","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"码块连接 在完成以码块为单位的信道编码和速率匹配的过程之后，将对 1 个码字内所有的码块进行串行连接，形成码字（即传输块）所对应的传输序列，然后就可以进一步地进行信号调制相关的处理与发送了。 码块连接\" 码块连接 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:5","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:2:0","tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/"},{"categories":null,"content":" 粗体 表示在多平台中使用的软件 斜体 表示优先选择表示商店版本(Windows \u0026 MacOS) Linux 优先选用对应包管理器安装 ","date":"2019-12-30","objectID":"/softwares/:0:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"浏览器 FireFox Microsoft Edge Chrome ","date":"2019-12-30","objectID":"/softwares/:1:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"浏览器插件 ClearURLs Enpass extension Feedbro：RSS 阅读器 MONKNOW：新建标签页美化 OneNote Web Clipper Proxy SwitchyOmega Save to Pocket Tampermonkey uBlock Origin 京价保 - 京东价保助手 FireShot 沙拉查词-聚合词典划词翻译 隐私獾 Augmented Steam：steam 增强 Free Download Manager Imagus：鼠标悬停放大图片 Little Star：Github 分类管理 Notion Web Clipper OneTab Stylus Unpaywall：文献解锁 Reggy：匿名用户资料生成 Vimium 二管家：扩展管理 ","date":"2019-12-30","objectID":"/softwares/:1:1","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"压缩\u0026解压缩 Bandizip：7.0 版本已增加付费，停留于 6.26 7-zip Peazip ","date":"2019-12-30","objectID":"/softwares/:2:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"下载 FDM Motrix Eagleget：官方宣称是外国软件，查询证书为国产，原因不明 IDM Aria2 Aria2NG Curl Wget ","date":"2019-12-30","objectID":"/softwares/:3:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"游戏平台及工具 战网 Steam Origin Uplay GOG Galaxy 网易 UU Logitech 鼠标驱动 ","date":"2019-12-30","objectID":"/softwares/:4:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"Code Visual studio code Visual studio 2019 Git Python3 Matlab Pycharm-professional Goland Go ","date":"2019-12-30","objectID":"/softwares/:5:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"文档工具 Office 365 Office tools plus：Office 套件管理工具 Typora iSlide Tools DrawBoard PDF Adobe acrobat DC CAJViewer Visio OneNote Notion ","date":"2019-12-30","objectID":"/softwares/:6:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"视频\u0026音乐 Potplayer 斗鱼 网易云音乐 Mp3tag (歌曲信息管理) foobar2000 VLC Petal：Linux 下豆瓣 FM 第三方客户端 ","date":"2019-12-30","objectID":"/softwares/:7:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"网盘工具 Onedrive RaiDrive Rclone Speedpan ：已失效 Pandownload ：已失效，尽量避免使用百度网盘 Goodsync Resilio Sync ","date":"2019-12-30","objectID":"/softwares/:8:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"即时通信 Telegram Unigram ：Telegram 第三方客户端，相较官方客户端增加了 PC 端的端到端加密聊天功能 微信 QQ ","date":"2019-12-30","objectID":"/softwares/:9:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"密码管理 Enpass ","date":"2019-12-30","objectID":"/softwares/:10:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"网络工具 Shadowsocks-libev ：转向 vmess 协议 Sstap ：停止更新 V2rayN ：已转用 Clash，支持更加灵活的规则和配置文件管理 Clash Clash for Windows ClashX Fiddler Best Trace MobaXterm ：已转用 Termius，多端同步 Termius ZeroTier One Remmina ：Linux 下远程桌面 Wireshark ","date":"2019-12-30","objectID":"/softwares/:11:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"效率工具 Quicker：已转用 utools Wox：已转用 utools WGestures ：Windows 鼠标手势 Fastcopy-M：基于原版的二次开发 Everything Pollar Easystroke：Linux 鼠标手势 Bcompare：已用 Meld 代替 Meld：跨平台开源文件/文件夹对比软件 Utools PowerToys ","date":"2019-12-30","objectID":"/softwares/:12:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"软件\u0026磁盘管理 CCleaner Dism++ Scoop：PowerShell 包管理器 Geek Uninstaller SpaceSniffer CrystalDiskMark CrystalDiskInfo DiskGenius ","date":"2019-12-30","objectID":"/softwares/:13:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"安全工具 火绒 Sandboxie ","date":"2019-12-30","objectID":"/softwares/:14:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"虚拟机 VMware Workstation Pro Hyper-V ","date":"2019-12-30","objectID":"/softwares/:15:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"阅读 irreader Liferea ","date":"2019-12-30","objectID":"/softwares/:16:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"Cli Zsh Oh-my-zsh Navi Screenfetch Htop ","date":"2019-12-30","objectID":"/softwares/:17:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"系统工具 BleachBit Redshift Deepin-wine Docker TimeShift：系统备份 Better and Better iStat Menus ","date":"2019-12-30","objectID":"/softwares/:18:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"邮件 Thunderbird Outlook ","date":"2019-12-30","objectID":"/softwares/:19:0","tags":null,"title":"软件","uri":"/softwares/"},{"categories":null,"content":"🤷‍♂️我 对网络知识有浓厚的兴趣 是一只会 Python🐍 的通信🐕 喜欢瞎折腾👨‍💻一些有用没用的东西 长期使用 Linux(Arch \u0026 Ubuntu 20.04) \u0026 Windows 10 工作学习 ","date":"2019-12-30","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"这个网站 本质上，就是我自己的笔记📔，某天突发奇想💭：做成网站也不错呀，随时都可以查看。于是就诞生了这网站。 网站文章使用 Markdown 撰写排版 网页利用 Hugo 渲染生成 页面由 LoveIt 装点 网站托管在 Vercel 套用了 jsDelivr 的 CDN 致谢 在此，感谢上述开发者 \u0026 公司。 ","date":"2019-12-30","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"本站的内容授权 版权说明 本站点发布内容默认采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议（CC BY-NC-SA 4.0）进行许可，即： 本授权条款允许您（用户）可以复制、发行、展览、表演、放映、广播或通过信息网络传播本站作品； 您必须以附加本站 URL (https://www.techkoala.top/) 的方式对作品进行署名； 若您改变、转变或更改本作品，仅在遵守与本作品相同的许可条款下，您才能散布由本作品产生的派生作品； 您不得为商业目的而使用本作品； 转载作品另行声明，遵守原作者授权协议，所有权利归原作者所有； 如果本站内容能帮到你，那是我极大的荣幸； ","date":"2019-12-30","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":["WirelessCommunication"],"content":" LTE 物理层概要 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:0:0","tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/"},{"categories":["WirelessCommunication"],"content":"下行共享信道的传输与接收 物理层下行数据传输包含了链路自适应的过程，基站根据终端所上报的链路质量信息（CQI/PMI/RI）选择适当的物理资源和相应的编码调制方式进行下行数据的发送，实现对系统下行无线资源的优化利用，达到最佳的性能。 信道状态信息反馈和下行链路自适应传输\" 信道状态信息反馈和下行链路自适应传输 物理层下行共享信道的传输包括了 调度信息（PDCCH） 数据信息（PDSCH） 在长度为 1ms 的子帧结构中，前面的 1 ～ 3 个 OFDM 符号用于传输下行控制信息，其中包括了传输数据调度信息的 PDCCH；而子帧中剩余的符号用于传输数据信息（PDSCH）。 下行数据传输的子帧结构\" 下行数据传输的子帧结构 在下行数据接收的过程中，终端对当前子帧中所有 PDCCH 信道进行盲检测，如果发现属于自己的调度信息，那么终端将根据该调度信息的指示（包括资源位置、编码调制方法等）解调接收当前子帧中属于自己的 PDSCH 数据信息。 下行数据的调度与传输\" 下行数据的调度与传输 物理层下行支持 29 种调制编码格式，其中包括了 QPSK、16QAM 和 64QAM 3 种不同的调制方式和不同的信道编码速率（范围是 0.16 ～ 0.92）。根据这样的原则，针对每一种物理资源 PRB 的占用数目，规范中定义了 29 种传输块大小（Tranport block size）。 在进行下行数据传输时，下行调度信息中使用 5 个比特对所调度数据使用的编码调制格式（MCS）进行指示。接收端根据该信息可以确定数据所使用的调制方式； 同时，将这 5 比特 MCS 信息和调度信息中所分配的 PRB 数目相结合，可以查表确定传输块大小，即信道编码数据源大小的信息，由此实现下行数据的正确传输与接收。 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:1:0","tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/"},{"categories":["WirelessCommunication"],"content":"上行共享信道的调度与传输 物理层上行数据的传输包含了链路自适应的调度过程。 首先，终端在上行发送 Sounding 导频 信号，基站利用该信号对用户上行信道的质量进行测量，根据测量的结果选择适当的物理资源和相应的编码调制方式，在上行资源调度信息中进行指示，终端根据基站的指示进行上行数据的发送，实现对系统上行无线资源的优化利用。 Sounding 导频和上行链路自适应\" Sounding 导频和上行链路自适应 上行共享信道的传输包括 上行调度信息（PDCCH） 数据信息（PUSCH） 根据 PDCCH 上行调度信息的指示，终端使用相应的资源进行上行数据的发送。与下行情况不同的是，在下行共享信道的传输过程中，调度信息与对应的数据信息处于同一个子帧内。而在上行的情况中，终端需要根据 PDCCH 调度信息的指示，进行上行数据的发送，因此二者之间存在一定的时延，考虑无线传播和设备处理时间的因素 FDD 中定义该时延的数值为 4ms，即对于在子帧 n 中接收到的 PDCCH 上行调度信息，终端将在子帧 n+4 进行对应的上行数据传输。 TDD 的情况中，在时延最小值等于 4ms 的前提下，还需要区分是上行或者下行子帧，因为只有在属于上行子帧的时间才能进行上行数据的发送。 上行数据的调度与传输\" 上行数据的调度与传输 与下行类似，物理层上行支持 29 种调制编码格式，其中包括了 QPSK、16QAM 和 64QAM 3 种不同的调制方式和不同的信道编码速率（范围是 0.16 ～ 0.92），使用与下行相同的传输块大小的表格定义，规定了在各种 PRB 数目的情况下，所对应的 29 种传输块大小（Transport block size）。 在进行上行数据传输时，上行调度信息中使用 5 个比特指示数据的调制编码格式（MCS），终端根据该信息可以确定所使用的调制方法（QPSK/16QAM/64QAM）；同时，将这 5 比特 MCS 信息和调度信息中所分配的 PRB 数目相结合，可以查表确定传输块大小，即信道编码数据源的大小。最后，终端进行信道编码、速率匹配的信号处理过程，实现上行数据的发送。 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:2:0","tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:3:0","tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/"},{"categories":["WirelessCommunication"],"content":" LTE 多址方式详解 ","date":"2019-10-20","objectID":"/lte_multiple_access/:0:0","tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/"},{"categories":["WirelessCommunication"],"content":"多址方式 LTE 的空中接口采用以 OFDM 技术为基础的多址方式，使用 15kHz 的子载波宽度，通过不同的子载波数目（72 ～ 1200 ）实现了从 1.4 ～ 20MHz 之间多种可变的系统带宽。另外，考虑到在不同应用场景的情况下，无线信道的多径传输具有不同的时延扩展特性，所以 LTE 支持两种不同循环前缀（Cyclic Prefix，CP）长度的配置：Normal CP 和 Extend CP，它们的长度分别约为 4.7μs 和 16.7μs。 在 OFDM 技术的基础上，根据下行和上行两个方向通信的不同特点，LTE 分别选择了多载波 OFDM 和单载波 SC-FDMA（即 DFT-SOFDM）作为多址方式的具体实现方法。 ","date":"2019-10-20","objectID":"/lte_multiple_access/:1:0","tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/"},{"categories":["WirelessCommunication"],"content":"下行多址方式 LTE 采用 OFDM（Orthogonal Frequency Division Multiplexing）作为下行无线信号传输的多址方式。OFDM 是一种多载波调制的传输技术，将数据流经过串并变换，形成多路子数据流（N 路），使用它们分别去调制 N 路子载波后并行传输。通过这样的处理，子数据流的速率是原来的 1/N，即符号周期是原来的 N 倍，使得该符号周期远大于信道的时延扩展，从而实现了将一个宽带频率选择性信道划分成 N 个窄带平坦衰落信道，因此 OFDM 信号具有很强的抗无线信道多径衰落和抗脉冲干扰的能力，并且由于实现方式简单，所以特别适用于高速无线数据传输。 OFDM 调制的信号处理流程\" OFDM 调制的信号处理流程 ","date":"2019-10-20","objectID":"/lte_multiple_access/:1:1","tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/"},{"categories":["WirelessCommunication"],"content":"上行多址方式 上行方向上，LTE 采用单载波 SC-FDMA（即 DFT-SOFDM） 作为多址方式。其中，同样采用了 15kHz 的子载波带宽，不同子载波数目实现不同的系统带宽。 DFT-SOFDM 调制的信号处理流程\" DFT-SOFDM 调制的信号处理流程 与 ODFM 中信号直接映射到频域的子载波上形成多载波信号不同，DFT-SOFDM 中信号由时域输入，通过 DFT 的操作转换到频域后再进行子载波的调制，因此 DFT-SOFDM 属于单载波的调制方式，其发射信号也具有单载波的特性。 在 OFDM 多载波调制中，由于多路信号在频域的并行传输，叠加后形成的时域输出信号具有较大峰均比。由于基站功率放大器的能力较强，因此在下行峰均比不会成为影响系统性能的主要问题。在上行方向上，考虑到终端的成本和功率效率，使用具有单载波特性的发送信号，这是因为较低的信号峰均比具有重要的意义。根据调制方式的不同（QPSK、16QAM），与 OFDM 相比较，单载波信号具有 1.5 ～ 2.5dB 的峰均比增益，这也是 LTE 选择单载波 SC-FDMA 作为上行多址方式的主要原因。 另一方面，为了使信号真正具有单载波的特性，DFT-SOFDM 调制过程中对于子载波的映射需要满足一定的限制。除了集中式的映射之外（此时，DFT-SOFDM 的信号处理过程相当于对输入信号进行时域的过采样），在分布式的映射中，为了保持单载波特性，DFT-SOFDM 调制必须采用等间隔的子载波映射，即 L1 =L2 =…=LN （此时，DFT-SOFDM 的处理过程相当于对输入信号进行时域的块重复），而不能够使用间隔不相等的分布式映射，因为那将破坏输出信号的单载波特性。 OFDM/DFT-SOFDM 的子载波映射\" OFDM/DFT-SOFDM 的子载波映射 ","date":"2019-10-20","objectID":"/lte_multiple_access/:1:2","tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-10-20","objectID":"/lte_multiple_access/:2:0","tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/"},{"categories":["WirelessCommunication"],"content":" LTE 物理层概要综列 ","date":"2019-09-15","objectID":"/lte_cell_synchronize/:0:0","tags":["LTE"],"title":"LTE 系列：小区搜索和下行同步","uri":"/lte_cell_synchronize/"},{"categories":["WirelessCommunication"],"content":"终端的小区搜索和下行同步 通过小区搜索的过程，终端实现对服务小区下行信号时间和频率的同步，并且确定小区的物理层 ID。 小区搜索过程\" 小区搜索过程 物理层小区搜索的过程主要涉及两个同步信号： 主同步信号（PSS） 辅同步信号（SSS） 过程中包括了 下行时间和频率的同步 小区物理 ID 的检测 OFDM 信号 CP 长度的检测（Normal 或者 Extended CP） 完成这些操作后，终端就可以开始读取服务小区的广播信道（PBCH）中的系统信息了。 通过同步信号的检测与服务小区获得同步以后，终端还可以利用下行导频信号（CRS），进行更精确的时间与频率的同步，以及同步的维持。 ","date":"2019-09-15","objectID":"/lte_cell_synchronize/:1:0","tags":["LTE"],"title":"LTE 系列：小区搜索和下行同步","uri":"/lte_cell_synchronize/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-09-15","objectID":"/lte_cell_synchronize/:2:0","tags":["LTE"],"title":"LTE 系列：小区搜索和下行同步","uri":"/lte_cell_synchronize/"},{"categories":["WirelessCommunication"],"content":" LTE 基本物理资源及分配方法 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:0:0","tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/"},{"categories":["WirelessCommunication"],"content":"基本物理资源 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:0","tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/"},{"categories":["WirelessCommunication"],"content":"物理资源块（PRB） 物理层定义了物理资源块（Physical Resource Block，PRB）作为空中接口物理资源分配的单位。1 个 PRB 在频域上包含 12 个连续的子载波，在时域上包含 7 个连续的 OFDM 符号（在 Extended CP 的情况下为 6 个），即 1 个 PRB 包括了频域宽度等于 180kHz、时间长度等于 0.5ms（1 个时隙）的物理资源。 物理资源块（PRB）的结构\" 物理资源块（PRB）的结构 通过设置不同的子载波数目可以映射到不同的资源块（PRB）数目。LTE Release 8 版本定义的 6 种不同的系统带宽与子载波数目以及 PRB 数目之间的对应关系如下表所示： 系统带宽与资源块数目\" 系统带宽与资源块数目 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:1","tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/"},{"categories":["WirelessCommunication"],"content":"逻辑资源块（VRB） 为了方便物理信道向空中接口物理资源的映射，在物理资源块（PRB）的基础上还定义了逻辑资源块（Virtual Resource Block，VRB）。 逻辑资源块的大小与物理资源块相同，即 1 个时隙（0.5ms）、12 个子载波。逻辑资源块主要定义了资源的分配方式，位于 1 个子帧内 2 个时隙的 2 个 VRB（即 VRB pair）是物理资源分配信令的指示单位。 逻辑资源块和物理资源块分别对应有各自的资源块序号 nVRB 和 nPRB 。 物理资源块 PRB 的序号 nPRB 按照频域的物理位置进行顺序编号 逻辑资源块 VRB 的序号 nVRB 是系统进行资源分配时所指示的逻辑序号，通过它与 PRB 序号之间的映射关系来进一步地确定实际物理资源的位置 物理层定义了两种类型的逻辑资源块： 集中式 VRB（Localized VRB，LVRB） LVRB 直接映射到 PRB 上，即 nPRB =nVRB 分布式 VRB（Distributed VRB，DVRB） DVRB 逻辑资源序号与物理资源序号具有一定的映射关系，可以表示为 nPRB =f(nVRB ，ns )，其中 0≤ns ≤19 是 1 个无线帧内的时隙序号。通常情况下，连续的 DVBR 序号将映射到不连续的 PRB 序号上，并且 1 个子帧内的 2 个时隙也有着不同的映射关系，即属于 1 个 DVRB pair 的两个具有相同逻辑序号的 DVRB 将映射到两个时隙不同频率位置的 PRB 上。通过这样的机制实现了分布式的资源分配 基于 VRB 的资源分配\" 基于 VRB 的资源分配 下行方向的信号传输，支持 LVRB 和 DVRB 的分配，具体采用的方式在下行资源的调度信令中进行指示 上行方向的信号传输，仅支持 LVRB 方式的资源分配 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:2","tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/"},{"categories":["WirelessCommunication"],"content":"资源单元组（REG） PRB 和 VRB 用于数据信道的资源分配和映射，物理层还定义了 REG（Resource Element Group）的概念，用于物理层下行控制信道的资源映射。 1 个 REG 对应除掉导频符号之外在频域上连续的 4 个物理资源。 资源单元组（Resource Element Group，REG）\" 资源单元组（Resource Element Group，REG） ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:3","tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:2:0","tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/"},{"categories":["WirelessCommunication"],"content":" 无线网络中的时延是如何一步步进化到 5G 中的 \u003c1ms ？ 注：本文系全文转载，原文信息如下： 作者：见微 链接：https://www.zhihu.com/question/307958274/answer/712266324 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2019-08-12","objectID":"/5g_time_delay/:0:0","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"网络延迟时间的定义 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:0","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"单向延迟 单向延迟指的是信息从发送方传到接收方的所花费的时间。 单向时间延迟\" 单向时间延迟 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:1","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"双向延迟 双向延迟（Round Trip Time, RTT）, 指的是信息从发送方到达接收方，加上接受方发信息给发送方所花费的总时间。双向延迟在工程中更加常见，因为我们可以只在信息发送方或者接收方的其中一方就可以测量到双向延迟（利用 ping 等工具）。 双向时间延迟\" 双向时间延迟 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:2","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"用户面时延 题主提到的 5G 网络 1 毫秒时间延迟最初是由 ITU IMT-2020 M.2410-0 （4.7.1）关于 IMT-2020 系统的设计最小需求中提到的。其适用的范围是 URLLC（Ultra reliable and low latency communication）超可靠且超低的时延业务，这里的时延是针对用户面时延。用户面时延是指我们平时使用手机发送数据的时间延迟，区别于控制面时延：手机注册网络或者状态转换经过的信令流程所花费的时间（控制面时延不做讨论）。 另外一点是 1 毫秒指的是无线网络 空中接口（手机和基站之间，不包括核心网，互联网等网络节点）的延迟时间。 用户面时间延迟\" 用户面时间延迟 明确了讨论的范围（无线网络空中接口的双向用户面时间延迟），接下来真正进入正题：网络空中接口的时间延迟是如何一步步降下来的。 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:3","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"4G 网络延迟 4G 网络（注：本文中提到的 4G 特指 LTE 网络）是从 2004 年开始标准化，2009 年开始商用网络部署，到现在已经历经了 10 余年的时间，是最成功的无线网络之一，已经在全球范围内广泛部署。 最初的 4G 网络主要关注的业务和应用是 MBB（Mobile broad band）移动带宽业务，通俗的讲就是提供更大的网络容量，更快的上网速度。从最初的 3GPP release8 到 release13 一直是沿着这条路走，标准定义的峰值速率从 300Mbps 到 25Gbps（载波聚合，MIMO，高阶调制方式）。当我们在速率更快这条路走得越来越远，才发现无线网络的时延水平也需要改善，时延还会从侧面影响下载的速率，谨慎的评估了 LTE 的无线网络的现状，空中接口的时间延迟是未来标准化组织重点关注的研究对象。 而在当时，LTE 网络的延迟状况是接近于～20ms 的双向时延。（理论延迟时间，实际根据无线环境情况一般会更长） LTE 网络空中接口上下行时延基线\" LTE 网络空中接口上下行时延基线 上图描述了 LTE 空中接口的上行（从终端到基站）和下行（从基站到终端）时延。 ","date":"2019-08-12","objectID":"/5g_time_delay/:2:0","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"上行时间延迟 上行时间延迟（从手机到基站）：当手机有一个数据包需要发送到网络侧，需要向网络侧发起无线资源请求的申请（Scheduling request, SR），告诉基站我有数据要发啦，基站接收到请求后，需要 3 毫秒时间解码用户发送的调度请求，然后准备给用户调度的资源，准备好了之后，给用户发送信息 (Grant)，告诉用户在某个时间某个频率上去发送他想要发送的数据，用户收到了调度信息之后，需要 3 毫秒时间解码调度的信息，并将数据发送给基站，基站收到用户发送的信息之后需要 3 毫秒的时间解码数据信息，完成数据的传送工作，整个时间计算下来是 12.5ms。 ","date":"2019-08-12","objectID":"/5g_time_delay/:2:1","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"下行时间延迟 下行时间延迟（从基站到手机）：当基站有一个数据包需要发送到终端，需要 3 毫秒时间解码用户发送的调度请求，然后准备给用户调度的资源，准备好了之后，给用户发送信息，告诉用户在某个时间某个频率上去接受他的数据，用户收到了调度信息之后，需要 3 毫秒时间解码调度的信息并接收解码数据信息，完成数据的传送工作，整个时间计算下来是 7.5ms。 所以总共的双向时延是 12.5ms+7.5ms = 20ms 详细的时间延迟组成请参考 3GPP 36.881 Study on latency reduction techniques for LTE（5.2.1） LTE 上行时间延迟组成（Source:3GPP 36.881 Study on latency reduction techniques for LTE）\" LTE 上行时间延迟组成（Source:3GPP 36.881 Study on latency reduction techniques for LTE） LTE 下行时间延迟组成（Source:3GPP 36.881 Study on latency reduction techniques for LTE）\" LTE 下行时间延迟组成（Source:3GPP 36.881 Study on latency reduction techniques for LTE） 从 20 毫秒开始，到 1 毫秒要走过怎样的路？ 当 LTE 标准化组织 3GPP 意识到网络的时间延迟是一个问题，而且具有很大的潜在提升的时候，相关的工作拉开了序幕。 时间来到了 2015 年，3 月初，中国上海，乍暖还寒，在 3GPP RAN 67 次会议上，终于迎来了关于减少 LTE 网络时间延迟的研究项目（SI）立项（RP-150465 New SI proposal: Study on Latency reduction techniques for LTE）。本次研究项目的立项旨在减小 LTE 网络的时间延迟，因为在此以前 LTE 网络一直向着速率更快的方向在发展，但是网络的延迟水平一直没有得到改善，而研究发现用户面网络延迟的改善能够提升网络的速率瓶颈（因为 TCP 的慢启动效应，改善 TCP 握手的时延，从而提升网络的速率），而且能够更好地支持更多对于时延要求特别高的应用，比如：VR，实时游戏，VoIP，视频会议等等。 改善 LTE 无线时延水平以支持更多的应用 （Source: Ericsson, Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication, IEEE cscn2017）\" 改善 LTE 无线时延水平以支持更多的应用 （Source: Ericsson, Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication, IEEE cscn2017） 有了提升的意愿，通过什么方式提升？要解决一个问题，需要 全面的了解问题本身。 ","date":"2019-08-12","objectID":"/5g_time_delay/:2:2","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"网络延迟的组成 LTE 网络空中接口的用户面网络延迟主要由以下及部分组成：资源调度请求和指派（Grant acquisition），传输时间间隔（Transmission time interval），终端和基站的数据包以及信令处理时间（Processing），混合重传来回时间（HARQ RTT）。 经过研究，终端和基站的数据包的处理时间根据数据包的大小时间不同，这块时延很难大幅度改善，主要的提升方向放在了前两部分：资源调度请求和指派（Grant acquisition），传输时间间隔（Transmission time interval），同时这两部分也是未来 5G 网络延迟改善的方向。 ","date":"2019-08-12","objectID":"/5g_time_delay/:3:0","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"资源调度请求和指派 终端在需要传送上行数据的时候需要先给基站发送资源调度请求，然后基站才会分配相关的资源给终端，终端收到相应的指派信令后再在相关的资源上去发送上行的数据，整个过程下来，从手机有发送数据的意愿到真正开始向基站传数据，花了 8.5ms，相对于整个上行的单向时延 12.5ms 来说，是相当大的一部分时间延迟。所以研究的重点转向了怎样使用户不用通过上行资源的请求流程，直接就能想发送数据就发送数据？ ","date":"2019-08-12","objectID":"/5g_time_delay/:3:1","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"传输时间间隔 传输时间间隔，是网络处理数据，请求的最小时间单位，在 LTE 中传输时间间隔等于 1 毫秒，也就是一个无线子帧。如何缩小传输的时间间隔也是改善时延的研究重点。 ","date":"2019-08-12","objectID":"/5g_time_delay/:3:2","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"如何改善 LTE 网络的时延？ 对于资源调度请求和指派这个方向，在 LTE release 14 以前，设备厂家普遍采用预调度（Pre-scheduling）的方式来改善延迟，这种办法的主要思想在于：基站周期性的给终端用户分配好相应的无线资源，终端在有数据要发送的时候直接就能在预先分配好的无线资源上发送，无需再向网络侧请求资源，所以减少了整个资源请求流程的时间。但是这种办法有一些缺点： 不管终端用户是否使用预先调度的无线资源，始终会分配给用户。造成了宝贵无线资源的浪费。 终端用户在接收到无线资源调度后，如果没有数据发送，始终会使用已经分配的无线资源上传填充数据（padding data），这样会造成网络的干扰水平抬升，影响了网络的整体性能。而且手机的耗电量也增加了。 LTE 预调度（Pre-scheduling）\" LTE 预调度（Pre-scheduling） 似乎探索有了方向… 光阴如梭，整整一年后，2016 年 3 月初，瑞典哥德堡，3GPP RAN 71 次会议，关于真正网络延迟减少工作立项了（RP-160667 L2 latency reduction techniques for LTE），此次工作项目的立项标志着网络延迟减少工作的正式开启。所要着手解决的主要集中在改善上行的网络延迟，而解决问题的思想是和预调度类似的 半静态调度，提前为终端周期性的分配好相关的无线资源，用户在需要传送上行数据的时候直接使用已经预先分配好的资源，无需再进行资源请求流程。而在这个版本中引入了更短的半静态调度周期，低至一毫秒，从而能进一步改善时间延迟。 同时针对预调度中分配了无线资源终端就得发送数据的问题（造成网络干扰和电量消耗），通过 Release 14 标准的改善，使用户即使分配了无线资源，也可以不发送填充数据。 至此，上行的网络传输延迟大大减少。根据仿真的结果，LTE 空中接口双向传输时延降至～8ms 更短的半静态调度周期\" 更短的半静态调度周期 上行不用发送 Padding 数据\" 上行不用发送 Padding 数据 手机的能耗也下降了～10% 时延减少的同时对手机耗电量的改善 (Source: 3GPP R2-153490 L2 enhancements to reduce latency)\" 时延减少的同时对手机耗电量的改善 (Source: 3GPP R2-153490 L2 enhancements to reduce latency) 同时网络时延的改善也从侧面提升了终端的速率～30%-40% 时延减少的同时对终端速率提升 (Source: 3GPP R2-153490 L2 enhancements to reduce latency, Ericsson)\" 时延减少的同时对终端速率提升 (Source: 3GPP R2-153490 L2 enhancements to reduce latency, Ericsson) 但是，真的这样就足够了吗？No，通信人止于至善。 以上只是解决问题的其中一个角度，针对另一个角度 改善传输间隔时间 能做点什么？ 3 个月后，又又又开会了，韩国釜山，RAN 72 次会议，立项了关于从改善 LTE 网络传输间隔时间从而减少网络时延的工作（RP-161299 New Work Item on shortened TTI and processing time for LTE），改善的方法得从 LTE 的无线帧结构说起。 无线网络的传输介质是时间和频率资源，终端在分配的时间和频率上发送相应的数据，在通信的世界里，时间的单位很短很短，一个 LTE 帧是 10 毫秒，可以分为 10 个子帧，每个子帧 1 毫秒，这就是网络最小可以调度的时间单位：1 毫秒。 1 个子帧还可以分为两个时隙，每个时隙还可以分为 7 个符号，至此，终于分完。 Short transmission time interval (sTTI) 减少传输时延\" Short transmission time interval (sTTI) 减少传输时延 以前 LTE 网络每次的传输时间间隔是固定一个子帧 = 1 毫秒，上图红色部分是控制信道，用于传输无线资源指派等信令，绿色部分是下行数据信道，用于传输数据。本次工作要做的是将传输时间间隔从子帧级别（1ms) 降低至符号级别（1/14 ms），最小的调度间隔根据情况可以选择 3/2 个符号（3/14ms, 2/14ms），7 个符号（7/14ms），具体的子时隙 (subslot) 细分方式如下图。从而又进一步降低了整个 LTE 无线网络空口的时延。 4G LTE sTTI 上下行可选配置方式（Source: URLLC Services in 5GLow Latency Enhancements for LTE, Thomas Fehrenbach, Rohit Datta）\" 4G LTE sTTI 上下行可选配置方式（Source: URLLC Services in 5GLow Latency Enhancements for LTE, Thomas Fehrenbach, Rohit Datta） 在 LTE release 15 中，还降低了 处理（procession）时间 (收到上行资源 grant 到上行传输数据的时间，以及从收到下行指派到反馈 HARQ ACK/NACK 指示的时间)，以前需要 4ms，降至了 3ms。 R15 处理时间的减少从 n+4 到 n+3 ms（Source: 3GPP TR 21.915 Summary of Rel-15 Work Items）\" R15 处理时间的减少从 n+4 到 n+3 ms（Source: 3GPP TR 21.915 Summary of Rel-15 Work Items） 2018 年，到 LTE release 15 时，所有的大招都用上，LTE 的网络延迟理论上可以降至双向 2.7 毫秒（下行 0.7 毫秒 + 上行 2.0 毫秒） LTE 用户面时延（Source: URLLC Services in 5GLow Latency Enhancements for LTE, Thomas Fehrenbach, Rohit Datta）\" LTE 用户面时延（Source: URLLC Services in 5GLow Latency Enhancements for LTE, Thomas Fehrenbach, Rohit Datta） 至此，LTE 的无线网络延迟改善到头了。 那么梦寐以求的一毫秒时间延迟怎么实现？剩下的使命需要 5G 来完成。 ","date":"2019-08-12","objectID":"/5g_time_delay/:3:3","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"5G 网络延迟 和人一样，一项技术也有自己的命运，LTE 从应运而生到如今的如日中天已经走过了 10 多个春秋，正如之前在另一个问题中讨论的从专业角度讲，为什么需要开展 5G 而不是继续提升 4G？ 因为 4G LTE 从出生伊始已经注定了其时间延迟的下限，而这个下限如今也已经被我们触摸到了。下一步需要我们转向一项延迟下限更低的技术去找寻极限。 5G 是站在巨人（4G）的肩膀上诞生的，从系统设计之初就将网络时间延迟的特性考虑了进来，成为 5G 需求的一部分: URLLC（Ultra reliable and low latency communication）超低的时延和超高可靠的通信以支持对时延和可靠性要求极高的行业应用，比如智能工厂，远程手术，自动驾驶等等。这部分的需求在 5G 的第一个版本 Release 15 中满足了一部分。 关于超低的时延：1ms 的无线空中接口双向传输时延是怎么一步步实现的呢？ 5G URLLC 满足极低时延极高可靠业务（Source: Ericsson, Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication, IEEE cscn2017）\" 5G URLLC 满足极低时延极高可靠业务（Source: Ericsson, Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication, IEEE cscn2017） 2016 年，3GPP 开始了 5G 的需求分析和研究项目，为了满足 ITU 所设置的 URLLC 极高的可靠性和极低的时延要求，在 5G 的需求研究项目 TR38.913 Study on scenarios and requirements for next generation access technologies 中的用户面 KPI 中针对 URLLC 业务用户面时延定义了上行 0.5ms 和下行 0.5ms 的要求，加起来正好是 1ms 的双向时延。 需求的定义明确了，接下来进入了研究如何实现技术需求的阶段，2016 年 3 月，3GPP TSG RAN 71 次会议通过了 TR38.912 Study on New Radio (NR) access technology ，这项研究工作致力于提出可行的无线技术来满足 ITU-2020 制定的 5G 需求。而从研究项目伊始，URLLC 就做为一项不可缺少的 5G 需求被考虑进来。 从 2016 年的研究项目开始到 2018 年中第一版本 5G 标准（release 15 NSA\u0026SA）的出炉，低时延的设计贯穿了整个 5G 无线系统，我们就从用户面的每个层（物理层 PHY，媒体接入控制层 MAC，无线链路控制层 RLC）看看为了实现 1ms 的目标都做了怎样的努力。 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:0","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"物理层 5G 中物理层的主要作用是：编解码，调制 / 解调，多天线映射等。 虽然本回答主要讨论的是低时延的系统架构设计，但是低时延是与 URLLC 的另一部分需求：极高的可靠性（99.999%）被共同捆绑在一起的。如果单单考虑低时延会比低时延高可靠简单很多，因为要满足极高的可靠性惯常采用更多的控制信令开销，重传，冗余，这些手段往往会提升时间延迟的水平。所以如何在保证可靠性的同时改善时延水平在物理层的设计中是难上加难。5G 物理层用了哪些手段来改善时延呢？ 5G 用户面协议层\" 5G 用户面协议层 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:1","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"包结构（Packet structure） 在 4G LTE 的时延分析中提到过的系统处理时间在时延中所占的分量比较大，而且改善较为不易。这部分时延包括了接收包，获取控制信息，调度信息，解调数据，以及错误检测。在 4G LTE 中是采用下图左侧这种方形的包结构，传输的信息分为三部分，导频信息（Pilot），控制信息（control information），以及数据（data）。这种设计方式被广泛的用来对抗信道衰落。但是在 5G 中 URLLC 包采用的是下图右侧这种设计方式，导频信息，控制信息，以及数据依次在时域上排列，这样做的好处是信道估计，控制信道解码，数据的获取可以串行的进行，通过这样的方式这样减少了处理时间。 4G LTE 和 5G URLLC 包结构对比 （Source: Ultra Reliable and Low LatencyCommunications in 5G Downlink: PhysicalLayer Aspects）\" 4G LTE 和 5G URLLC 包结构对比 （Source: Ultra Reliable and Low LatencyCommunications in 5G Downlink: PhysicalLayer Aspects） 从手机收到资源分配（Grant）指令到数据的传输时间要求如下，中间部分是 5G 不同子载波间隔（Subcarrier Spacing）配置下的不同要求： 从手机收到资源分配（Grant）指令到数据的传输时间要求（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson）\" 从手机收到资源分配（Grant）指令到数据的传输时间要求（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:2","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"信道编码 4G LTE 采用 Turbo 和 Simple code 来编解码数据达到无线传输的可靠性。在 5G 中使用的是 LDPC 和 Polar 码来提升数据和控制信道的编解码效率，经过编码界研究的不懈努力，编解码的性能和计算复杂度的提升对于降低时延也有所帮助。 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:3","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"更短的传输时间间隔（可变的 Numerology） 从更短的时间间隔这点说 5G 是天生丽质一点都不为过，LTE 规定的一个子载波 (传送信息的最小频域单位) 是 15KHz，时间域是 1ms （正常情况下）。5G 所需要支持的频率范围非常广，中低频从 450MHz~6000MHz（FR1），高频从 24.25GHz~52.6GHz（FR2）。高频意味着更高的相位噪声，所以需要设计更加宽的子载波间隔来抵御相位噪声的干扰。更宽的子载波间隔，意味着时域上更短的时隙，更短的传输时间间隔，我们在 4G LTE 时代千方百计想要降低的传输时间间隔在 5G 时代只需要使用更高的频段，更宽的子载波间隔就轻而易举的降低了。而且根据不同的频段可以选择从 15KHz, 30KHz 到 120KHz 的子载波间隔，可以简单的理解为，5G 子载波间隔相比于 LTE 15KHz 增加了多少倍，那么在时域上的传输时间间隔就减少相应的倍数。 频域子载波间隔成倍增加，时域符号时长相应倍数减少（Source: Ultra Reliable and Low LatencyCommunications in 5G Downlink: PhysicalLayer Aspects）\" 频域子载波间隔成倍增加，时域符号时长相应倍数减少（Source: Ultra Reliable and Low LatencyCommunications in 5G Downlink: PhysicalLayer Aspects） 不同子载波间隔（sub-carrier spacing）对应的无线帧结构\" 不同子载波间隔（sub-carrier spacing）对应的无线帧结构 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:4","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"微时隙调度（Mini-slot） 微时隙调度继承了 LTE 中减小传输时间间隔 (subslot) 的设计理念，将最小的传输时间间隔由子帧拓展到了符号上。第一优先级最小的调度间隔根据情况可以选择 2 个符号，4 个符号，7 个符号。下图是一个下行数据传输的示例，数据包到达了基站，基站经过 4 个符号的处理以及等待合适的 sPDCCH 时间，随后通过两个符号的微时隙调度将数据传输给用户。 下行微时隙调度\" 下行微时隙调度 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:5","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"MAC（媒体接入控制）层 MAC 的作用是多路逻辑信道的复用，HARQ（混合重传），以及调度相关的功能。关于时延的改善的技术在 MAC 层有：异步 HARQ（异步混合重传） 当无线环境出现问题等原因造成传输的数据出错，在 MAC 层会由 HARQ 功能来发起重新传输流程，在 LTE 中，HARQ 的时间间隔（从收到数据到发送反馈给发送方是否正确接收信息指令）是固定的（FDD，TDD 根据子帧结构变化）。 而在 5G 中，HARQ 的时间间隔是动态指派的，更加的灵活，也符合低时延的设计要求。 5G 与 4G HARQ 流程时间对比： 5G 与 4G LTE HARQ 时延对比（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson）\" 5G 与 4G LTE HARQ 时延对比（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:6","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"上行免调度传输 （Grant free transmission） 和 4G LTE 一样，5G 可以周期性的给用户分配上行资源（半静态调度）来减少上行的传输时延，而且 5G 更加进了一步。在 4G 中半静态调度的资源一般是给每个用户单独分配的，所以当网络中用户较多的时候，造成的浪费是非常大的，因为预留的无线资源终端不一定会使用。 在 5G 中可以将预留资源分配给一组终端用户，并且设计了当多个用户同时在相同的无线资源上发生冲撞的解决机制。这样在降低时延的同时使宝贵的无线资源的利用率也得到了保证。 5G 上行免调度传输 type1 和 type2 （Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson）\" 5G 上行免调度传输 type1 和 type2 （Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:7","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"预清空调度（Downlink preemption Scheduling） 预清空调度的意思是为某个高优先级的用户清空原来已经分配给其他用户的资源，打个比方，我们去餐馆吃饭，没有位置了，餐馆老板认识我们是高级 VIP，所以把一桌正在吃饭的人赶走了，把桌子留给了咱们。 通过这样的方式达到了对时间延迟要求高的用户可以立即传输数据，从而降低了时延。下图是一个示例： 用户 A 已经在一个时隙上被调度了数据，但是这时用户 B 被标记为对时延要求高的数据需要传输。 如果这时有空闲的时频域资源可用，用户 B 会被优先调度空闲的资源 但是如果此时网络负荷较大，没有空闲的资源可用，用户 B 就会抢占其他用户的（例如用户 A）的资源。 这种方式有个弊端就是会影响原本被分配资源的 A 的用户的数据传输（在被用户 B 抢占的资源上），当然优秀的 5G 系统也设计了方案来解决这个问题，方式有：HARQ 重传用户 A 受影响的传输数据，或者是直接通过控制信令（DCI2-1）通知用户 A，哪些传输的数据受到了影响。 下行预清空调度示例（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson）\" 下行预清空调度示例（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:8","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"RLC（无线链路控制）层 RLC 层主要负责 RLC 数据的切分，重复数据去除，RLC 重传的工作。 在 RLC 层中关于低时延的技术考量主要体现在：在 4G LTE 中 RLC 层还需要负责保证数据的按顺序传递（In-sequence delivery），即前面的包没有向上层传递之前，排在后面的包需要等待。在 5G 中去掉了这样的功能要求来保障低时延水平。这样做的好处是，如果之前有某些包因为某些原因（例如无线环境突然变差）丢失了需要重传，在 5G 中后面的包不需要等到前面的包重传完毕就可以直接向上层传递。 那么通过以上关键技术的组合，是怎么一步步使 5G 无线网络时间延迟降低到 1 毫秒的呢？ 无线网络空中接口双向时延演进\" 无线网络空中接口双向时延演进 通过使用 30KHz 的子载波间隔，上行免调度，以及两个符号的微时隙的 5G 系统配置方案，可以达到低于双向时延 1ms 以下的要求。如果采用 5G 高频通信，使用 120KHz 的子载波间隔，时延可以更低。 至此，1ms 梦寐以求的目标终于达成，但是科技工作者们仍没有停下探索的脚步，目前的研究转向了 5G 物理层的增强对 URLLC 业务的支持，而新的研究项目也已经成功立项并完成：Study on physical layer enhancements for NR ultra-reliable and low latency case (URLLC), 在下一版本 5G release 16 中，URLLC 将从 PDCCH，UCI，PUSCH（上下行控制信道以及上行数据信道）获得更多的提升。同时还研究支持对时延和可靠性要求极高的工业互联网应用 Study on NR industrial Internet of Things (IoT)。探索为什么 5G 能降低网络时间延迟到 1ms 完结，但是需要引起注意的是，我们这里讨论的延迟是整个网络中的一部分，特指空中接口。但是网络的传输时延绝不是空中接口单一接口就能够保证的，还涉及到端到端的核心网以及互联网。剩下这部分属于 TSN（Time Sensitive Networking）的范围，什么是 TSN，怎么将无线 URLLC 和 TSN 结合起来为工业 4.0 服务，下次有机会再聊。 无线网络的低时延高可靠特性结合 TSN 为工业互联网服务（Source：Boosting smart manufacturing with 5G wireless connectivity, Ericsson）\" 无线网络的低时延高可靠特性结合 TSN 为工业互联网服务（Source：Boosting smart manufacturing with 5G wireless connectivity, Ericsson） 历史的有趣之处就在于：总是在起起伏伏，跌跌撞撞中前行，不断的循环，却又惊人的相似。对比 5G 中时延减少的思路，很多都和 4G 类似。而从 4G 一路看过来，才不会乱花渐欲迷人眼。20 毫秒到 1 毫秒，这么短，却又那么长，背后是无数通信工作者夜以继日，年复一年，默默无闻的贡献自己的力量。 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:9","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":"参考 [1] ITU-R M.2410-0 Minimum requirements related to technical performance for IMT-2020 radio interface (s) [2] 3GPP 38.913 Study on scenarios and requirements for next generation access technologies [3] 3GPP 36.881 Study on latency reduction techniques for LTE [4] RP-150465 New SI proposal: Study on Latency reduction techniques for LTE [5] RP-160667 L2 latency reduction techniques for LTE [6] RP-161299 New Work Item on shortened TTI and processing time for LTE [7] R2-153490 L2 enhancements to reduce latency [8] Thomas Fehrenbach, Rohit Datta, URLLC Services in 5G Low Latency Enhancements for LTE [9] 38.913 Study on scenarios and requirements for next generation access technologies [10] TR38.912 Study on New Radio (NR) access technology [11] Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication IEEE cscn2017 [12] Ultra Reliable Low Latency Communication for 5G New Radio [13] Ultra Reliable and Low Latency Communications in 5G Downlink: Physical Layer Aspects [14] ErikDahlman, JohanSkold, StefanParkvall, Ericsson，NR: the next generation wireless access technology [15] 3GPP TS38.824 Study on physical layer enhancements for NR ultra-reliable and low latency case (URLLC) [16] 3GPP TR38.825 Study on NR industrial Internet of Things (IoT) [17] Boosting smart manufacturing with 5G wireless connectivity [18] 3GPP TR 21.915 Summary of Rel-15 Work Items ","date":"2019-08-12","objectID":"/5g_time_delay/:5:0","tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/"},{"categories":["WirelessCommunication"],"content":" LTE 上行链路帧结构详细讲解 LTE 使用 SC (单载波)-FDMA 作为上行链路信号。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:0:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"时隙结构 从下面的时隙结构可以看出，LTE 上下行链路的时隙结构是相似的： 上行时隙结构\" 上行时隙结构 与下行链路相同，上行链路中的帧时间和时隙时间与下行链路中相同。并且资源块结构和下行链路上也相同。如上所述，在一个时隙中的 7 个符号在上行链路和下行链路上也是相同的。 你可能会注意到的一点区别是每个物理信道的位置。在下行链路情况下，信道通常占用整个带宽，但是上行链路时隙中的信道更局限。例如，PUCCH 仅位于整个带宽中的的最低端和最高端。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUCCH RS 携带解调 PUCCH 所需的参考信号。这意味着如果此部分配置不正确或 eNodeB 检测不到此部件，则 eNodeB 无法解码 PUCCH。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:1","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUCCH 此信道可以承载大量信息(UCI)，但根据配置的不同，它只能承载以下信息中的一部分： ACK/NACK for the recieved PDSCH data CQI RI PMI 正如你在时隙结构中看到的，PUCCH 以子帧内两个时隙之间交替的方式位于上行链路频域的两端，这意味着如果 PUCCH 是时隙 0 (第一个时隙) 中的频域的最低部分，并且它将位于时隙 1 (第二个时隙) 中的频域的最高部分。分配给 PUCCH 的资源元素的确切数量由网络确定，并且配置通过 SIB2 广播到 UE。 详细的 PUCHH 结构参考： PUCCH Format PUCCH Format 1,1a,1b Location PUCCH Format 2,2a,2b Location ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:2","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUSCH RS 携带解调 PUSCH 所需的参考信号。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:3","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"PUSCH 承载 UE 尝试发送的上行链路数据。并且除了上行链路数据之外，还可以携带 UE 接收的 PDSCH 的 ACK/NACK。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:4","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"SRS 参考 SRS in Quick Reference ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:5","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"上行资源网格 具体来说，上行资源还有一种网格格式，如下所示: 上行资源网格\" 上行资源网格 最小的单元是 “资源元素 (RE)”，最小的资源分配单元是 RB (资源块)，它沿时域跨越 7 RE，沿频域跨越 12 RE。 这意味着一个 RB 有 84 个单元 (7x12)。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:2:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"通信中的信道 下图显示了上行/下行数据传输的总体顺序。你可以将数据传输序列图与 DL/UL 帧结构中每个通道的特定位置相关联。 LTE 上下行传输顺序图\" LTE 上下行传输顺序图 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:3:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"帧结构总览 上行帧结构概览\" 上行帧结构概览 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:4:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"参考 [1] UL FrameStructure ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:5:0","tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/"},{"categories":["WirelessCommunication"],"content":" LTE 物理信道详解 ","date":"2019-08-05","objectID":"/lte_physical_channels/:0:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"广播信道（PBCH） 物理广播信道（Physical Broadcast CHannel，PBCH）用于承载系统的 MIB 广播信息。 LTE 系统广播信息分为 MIB（Master Information Block） 系统基本的配置信息，在 PBCH 固定的物理资源上进行传输 MIB 数据块的总长度为 40 比特，包含 24 个信息比特和 16 个 CRC 比特（以加扰的方式携带关于基站发射天线数目（1/2/4）的信息）。信息比特中包括： 下行系统带宽指示（3 比特） PHICH 资源指示（3 比特） 系统帧号 SFN（8 比特） 预留的 10 个比特 MIB 信息的传输周期 TTI=40ms，在位于每个 10ms 无线帧的第一个子帧的 PBCH 信道上传输。MIB 数据块经过信道编码、速率匹配和加扰后，得到 1920 比特，映射到 40ms 内，间隔为 10ms 的 4 个子帧的 PBCH 信道的物理资源上。其中，每一个 PBCH 子帧都是可自解码的，也就是说假设信道质量足够好的话，终端可以通过 4 次中的任意一次的接收即可解调出 MIB 信息。 LTE 物理广播信道\" LTE 物理广播信道 SIB（System Information Block） PBCH 信道位于每个 10ms 无线帧的第一个子帧，占用 4 个连续的 OFDM 符号，在频域上占用下行频带中心 1.08MHz 的带宽。也就是说，对于各种不同的系统带宽（1.4MHz、3MHz、5MHz、10MHz、15MHz、20MHz），物理广播信道 PBCH 的传输带宽相同，总是占用频带中心的 1.08MHz 带宽（72 个子载波）。物理广播信道 PBCH 频域结构。 物理广播信道 PBCH 频域结构\" 物理广播信道 PBCH 频域结构 当发射天线为 2/4 的时候，PBCH 采用发送分集（SFBC/SFBC+FSTD）的方式。在资源映射的时候，为了方便终端在不知道发射天线数目情况下的盲检测，对 1、2 或者 4 的发射天线数目，使用相同的物理资源映射方式，即总是空出 4 天线的小区公用导频 CRS 资源。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:1:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"下行共享信道（PDSCH） 下行物理共享信道（Physical Downlink Shared CHannel，PDSCH）用于下行数据的调度传输，是 LTE 物理层主要的下行数据承载信道，可以承载来自上层的不同的传输内容（即不同的逻辑信道），包括： 寻呼信息 广播信息 控制信息和业务数据信息 作为决定物理层性能的关键因素之一，PDSCH 的传输支持各种物理层机制，包括信道自适应的调度，HARQ 和各种 MIMO 机制。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:2:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"控制格式指示信道（PCFICH） 物理控制格式指示信道（Physical Control Format Indicator CHannel，PCFICH）指示物理层控制信道的格式。 在 LTE 中，物理层控制信道（PDCCH）在每个子帧的前几个 OFDM 符号上传输，根据系统物理层控制信息负载情况的不同，该数值可能是 1、2 或者 3（在使用最小值 1.4MHz 的系统带宽的时候，为了提供足够的物理层控制信息的容量，也可以设置为 4）。PCFICH 信道正是对该数值进行了指示，即在当前子帧中，前几个 OFDM 符号用于物理层控制信道 PDCCH 的传输。 PCFICH 指示当前子帧中 PDCCH 的符号数目：1、2、3（当系统带宽 1.4MHz 的时候，取值为 2、3、4）。 PCFICH 的基带处理过程如图所示，其携带的 3 种可能性通过编码映射得到 32 比特的信息，经过 QPSK 调制后形成 16 个调制符号，这 16 个调制符号将映射到子帧第 1 个 OFDM 符号上的 4 个资源单元组 REG 上（每个 REG 包含 4 个 RE，可以承载 4 个调制符号）。为了获得充分的分集增益，这 4 个 REG 均匀地分布在系统下行带宽上。可以注意到，其中频域的起始位置 k 与小区 ID 相关，因此不同小区的 PCFICH 将形成相对的频域偏移，避免不同小区的 PCFICH 之间的干扰。 物理控制信道格式指示信道（PCFICH）\" 物理控制信道格式指示信道（PCFICH） PCFICH 信道采用的发射天线与 PBCH 相同，即 1、2 或者 4。当发射天线数目为 2 或者 4 的时候，使用 SFBC/SFBC+FSTD 的发送分集方式。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:2:1","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"HARQ 指示信道（PHICH） 物理 HARQ 指示信道（Physical HARQ Indicator CHannel，PHICH）承载对上行数据传输的 HARQ ACK/NACK 反馈信息。 物理层 PHICH 信道的传输以 PHICH 组的形式来组织，1 个 PHICH 信道由 PHICH 组编号和组内编号共同确定。 1 个 PHICH 组内的多个 PHICH 信道占用相同的时频域物理资源，采用正交扩频序列的复用方式。 在 Normal CP 的情况下，采用扩频因子为 4 结合 I/Q 两路 BPSK 调制的复用方式，1 个 PHICH 组占用 12 个调制符号（3 个 REG），可以复用 8 个 PHICH 信道 在 Extended CP 时，针对频率选择性较强的无线信道，采用扩频因子为 2 结合 I/Q 两路 BPSK 调制的复用方式，1 个 PHICH 组占用 6 个调制符号，可以复用 4 个 PHICH 信道，此时，2 个 PHICH 组共同占用 3 个 REG 的物理资源 PHICH 信道的基带处理过程如图所示，1 个比特的 ACK/NACK（0/1）信息使用重复编码的方式得到 3 个比特的编码后信息，然后经过 BPSK 调制以及系数为 4 的扩频操作，得到 12 个符号，映射在 PHICH 组所对应的 3 个 REG 的物理资源位置上。 物理 HARQ 指示信道（PHICH）\" 物理 HARQ 指示信道（PHICH） 在频域上，1 个 PHICH 组对应的 3 个 REG 采用分布式的映射方式，以获得分集增益 在时间上，PHICH 有正常（normal）和扩展（extended）两种资源映射方式 在采用正常方式的时候，PHICH 信道映射在子帧的第一个 OFDM 符号上； 当 PDCCH 的长度为 3 时（在混合载波的 MBSFN 子帧或者 TDD 特殊子帧中，PDCCH 长度为 2 时），PHICH 可以配置为采用扩展的方式，此时每 1 个 PHICH 信道将分布在 PDCCH 所占用的多个 OFDM 符号上。 在 PCFICH 所指示的前 n 个 OFDM 符号中，除了用于 PCFICH 和 PHICH 传输的资源外，其余的将用于 PDCCH 的传输。 为了确定用于 PDCCH 的资源，需要先确定用于 PCFICH 和 PHICH 的资源，其中 PCFICH 的资源是固定的，而用于 PHICH 传输的资源数目则由系统在 PBCH 广播信息进行半静态的指示。MIB 信息中有 3 个比特用于 PHICH 资源的指示，其中包括了正常或者扩展两种时间长度以及 PHICH 组数目 4 种可能性的指示。 PHICH 信道发射天线的数目与 PBCH 相同，当发射天线数目为 2、4 的时候采用 SFBC/SFBC+FSTD 的发送分集方式。 PHICH 信道的索引号与上行数据传输的资源位置相对应，也就是说，不需要采用信令进行指示，根据上行 PUSCH 数据传输的资源位置就可以确定下行 PHICH 信号的索引号。 具体来说，由相应的上行 PUSCH 数据传输使用的第 1 个物理资源块 PRB 的序号所确定。另外，为了使得各个 PHICH 组中实际使用的 PHICH 信道数量的负载均衡，相邻的上行 PRB 位置对应于不同 PHICH 组中的 PHICH 信道。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:2:2","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"下行控制信道（PDCCH） 下行物理控制信道（Physical Downlink Control CHannel，PDCCH）用于承载物理层的下行控制消息，包括： 上／下行数据传输的调度信息 上行功率控制命令信息 PDCCH 信道的传输以控制信道单元（Control Channel Element，CCE）的形式来组织，1 个 CCE 由 9 个 REG 组成（即 9×4=36 个 RE）。根据所占用的 CCE 数目的不同，标准中定义了 4 种 PDCCH 格式，分别占用 1、2、4、8 个 CCE，相应的数值又称为 PDCCH 的聚合等级（Aggregation Level）。 一个下行子帧可以承载多个 PDCCH 信道，各个 PDCCH 信道进行独立的 CRC 计算、加扰、信道编码并根据 Aggregation Level 进行速率匹配。然后，一个子帧中所有的 PDCCH 信道将复用为 1 个数据比特流，对该数据流进行填充，使各个 PDCCH 信道符合定义的 CCE 起始位置的规则（Aggregation Level 为 n 的 PDCCH 的起始位置为 n 整数倍的 CCE 位置）；并且使填充后的数据比特流长度能够充满分配给 PDCCH 的 OFDM 符号的所有资源（除去 PCFICH 和 PHICH）。然后，对形成的数据流进行加扰、调制和多天线映射。最后映射到分配给 PDCCH 的物理资源上。 在 PDCCH 数据流向物理资源的映射过程中，包含了交织的操作，数据流以 REG（4 个调制符号）为单位进行交织。通过交织的资源映射，每个 PDCCH 信道能够获得充分的分集增益。 下行物理控制信道（PDCCH）\" 下行物理控制信道（PDCCH） PDCCH 信道的发射天线与 PBCH 相同，即 1、2 或者 4。当发射天线数目为 2、4 的时候采用 SFBC/SFBC+FSTD 的发送分集方式。 终端对 PDCCH 信道的接收采用盲检测的方式，即终端根据所使用的下行控制信息（DCI）的格式，解调所有可能属于自己的下行 PDCCH 信道，搜索属于自己的信息。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:3:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"随机接入信道（PRACH） 物理随机接入信道（Physical RandomAccess CHannel，PRACH）用于终端上行发送随机接入信号（random access preamble），启动随机接入的过程。 随机接入信号由 循环前缀（Cyclic Prefix，CP） 接入序列（Sequence） **保护时间（Guard Time，GT） ** 3 个部分组成。 物理随机接入信道\" 物理随机接入信道 根据适用的场景的不同（例如：小区半径和链路的功率预算），LTE 物理层支持 5 种随机接入信号格式，具体使用过程中，由高层信令指示小区所使用的随机接入信道的配置。 随机接入信号格式\" 随机接入信号格式 其中格式 4 的随机接入信号仅用于 TDD Type 2 中，当 TDD 配置特殊时隙 UpPTS 的长度为 2 个 OFDM 符号时，可以在 UpPTS 的位置发送格式 4 的随机接入信号，以较小的开销实现随机接入的功能。 在频域上，PRACH 占用 6 个 PRB（1.08MHz）的带宽。以 Format 0 为例，PRACH 信号的生成方式如图所示，信号占用的带宽为 1 048.75kHz，不足 1.08MHz 的部分作为频域的保护带。 PRACH preamble 生成方法（Format 0）\" PRACH preamble 生成方法（Format 0） LTE 物理层使用 Zadoff-Chu 序列作为生成随机接入信号的序列。每个小区有 64 个可用的序列，由小区的下行广播进行指示。 小区中分配给上行随机接入信道的物理资源位置由高层信令进行指示。在关于小区随机接入信道配置的信息中，指示了使用的 PRACH 格式以及物理资源的位置。 对于 FDD Type 1，每个时刻最多传输一个 PRACH 信道，即没有频分复用。结合配置信息中指示的PRACH 信道的时间位置和PRACH 信道频率位置的信息，可以确定小区中 PRACH 信道的时频资源位置。 例如：设置使用 PRACH Format 0，周期等于 10ms，时间偏移量等于 1 个子帧，频率位置等于 1，那么小区中用于 PRACH 信道的物理资源位置 随机接入信道的物理资源位置\" 随机接入信道的物理资源位置 对于 TDD Type 2，除了在 UpPTS 上支持 PRACH Format 4 的发送之外，同一个时刻还可能传输多个频分的 PRACH 信道。 TDD Type 2 中频分的 PRACH 信道\" TDD Type 2 中频分的 PRACH 信道 因为 TDD 支持不同的上下行时间比例的配置，在某些配置情况下上行时间较少，所以可能需要在同一个时刻支持多个 PRACH 信道，以提供足够的随机接入信道的容量。在普通子帧中，由于上行两边频带存在 PUCCH 控制信道，而中间是 PUSCH 数据信道，因此 PRACH 信道采用频率偏移结合上下交错的分配方式为 PUCCH 和 PUSCH 信道留出物理资源空间。而对于 PRACH Format 4，由于特殊时隙 UpPTS 上不存在 PUCCH 或者 PUSCH 信道，因此采用了不同的机制：从上行频域的边际开始，连续分布，在两次 UpPTS 之间采用跳频的方式，即交替地从上边带或者下边带开始，这样可以在随机接入信号需要多次传输的时候获得频率分集的增益。 TDD Type 2 中 PRACH Format 4 的频分与跳频\" TDD Type 2 中 PRACH Format 4 的频分与跳频 ","date":"2019-08-05","objectID":"/lte_physical_channels/:4:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"上行控制信道（PUCCH） 上行物理控制信道（Physical Uplink Control CHannel，PUCCH）传输物理层上行控制信息，包括上行调度请求、对下行数据的 ACK/NACK 信息和信道状态信息 CSI 反馈（包括 CQI/PMI/RI）。 每 1 组 PUCCH 信道占用 1 个 RB-pair 的物理资源，采用时隙跳频的方式，在系统上行频带的两边进行传输，而上行频带的中间部分用于传输上行共享信道（PUSCH）的数据。 PUCCH 信道的资源分布\" PUCCH 信道的资源分布 根据所承载的上行控制信息，物理层设计了不同的 PUCCH 格式，对应于不同的发送方法。 PUCCH 信道不同的格式\" PUCCH 信道不同的格式 根据不同格式的 PUCCH 信道的特点，它们在频域的分布情况如图所示。 不同格式 PUCCH 信道在频域的分布情况\" 不同格式 PUCCH 信道在频域的分布情况 PUCCH 2/2a/2b 承载的是信道状态 CSI 的反馈信息，在系统配置中，这一部分资源的数量是相对固定的，因此将它们分布在频带的最外侧，资源的具体数量通过高层信令进行半静态的指示。 PUCCH 1/1a/1b 承载的是调度请求信息和对下行数据的 ACK 信息，资源数量是动态变化的，与小区中发送的下行数据的数量相关，因此将这一部分资源放置在稍靠近频率中心的位置，方便将系统剩余的频率资源用于上行共享信道 PUSCH 的传输。 在所占用的 1 个 RB-pair 的时频域资源中，PUCCH 1/1a/1b 和 PUCCH 2/2a/2b 都采用了码分的方式进一步地复用多个 PUCCH 信道。因此当配置的 PUCCH 2/2a/2b 信道数量所占用的资源数目不是 RB-pair 整数倍的时候，在 PUCCH 2/2a/2b 和 PUCCH 1/1a/1b 频域的交界处将出现它们在某 1 个 RB-pair 内以码分的方式混合传输的情况。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:5:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"PUCCH 格式 1/1a/1b PUCCH 格式 1/1a/1b 用于终端发送调度请求信息或者1、2 比特的 ACK/NACK 信息。 使用一个调制符号 $d(0)$ 来表示 PUCCH 1/1a/1b 发送的信息。对于 PUCCH 1 的调度请求信息，基站侧仅需要检测是否存在这样的发送，此时的 $d(0)$ 设置为预定义的固定值（d(0)=1）。对于 PUCCH 1a/1b 的 ACK 信息，$d(0)$ 为 BPSK 或者 QPSK 调制符号，分别对应于 1 比特或者 2 比特的 ACK 信息。 在信息的发送过程中，首先使用正交扩频序列 $w(m)$ 进行扩频，将信息分散在一个时隙内用于 PUCCH 传输的多个上行符号上；然后，在每个上行符号上使用 1 个长度为 12 的 Zadoff-Chu 序列 $r_{u,v}^{\\alpha}$ 进行调制，得到长度为 12 的复数序列对应于 1 个 RB 内的 12 个子载波。因此，PUCCH 1/1a/1b 的发送包含了**正交扩频序列**和**Zadoff-Chu 序列**两次码扩频的过程，可以复用的信道数目为二者的乘积。 例如：在使用 Normal CP 的情况下有 3 个正交扩频序列，而所使用的 Zadoff-Chu 序列的长度为 12，假设设置 Zadoff-Chu 序列循环移位（Cyclic Shift）的复用间隔为 2，那么 1 个 RB-pair 上可以复用 3×6=18 个 PUCCH 1/1a/1b 信道。 PUCCH 1/1a/1b 物理层信号发送方法（Normal CP）\" PUCCH 1/1a/1b 物理层信号发送方法（Normal CP） 为了增强信号的随机性，在 PUCCH 1/1a/1b 的发送过程中包含了跳频的概念。包括两种跳频： 子帧内的 2 个时隙使用不同的正交扩频序列 $w(m)$，即正交序列跳频 时隙内的不同上行符号之间使用 Zadoff-Chu 序列不同的循环移位，即Cyclic Shift 跳频 ","date":"2019-08-05","objectID":"/lte_physical_channels/:5:1","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"PUCCH Format 2/2a/2b PUCCH 格式 2 用于终端发送信道状态信息（Channel State Information，CSI），包括： 信道质量指示（Channel Quality Indicator，CQI） 预编码向量指示（Precoding Matrix Indicator，PMI） 复用秩的指示（Rank Indicator，RI） 在 Normal CP 的情况下，PUCCH 格式 2 还可以扩展成 PUCCH 格式 2a/2b，在这两种格式中，通过对 PUCCH 格式 2 中的导频符号进行调制，在 CSI 信息的基础上，进一步承载 1 或者 2 比特的 ACK/NACK 信息。 CSI 信息经过信道编码和加扰后形成长度为 20 比特的数据流，经过 QPSK 调制后形成 10 个调制符号（d(0)，…，d(9)），在 PUCCH Format 2/2a/2b 上发送。 PUCCH Format 2/2a/2b 信息的发送过程与 PUCCH Format 1/1a/1b 类似，只是没有了扩频的操作，因为要发送更多的比特信息。 对于要发送的调制符号信息 d(0)，…，d(9)，在每个符号上使用长度为 12 的 Zadoff-Chu 序列 $r_{u,v}^{\\alpha}$ 进行调制，然后将各个符号调制的结果映射在子帧内相应上行符号 1 个 RB 内的 12 个子载波上。通过长度为 12 的 Zadoff-Chu 序列的不同循环移位来进行同一个 RB 内不同 PUCCH 2/2a/2b 信道的复用。 假设设置 Zadoff-Chu 序列循环移位的复用间隔为 2，那么 1 个 RB-pair 上可以复用 6 个 PUCCH 2/2a/2b 信道。 PUCCH 2/2a/2b 物理层信号发送方法（Normal CP）\" PUCCH 2/2a/2b 物理层信号发送方法（Normal CP） 在 PUCCH 2a/2b 中，除了 20 个比特的 CSI 信息之外，还承载 1 或者 2 比特的 ACK 信息。该 ACK 信息将通过 BPSK 或者 QPSK 的调制，形成一个调制符号 d(10)，然后调制在导频符号上进行传输。 PUCCH 2a/2b 仅适用于 Normal CP 的情况，对于 Extended CP 的情况，由于 PUCCH 格式 2 的每个时隙内只有 1 列上行导频，难以将 ACK/NAK 信息调制在导频中。所以，在这种情况下，如果 ACK/NAK 和 CQI 需要同时传输，那么将对它们进行联合编码，形成 20 比特的编码后数据，采用 Extended CP 的 PUCCH 格式 2 进行发送。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:5:2","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"上行共享信道（PUSCH） 上行物理共享信道（Physical Uplink Shared CHannel，PUSCH）用于上行数据的调度传输，是物理层主要的上行数据承载信道，可以承载来自上层的不同的传输内容（即不同的逻辑信道），包括： 控制信息 用户业务信息 与下行物理共享信道 PDSCH 相似，PUSCH 信道是决定系统上行数据传输性能的关键，因此，PUSCH 的传输支持各种物理层机制，包括信道自适应的调度、HARQ 等。 值得一提的是，上行物理层采用单载波（DFT-SOFDM）作为多址方式，这样的多址方式对终端上行功率效率方面带来好处的同时也带来了一些限制。 例如：为了保持上行单载波的特性，LTE Release 8 物理层不支持单用户的上行共享信道（PUSCH）和上行控制信道（PUCCH）的频分复用，即 1 个用户不能在一个时刻同时发送 PUSCH 信道和 PUCCH 信道。当用户有上行数据 PUSCH 正在发送的时候，如果需要同时发送物理层上行控制信息（CSI、ACK 或者 RI），那么这些信息不能在 PUCCH 信道上传输，而是将这些控制信息与数据信息一起复用在 PUSCH 信道上进行传输。 另外，单载波（DFT-SOFDM）多址方式的处理过程中包含了 DFT 的操作，为了降低 DFT 运算的复杂度，便于使用类似 FFT 的快速算法，标准中对上行 PUSCH 信道子载波分配的数目进行了规定，即上行分配的 RB 数目的数值必须能够被 2、3、5 这 3 个质数所分解，即必须满足条件$=2_{α2}、3_{α3}、5_{α5}$，其中 $α2 、α3 和 α5$ 是非负整数。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:6:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-08-05","objectID":"/lte_physical_channels/:7:0","tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/"},{"categories":["WirelessCommunication"],"content":" 概述 LTE 信息帧中的各类物理通道和信号 在 此前的一篇文章 中，我们详细了解 LTE 下行链路的帧结构，其中包含了各种物理信道和信号，本文将会做一个概要性的讲述，用作一个速查表。 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:0:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PBCH Physical Broadcast Channel，物理广播通道 它只携带 MIB (master information block，主系统信息块) 它使用的是 QPSK 映射到 6 个资源块（72 个子载波），以 0 号子帧中的 DC 子载波为中心 映射到不为传输参考信号、PDCCH 或 PCHICH 而保留的资源元素 详情参考 Physical Layer : PBCH 和 Matlab Toolbox : PBCH 页面（待填坑） ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:1:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PCFICH Physical Control Format Indicator Channel，物理控制格式指示通道 它映射到每个下行链路子帧中的第一个 OFDM 符号 它包含了携带控制信道（PDCCH 和 PHICH）的 OFDM 符号数量的信息。UE 对该信道进行解码，以找出该帧中为控制信道（PDCCH 和 PHICH）分配了多少个 OFDM 符号 它是子帧的第一个 OFDM 符号的 16 个数据子载波 PCFICH 数据由 4 个 REG 承载，并且这 4 个 REG 均匀分布在整个频带上，与带宽无关 PCFICH 的确切位置由小区 ID 和带宽确定 详细信息参阅 Physical Layer : PCFICH 和 Matlab Toolbox : PCFICH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:2:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PDCCH Physical Downlink Control Channel，物理下行控制信道 映射到下行链路每个子帧中前 L 个 OFDM 符号 PDCCH 的符号数（L）可以是 1,2 或 3 PDCCH 的符号数由 PCFICH 指定 PDCCH 承载 DCI，而 DCI 承载传输格式，资源分配，与 DL-SCH，UL-SCH 和 PCH 相关的 H-ARQ 信息以及其他取决于 DCI 格式的信息 PDCCH 还携带用于 UL 调度分配的 DCI 0（例如，UL 授权） 可以在单个子帧中分配多个 PDCCH，并且 UE 对所有 PDCCH 进行盲解码 调制方案是 QPSK PDCCH 类似于 HSDPA 的 HS-SCCH、R99 的 PDCCH 和 HSUPA 的 E-AGCH/E-RGCH 即使 PDCCH 具有很多功能，但并非所有功能都同时使用，因此 PDCCH 配置应灵活设置 如果您对该通道中的详细信息映射感兴趣，请参阅 36.211 中的 6.8.1。简要说明如下： 物理下行链路控制信道承载调度分配和其他控制信息。物理控制信道是在一个或几个连续的控制信道元素（CCE）的聚合上发送的，其中控制信道元素对应于 9 个资源元素组。未分配给 PCFICH 或 PHICH 的资源元素组的数量为 REG N。系统中可用的 CCE 从 0 和 N_CCE-1 编号，其中 N_CCE = floor（N_REG/9）。 详细信息参阅物理层 Physical Layer : PDCCH 和 Matlab Toolbox : PDCCH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:3:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PHICH Physical Hybrid ARQ Indicator Channel，物理 HARQ 指示信道 对收到的 PUSCH 进行 H-ARQ 反馈 UE 在 UL 中传输数据后，等待 PHICH 进行 ACK 类似于 HSPA 中的 E-HICH 某些情况下，几个 PHICH 使用相同的资源元素构成 PHICH 组 详细信息参见 Physical Layer : PHICH 和 Matlab Toolbox : PHICH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:4:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PDSCH Physical Downlink Shared Channel，物理下行共享信道 携带用户特定的数据（DL 有效负载） 携带随机访问响应消息 它使用带有 QPSK，16 QAM，64 QAM，256 QAM 调制方案的 AMC（此调制方案由 DCI 承载的 MCS 确定） 详细信息参见 Physical Layer : PDSCH 和 Matlab Toolbox : PDSCH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:5:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"PRACH Physical Random Access Channel，物理随机接入信道 携带随机访问前导码 它在频域中占用 72 个子载波（6 RB）的带宽 在该信道内是随机访问前导，该随机访问前同步码用 Zadoff-Chu 序列 生成 详细信息参见 RACH 和 Matlab Toolbox : PRACH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:6:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"P-SS Primary Synchronization Signal，主同步信号 映射到 72 个活动子载波（6 个资源块），以时隙 0（子帧 0）和时隙 10（子帧 5）中的 DC 子载波为中心。 由 62 个 Zadoff-Chu 序列值 组成 用于下行帧同步 决定 物理小区 ID 的关键因素之一 详细信息参见 Physical Layer : PSS 和 Matlab Toolbox : PSS 页面 如何从基带捕获的 IQ 数据序列中找到 PSS 的确切位置？是定时同步中最重要的部分之一；也是理解 LTE 协议中非常棘手的部分之一，需要花费很长时间进行研究。 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:7:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"S-SS Secondary Synchronization Signal，副同步信号 SSS 是用于无线电帧同步的特定物理层信号，它具有以下列出的特征： 映射到 72 个活动子载波（6 个资源块），以 FDD 中的时隙 0（子帧 0）和时隙 10（子帧 5）的 DC 子载波为中心 子帧 0 中的 SSS 序列与子帧 5 中的 SSS 序列互不相同 由 62 个加扰序列（基于 m 序列）组成 奇偶索引的资源元素的值由不同方程生成 用于下行帧同步 决定 物理小区 ID 的关键因素之一 详细信息参见 Physical Layer : SSS 和 Matlab Toolbox : SSS ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:8:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS Reference Signal，参考信号 大多数信道（例如，PDSCH，PDCCH，PBCH 等）都用于承载特殊信息（比特序列），它们与更高层的信道相连，但是参考信号是仅存在于 PHY 层的特殊信号，不用于传递任何特定信息。参考信号的目的是为下行链路功率提供参考点。 当 UE 尝试计算 DL 功率（即，来自 eNode-B 的信号的功率）时，它将测量参考信号的功率并将其作为下行链路小区功率。 这些参考信号由每个时隙中的多个特定资源元素承载，并且资源元素的具体位置由天线配置确定。 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - Cell Specific 在下图中，红色/蓝色/绿色/黄色是承载参考信号的部分，灰色标记的资源元素是为参考信号保留的部分，但未承载该特定天线的参考信号。（插图基于 36.211 的图 6.10.1.2-1： 下行链路参考信号的映射（正常循环前缀）） 小区特定参考信号\" 小区特定参考信号 以下是 4 天线情况下物理信道配置和 RE（资源元素）映射的示例。测量结果来自 LTE 信号分析仪，它测量从 LTE 网络模拟器传出的 LTE 信号。它仅显示 20 Mhz 系统带宽中的一个 RB（RB0）（总共 100 个 RB），并且分别在 LTE 网络发送 MIB/SIB 和 UE 未连接时在天线端口 0、1、2、3 处捕获。你会注意到，每个天线的参考信号位置都不同。 由于此参考信号位置的差异，REG 分组可能由 PCFICH 的不同位置中略有不同。 各天线小区特定参考信号\" 各天线小区特定参考信号 有两种不同类型的参考信号：小区特定参考信号和 UE 特定参考信号 小区特定参考信号（CRS）：该参考信号在每个子帧处被发送，并且跨越整个工作带宽，通过天线端口 0、1、2、3 发送。 UE 特定参考信号：此参考信号在仅分配给特定 UE 的资源块中传输，并通过天线端口 5 传输。 特定于小区的参考信号的资源元素是否固定？ 否，位置会根据物理小区 ID 进行更改，如下所述： 参考信号的时域索引（l）= 固定（l = [0,4]） 参考信号的频域索引 k 根据 36.211 6.10.1.2 映射到资源元素中指定的物理小区 ID 而变化。 主要规则是：$k = 6m + (v + v_{shift})mod 6$，其中 v_shift=物理小区 ID mod6。详细信息参阅 36.211 6.10.1.2 下行参考信号携带什么样的值？ 该值是 36.211 6.10.1.1 序列生成中定义算法生成的伪随机序列。该序列的确定值之一是物理小区 ID，这意味着物理小区 ID 也影响参考信号的值。 CRS 是否以任何子帧类型（类型 1、2、3）传输？ 对于帧结构类型 1，在所有下行链路子帧中发送 CRS。 对于帧结构类型 2，在所有下行链路子帧和 DwPTS 中发送 CRS 对于帧结构类型 3，CRS 在非空子帧中传输 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:1","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - MBSFN 下图基于 36.211 的图 6.10.2.2-1：MBSFN 参考信号的映射（扩展循环前缀，Δf= 15 kHz） Reference Signal - MBSFN\" Reference Signal - MBSFN ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:2","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - UE Specific 下图基于 36.211 的图 6.10.3.2-1：特定于 UE 的参考信号，天线端口 5（正常循环前缀）的映射 Reference Signal - UE Specific - Antenna Port 5\" Reference Signal - UE Specific - Antenna Port 5 Reference Signal - UE Specific - Antenna Port 5\" Reference Signal - UE Specific - Antenna Port 5 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:3","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - Positioning 下图基于 36.211 的图 6.10.4.2-1：定位参考信号的映射（正常循环前缀） Reference Signal - Positioning - Antenna Port 6\" Reference Signal - Positioning - Antenna Port 6 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:4","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"RS - CSI 下图基于 36.211 的图 6.10.5.2-1：CSI 参考信号的映射（CSI 配置 0，常规循环前缀） Reference Signal - CSI - Antenna Port 15,16,17,18,19,20,21,22\" Reference Signal - CSI - Antenna Port 15,16,17,18,19,20,21,22 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:5","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"全帧快照 下图展示了上述提及的所有物理信道在整个框架上的整体图像： Full Frame\" Full Frame ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:10:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"通信过程中的物理信道 下图显示了上行/下行数据传输的总体顺序： 数据传输序列图\" 数据传输序列图 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:11:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"附加图 Spectrogram - LTE FDD DL - Radio Frame\" Spectrogram - LTE FDD DL - Radio Frame Spectrogram - LTE FDD DL - PBCH\" Spectrogram - LTE FDD DL - PBCH Spectrogram - LTE FDD DL - PSS/SSS\" Spectrogram - LTE FDD DL - PSS/SSS Spectrogram - LTE FDD DL - Each Symbol\" Spectrogram - LTE FDD DL - Each Symbol ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:12:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"另见 LTE 系列：物理信号 LTE 系列：物理信道 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:13:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":"参考 [1] Physical Channels and Signals [2] LTE 的信道 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:14:0","tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/"},{"categories":["WirelessCommunication"],"content":" LTE 下行链路帧结构详细讲解 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:0:0","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"下行帧结构 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:0","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"FDD——类型 1 36.211 中 FDD LTE 的帧结构概览图如下所示： FDD 帧结构\" FDD 帧结构 上图仅显示了帧在时域上的结构，而没有显示频域上的结构。 从图中可以看处： 一帧（一个无线帧，一个系统帧）的持续时间是 10 ms。 一帧（10 毫秒）的样本数是 307200（307.200 K）。 一帧中有 10 个子帧。 一个子帧中有 2 个时隙。 那么一个时隙是时域上最小的结构吗？不，如果进一步放大此结构，则会得到下图： 时隙结构\" 时隙结构 可以观察到一个时隙由 7 个符号组成。（一个符号是信号的某个时间跨度，在 I/Q 星座中的一个点。） 在符号的开头，还有一个很小的跨度，称为循环前缀，其余部分是真实的符号数据。 LTE 中有两种不同类型的循环前缀。一种是普通循环前缀；另一个是扩展循环前缀，其长度比普通循环前缀更长。（由于一个时隙的长度是固定的且不能更改，因此，如果使用扩展循环前缀，则一个时隙内则只能有 6 个符号）。 继续放大子帧以可以观察到确切的时间和采样，如下图所示： 符号结构\" 符号结构 此图中显示的长度不随采样率而变化，但是每个符号和 CP 中的采样数随采样率而变化。此图中显示的样本数基于 30.72 Mhz 采样率的情况。 关于上述子帧结构，需要注意的几件事是： 时隙中的第一个 OFDM 符号比剩下的 OFDM 符号长一些。 上图中显示的样本数基于以下参数设置：采样率为 30.72M 个样本/秒和 2048 个 bin/IFFT（$N_{ifft}$）。实际采样率和 $N_{ifft}$ 可能会随系统带宽而变化，需要根据特定带宽来缩放。 每种系统带宽的典型 $N_{ifft}$ 如下: System BW Number of RBs $N_{ifft}$ (bins/IFFT) 1.4 6 128 3.0 15 256 5.0 25 512 10.0 50 1024 15.0 75 2048 20.0 100 2048 下图是LTE 资源网格的总体子帧结构： LTE 资源网格\" LTE 资源网格 以下显示所有 4 个天线信号叠加（重叠）的理想情况下的下行链路帧结构和 RE（Resource Element，资源元素）映射的示例。 4天线帧结构和 RE 映射示例\" 4天线帧结构和 RE 映射示例 实际上，来自每个天线的信号具有略微不同的符号数据和参考信号位置。 RE 映射的顶部和底部显示的星座图是 LTE 信号分析器测量来自 LTE 网络模拟器的 LTE 信号的测量结果。这是在 LTE 网络正在传输 MIB/SIB 且 UE 未连接的情况下在天线端口 0 处捕获的。如果您使用不同的信道功率（例如 PCFICH 功率，PDCCH 功率，CRS 功率等）执行类似的操作，则可能会看到一些不同的星座图。 现在我们进一步放大结构，但这一次是在频域而不是时域扩展。我们将获得以下完整的详细图： 下行帧结构物理信道\" 下行帧结构物理信道 如上所述，我们可以在二维图中表示 LTE 信号。横轴是时域，纵轴是频域。纵轴上的最小单位是子载波，横轴上的最小单位是符号。时域和频域多个较小单位组合成较大单位。 首先让我们看一下频域结构： LTE（无论 OFDM/OFDMA）频带由多个小间隔信道组成，这些小信道称为子载波。 无论 LTE 频带的系统带宽是多少，子载波间隔都相同。 如果 LTE 信道的系统带宽发生变化，则信道数（子载波）会发生变化，但信道之间的间隔不会发生变化。 子载波和下一个子载波之间的空间是多少？ 15 Khz 20 Mhz LTE 频段的信道（子载波）数量是多少？ 1200 个子载波。 10 Mhz LTE 频段的信道（子载波）数量是多少？ 600 个子载波。 5 Mhz LTE 频段的信道（子载波）数量是多少？ 300 个子载波。 接着我们看一下横轴（即时域）的上的基本组成单位。时域上的最小单位是符号，长度为 66.7 us。无论带宽如何，符号长度都不会改变。 一个时隙中有多少个符号？ A\u003e 7 个符号。 一个子帧中有多少个符号？ A\u003e 14 个符号。 一个帧中有几个时隙？ A\u003e 20 个时隙。 现在，让我们看一下由时域（横轴）和频域（竖轴）组成的单位。我们将此类型的单元称为二维单元。 最小的二维单位是 RE，它由时域中的一个符号和频域中的一个子载波组成。另一个二维单位是 RB（Resource Block，资源块），它由时域中的一个时隙和频域中的 12 个子载波组成。RB 是 LTE 中协议侧和 RF 测量侧最重要的单元。 一个资源块中有多少个符号？ 7 个符号。 一个资源块中有多少个子载波？ 12 个子载波。 一个资源块中有多少资源元素？ 84 个资源元素。 那么 20 Mhz 频带中有多少资源块？ 100 个资源块。 10 Mhz 频带中有多少资源块？ 50 个资源块。 5 Mhz 频带中有多少资源块？ 25 个资源块。 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:1","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"TDD——类型 2 TDD 帧结构\" TDD 帧结构 以下是使用 Sandesh Dhagle’s Resource Grid Tools 生成的各种配置的 TDD UL/DL 资源分配图。 类别 颜色 PDCCH 橙色 PBCH 蓝色 PSS 紫色 SSS 浅蓝色 PDSCH 白色 Reserved 黑色 Ref Signal 红色 PCFICH 浅绿色 PHICH 黄色 TDD Uplink 绿色 Guard Period 灰色 Configuration 0, Special Subframe Config 0\" Configuration 0, Special Subframe Config 0 Configuration 1, Special Subframe Config 0\" Configuration 1, Special Subframe Config 0 Configuration 2, Special Subframe Config 0\" Configuration 2, Special Subframe Config 0 Configuration 3, Special Subframe Config 0\" Configuration 3, Special Subframe Config 0 Configuration 4, Special Subframe Config 0\" Configuration 4, Special Subframe Config 0 Configuration 5, Special Subframe Config 0\" Configuration 5, Special Subframe Config 0 Configuration 6, Special Subframe Config 0\" Configuration 6, Special Subframe Config 0 下面展示具有不同特殊子帧配置的资源网格的示例。在这些示例中，仅注意子帧 0 和子帧 6 中的符号结构如何变化。 Configuration 0, Special Subframe Config 0\" Configuration 0, Special Subframe Config 0 Configuration 0, Special Subframe Config 1\" Configuration 0, Special Subframe Config 1 Configuration 0, Special Subframe Config 2\" Configuration 0, Special Subframe Config 2 Configuration 0, Special Subframe Config 3\" Configuration 0, Special Subframe Config 3 Configuration 0, Special Subframe Config 4\" Configuration 0, Special Subframe Config 4 Configuration 0, Special Subframe Config 5\" Configuration 0, Special Subframe Config 5 Configuration 0, Special Subframe Config 6\" Configuration 0, Special Subframe Config 6 Configuration 0, Special Subframe Config 7\" Configuration 0, Special Subframe Config 7 Configuration 0, Special Subframe Config 8\" Configuration 0, Special Subframe Config 8 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:2","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"LAA——类型 3 从 3GPP Rel 13 开始，提出了一种新的帧结构，主要应用于 LAA（License Assisted Access，许可辅助访问），与 LTE-U 一样，这也是一种在未经许可的频率范围内传输 LTE 信号的技术。 然而，与 LTE-U 不同的是，LAA 使用一种特殊的物理层帧结构，称为帧结构类型 3，这是以前不存在的。这种新的帧结构旨在使 LTE 信号类似于 WLAN 突发，并使 LTE 信号更好地与现有的 WLAN 业务共存。更多详情参见 LAA。 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:3","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":"参考 [1] Frame Structure - Downlink [2] Sandesh Dhagle’s Resource Grid Tools ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:2:0","tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/"},{"categories":["WirelessCommunication"],"content":" LTE 无线帧结构详解 ","date":"2019-07-08","objectID":"/lte_frame_structure/:0:0","tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/"},{"categories":["WirelessCommunication"],"content":"无线帧结构 物理层定义了无线帧的结构，LTE 支持两种帧结构： Type 1 ，用于 FDD Type 2，用于 TDD 1 个无线帧的长度为 10ms，分为 10 个长度等于 1ms 的子帧。 LTE 空中接口物理资源分配的最小时间单位是 1 个传输时间间隔（Transmission Time Interval，TTI），1 个 TTI 的长度是 1 个子帧，即 1ms。 在 Type 1 FDD 帧结构中，1 个 10ms 的无线帧分为 10 个长度为 1ms 的子帧（Subframe），每个子帧由两个长度为 0.5ms 的时隙（Slot）组成。 Type 1 FDD 帧结构\" Type 1 FDD 帧结构 在 Type 2 TDD 帧结构中，1 个 10ms 的无线帧分为两个长度为 5ms 的半帧（Half Frame），每个半帧由 5 个长度为 1ms 的子帧组成，其中包括 4 个普通子帧和 1 个特殊子帧。普通子帧由两个 0.5ms 的时隙组成，而特殊子帧由 3 个特殊时隙（UpPTS、GP 和 DwPTS）组成。 Type 2 TDD 帧结构\" Type 2 TDD 帧结构 Type 2 TDD 的特殊时隙\" Type 2 TDD 的特殊时隙 GP（Guard Period）是 TDD 上下行转换的保护间隔。 TDD 双工方式的系统中，由于信号的传输时延和设备收发的转换时延，为了避免上下行信号之间的干扰，需要在上下行转换的时候设置一定的保护时间间隔。 设备收发的转换时延：指的是终端／基站在发送／接收状态间转换的设备时延，典型值在 10 ～ 20μs 之间 信号的传输时延：主要与小区的覆盖半径相关，需要根据系统规划进行相应的设置。在 Release 8 版本的系统设计中，支持 GP 长度在 71 ～ 714μs 范围之内的不同设置，相对应的最大小区半径为 7 ～ 100km DwPTS（Downlink Pilot Time Slot）用于下行信号的发送，根据不同的配置，DwPTS 的长度可以是 3 ～ 12 个 OFDM 符号。LTE TDD 系统的主同步信号位于它的第 3 个符号，DwPTS 中的其他资源用作正常的下行控制信道和下行共享信道的发送。 UpPTS（Uplink Pilot Time Slot）用于上行信号的发送，它的长度可以配置为 1 ～ 2 个 OFDM 符号，UpPTS 可以用于承载物理随机接入信道（PRACH Format 4）和 Sounding 导频信号。 Type 2 TDD 帧结构支持 7 种不同的上下行时间比例分配（即配置 0 ～ 6），可以根据系统业务量的特性进行设置。 这 7 种配置包括 3 种 5ms 周期和 4 种 10ms 周期的情况: 5ms 周期的配置中，每个长度为 5ms 半帧包含 1 个下行到上行的转换时间间隔 GP 10ms 周期的配置中，每个长度为 10ms 的无线帧包含 1 个或者 2 个下行到上行的转换时间间隔 GP 在系统广播消息 SIB1 中使用 3 个比特指示 TDD 上下行时间比例的配置信息。 LTE Type 2 TDD 上下行时间配比的配置\" LTE Type 2 TDD 上下行时间配比的配置 ","date":"2019-07-08","objectID":"/lte_frame_structure/:1:0","tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/"},{"categories":["WirelessCommunication"],"content":"另见 LTE 系列：下行链路帧结构 LTE 系列：上行链路帧结构 ","date":"2019-07-08","objectID":"/lte_frame_structure/:2:0","tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-07-08","objectID":"/lte_frame_structure/:3:0","tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/"},{"categories":["WirelessCommunication"],"content":" LTE 物理层概要综列 ","date":"2019-06-28","objectID":"/lte_physical_layer/:0:0","tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/"},{"categories":["WirelessCommunication"],"content":"物理层的功能 物理层位于无线接入网协议的最底层，以传输信道为接口，通过传输信道向物理信道的映射，物理层向上层提供数据传输的服务。 物理层的主要功能包括： 传输信道向物理信道的映射 调制与解调 纠错编码与速率匹配 向高层报告数据是否正确传输 多天线的处理 功率控制 频率和时间的同步 射频信号的生成 ","date":"2019-06-28","objectID":"/lte_physical_layer/:1:0","tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/"},{"categories":["WirelessCommunication"],"content":"物理层的关键技术 物理层的包含以下关键技术： 多址方式 无线帧结构 基本物理资源及分配方法 数据的编码、复用和交织 多天线技术（MIMO） ","date":"2019-06-28","objectID":"/lte_physical_layer/:2:0","tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/"},{"categories":["WirelessCommunication"],"content":"物理层信号和信道的设计 出于对 MAC 层的传输信道以及物理层内部处理过程的需要，物理层定义了一系列的物理信道。 下行方向的物理信道包括： 物理广播信道（PBCH） 物理下行共享信道（PDSCH） 物理多播信道（PMCH） 物理下行控制信道（PDCCH） 物理控制格式指示信道（PCFICH） 物理 HARQ 指示信道（PHICH） 上行方向的物理信道包括： 物理随机接入信道（PRACH） 物理上行共享信道（PUSCH） 物理上行控制信道（PUCCH） 下行信道映射\" 下行信道映射 上行信道映射\" 上行信道映射 物理信号主要包括： 导频信号 同步信号（PSS/SSS） 详细内容另见： LTE 系列：物理信号 LTE 系列：物理信道 LTE 系列：帧中的物理信道和信号 ","date":"2019-06-28","objectID":"/lte_physical_layer/:3:0","tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/"},{"categories":["WirelessCommunication"],"content":"物理层过程 讲解典型的物理层过程包括： 终端的小区搜索和下行同步 功率控制 上/下行共享信道的传输与接收 ","date":"2019-06-28","objectID":"/lte_physical_layer/:4:0","tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-28","objectID":"/lte_physical_layer/:5:0","tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/"},{"categories":["WirelessCommunication"],"content":" LTE RRC 层详解 ","date":"2019-06-21","objectID":"/lte_rrc/:0:0","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":"无线资源控制（RRC） 无线资源控制（Radio Resource Control，RRC）层是 LTE 无线接入网协议中控制面部分的主要内容。 用户终端在进行数据通信之前，需要与网络建立承载信令消息的连接，通过信令消息的交互，控制数据通信的过程。因此，是否与网络建立了 RRC 连接是终端状态的判断依据。 RRC 连接状态即已经与网络建立了 RRC 连接的终端处于连接状态，此时终端可以进行数据传输、系统信息接收，以及邻小区的测量上报和小区切换 RRC 空闲状态即没有与网络建立 RRC 连接，那么终端处于空闲状态，此时终端不进行数据的传输，仍然需要执行的功能包括：系统信息的接收、侦听寻呼，以及邻小区测量和小区重选 RRC 协议包括以下的主要功能： 系统信息的广播，包括接入网的系统广播消息，以及核心网非接入层（NAS）系统信息的广播 连接控制，包括信令承载（即 RRC 连接）的建立／重配置／重建立／释放、数据无线承载的建立／配置／释放，以及相关的完整性保护的数据加密的安全机制 移动性管理，包括配置终端的测量和上报，以及终端的小区选择、重选、寻呼和切换过程 服务质量（QoS）管理 NAS 信令直接传输的功能 ","date":"2019-06-21","objectID":"/lte_rrc/:1:0","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":"系统信息的广播 系统信息描述网络的基本情况，采用广播的方式进行发送，对应于广播控制逻辑信道（BCCH）。终端通过对系统信息的接收，获得在系统中进行通信所需要的基本网络参数。 LTE 的系统信息分为： 主信息块（Master Information Block，MIB） 主信息块（MIB）包括小区最基本的物理层信息，例如：系统下行信号的带宽、无线帧序号和发送天线的数目。终端需要获得这些基本的信息才能够进一步接收系统的其他信息。 MIB 信息在专门定义的广播传输信道（BCH）上，采用物理层广播信道（PBCH）在固定的时间和频率位置进行传输。MIB 采用 40ms 的周期重复发送，每个周期之内包括 4 次间隔为 10ms 的传输，在序号 SFN%4=0 无线帧的第 0 个子帧开始每个周期的第一次传输，其余 3 次传输发生在随后 3 个无线帧的第 0 个子帧的位置。 系统信息块（System Information Block，SIB） 系统信息块（SIB）映射在下行共享传输信道（DL-SCH）上进行传输，采用 SI-RNTI 进行指示。根据所传输信息的不同，SIB 分为多种类型：Type 1 ～ Type 12 SIB1（Type 1 信息）：包括了是否允许终端接入小区的相关信息，例如系统的公众网络标识（PLMN）、小区标识、关闭的用户组（CSG）信息以及 TDD 系统上下行时隙比例的配置信息。SIB1 中还承载了其他系统信息块（SIB2 ～ SIB13）的调度信息 SIB2：承载用于所有终端公共的无线资源配置信息，例如系统上行信号的频率／带宽、MBSFN 子帧、随机接入信道、寻呼信道、上行 sounding 导频和上行功率控制等的配置情况 SIB3 ～ SIB8：承载用于终端进行小区重选的相关参数，分别针对于同频、异频和异系统 3G/GSM/cdma2000 各种不同的情况。SIB9 指示关于家庭基站名字的信息 SIB10 ～ SIB12：用于公共灾害的警示服务，即地震和海啸警报系统（Earthquake and Tsunami Warning System，ETWS）和商用移动警报服务（Commercial MobileAlert Service，CMAS） SIB1 信息使用固定的时间位置进行传输，采用 80ms 的周期重复发送，每个周期之内包括 4 次间隔为 20ms 的传输，在序号 SFN%8=0 无线帧的第 5 个子帧开始每个周期的第一次传输，其余 3 次传输发生在随后 3 个序号为偶数的无线帧的第 5 个子帧的位置。 除了 SIB1 之外，其余的 SIB 消息映射在系统信息（System Information，SI）上进行传输，它们的映射关系可以进行灵活的配置，由 SIB1 中承载的调度信息进行指示。一个 SIB 消息只能映射在一个 SI 上进行传输，而一个 SI 可以包含多个具有相同周期的 SIB 消息。 系统广播信息向传输信道的映射如图所示: 系统广播信息向传输信道的映射\" 系统广播信息向传输信道的映射 系统广播信息的更新采用更新提示和信息更新两个阶段的方式。 根据系统配置的更新周期（最小值为 640ms），当需要对系统广播消息进行更新的时候，系统在前一个更新周期使用寻呼消息提示用户，系统广播消息将发生改变，但是在这个更新周期中，仍然发送原来的系统信息。在下一个更新周期，将发送改变之后的系统信息，终端根据该信息进行更新。 系统广播信息的更新\" 系统广播信息的更新 ","date":"2019-06-21","objectID":"/lte_rrc/:1:1","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":"对连接的控制 连接控制指的是对接入网中的无线承载进行控制的功能，包括信令承载的建立／重配置／重建立／释放、数据承载的建立／配置／释放，以及相关的完整性保护和数据加密的通信安全机制。 连接管理 LTE 中一共定义了 3 个用于信令的无线承载（Signaling Radio Bearer，SRB）： SRB0 用于承载公用控制逻辑信道（CCCH）的 RRC 消息 SRB1 主要用于承载专用控制逻辑信道（DCCH）的 RRC 消息 通常所说的建立 RRC 连接指的是信令无线承载 SRB1 的建立。 SRB2 用于承载专用控制逻辑信道（DCCH）的核心网非接入层（NAS）控制信息。 终端开机在网络中进行注册之后处于空闲状态，终端首先建立传输 RRC 消息的信令承载 SRB1，终端进入 RRC 连接状态，然后，系统建立传输 NAS 消息的信令无线承载 SRB2 和传输数据的无线承载 DRB，由此可以开始进行数据的通信。 RRC 连接建立的过程\" RRC 连接建立的过程 进入 RRC 连接状态之后，采用 RRC 连接重配置的过程来进行 SRB2 和 DRB 的建立和管理。 重配置过程在连接状态下对 RRC 连接进行更改，包括： 建立／更改／释放无线承载， 进行小区切换的过程 建立／更改／释放终端的测量和上报 对应于这些功能，RRC 连接重配置消息中可能携带的信息包括： 无线资源的配置情况（无线承载、MAC 层和物理层），其中含有如下信息： 公共的配置信息，描述了移动性控制信息和系统信息中公共的无线资源配置情况，例如随机接入信道的参数、系统上行 sounding 导频配置和上行功率控制参数等静态的物理层配置信息 专用的配置信息，专用的配置信息用于无线承载的管理，例如 MAC 层配置、SPS 调度以及专用的物理层配置等 移动性控制的相关参数 无线测量的配置信息 RRC 连接重配置的过程\" RRC 连接重配置的过程 按照 RRC 连接重配置消息中携带的配置信息，无线承载建立的过程包括建立一个 PDCP 实体、建立一个 RLC 实体，以及按照指定的逻辑信道标识建立一个逻辑信道。 与建立的过程相对应，当 RRC 连接重配置消息指示释放某个无线承载的时候，将释放相应的 PDCP 实体、RLC 实体和逻辑信道。通过 RRC 连接释放的过程，终端由 RRC 连接状态转变为空闲状态。这个过程释放 RRC 连接，包括所有已经建立的信令和数据的无线承载，以及所有的无线资源。 RRC连接释放的过程\" RRC连接释放的过程 通信安全的功能 为了保证通信的安全，防止窃听、伪装等恶意行为，无线接入网的连接控制中包含安全通信的相关功能，包括： 信令消息的完整性保护 信令消息加密 数据消息的加密 在 RRC 连接建立的过程中，无线接入网从核心网取得终端用户的相关信息，然后可以使用安全模式激活的 RRC 消息设置用户密钥和加密算法，开启信令完整性保护和加密的功能，从而保证后续通信过程的安全（包括 SRB2 和 DRB 的建立等）。 安全模式激活的过程\" 安全模式激活的过程 在通信的过程中还可以通过计数器检查（counter check）的 RRC 消息防止中间人（man in the middle）攻击。在计数器检查的过程中，网络发送计数器检查消息要求终端确认在每个数据无线承载 DRB 上发送和接收数据的数量，通过这样的方法可以排除中间人可能进行的伪装通信。 计数器检查的过程\" 计数器检查的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:2","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":"终端移动性的管理 终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括: 终端与无线接入网之间的 RRC 控制协议 终端与核心网之间非接入层（NAS）控制协议 空闲状态终端的移动性管理 处于 RRC 空闲状态的终端与无线接入网没有建立 RRC 连接，终端的信息在核心网中注册并且分配有 IP 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 DRX 周期监听可能的寻呼消息。空闲状态的终端不能进行单播数据的传输。 在终端开机的过程中，首先根据 PLMN（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。 终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。 空闲状态终端的寻呼和跟踪区改变\" 空闲状态终端的寻呼和跟踪区改变 当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网移动控制实体（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。 连接状态终端的移动性管理 处于 RRC 连接状态的终端与无线接入网建立了 RRC 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。RRC 连接状态的终端可以进行单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 DRX 功能。 RRC 连接状态终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。 连接状态终端的小区间切换\" 连接状态终端的小区间切换 切换过程 首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程： 通过 eNodeB 之间互联的 X2 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。 如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 C-RNTI 标识、目标小区的系统信息，以及分配的专用随机接入序列等。 源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 RRC 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(注： 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。) 收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。 无线接入网的切换完成后，目标基站将向核心网的移动控制实体（MME）发送路径切换请求，并由 MME 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。 完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。 配置终端的测量和上报 为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括： 同频测量场景 异频测量场景 异系统的测量场景 网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 RRC 连接状态的终端，通过 RRC 信令（即 RRC 连接重配置消息）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。 在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为同频测量，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，不需要测量间隔，也就是说，在对同频目标小区进行测量的时候，终端不需要中断对源服务小区的信号接收。 源服务小区和目标小区工作在不同载波频率的场景属于异频测量，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端中断对源小区的信号接收，将接收频率调整到目标小区进行测量。 对终端的测量进行配置的消息内容主要包括测量的对象和测量上报的配置。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。 适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括： A1 事件，服务小区的信号质量优于某个设定的门限 A2 事件，服务小区的信号质量差于某个设定的门限 A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限 A4 事件，相邻小区的信号质量优于某个设定的门限 A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限 另外，针对与异系统之间的移动性操作，定义了两种事件： B1 事件，异系统相邻小区的信号质量优于某个设定的门限 B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限 终端测量上报的过程\" 终端测量上报的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:3","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":"服务质量（QoS）管理 LTE 系统中采用 EPS 承载为单位进行端到端的服务质量（QoS）管理。 EPS（Evolved Packet System）承载是终端和分组数据网网关（P-GW）之间的连接，1 个 EPS 承载包括： 1 个无线承载，即终端和 eNodeB 基站之间的连接 1 个 S1 承载，即 eNodeB 和服务网关（S-GW）之间的连接 1 个 S5/S8 承载，即 S-GW 和 P-GW 之间的连接。 对于一个终端，网络可以建立多个 EPS 承载，每个 EPS 承载可以有不同的 QoS 参数，因此除了在不同用户之间实现不同的 QoS，属于同一个用户的多个 EPS 承载也可以实现不同的 QoS，用于一个用户在同时进行的不同业务。 LTE 系统中的承载\" LTE 系统中的承载 针对每一个 EPS 承载，由核心网分配 QoS 参数，包括QoS 类别标识（QoS Class Identifier，QCI）和分配和滞留优先级（Allocation and Retention Priority，ARP）。 QCI 参数描述了承载的 QoS 类别，每一种 QoS 类别都对应于一系列影响数据服务质量的具体系统参数，例如调度的加权、准入门限和排队门限，等等。 ARP 参数描述了承载的优先级，包括在资源受限的情况下是否允许建立承载，或者是否丢弃某个优先级较低的承载 另外还有保证数据速率（Guaranteed Bit Rate，GBR）和最大数据速率（Maximum Bit Rate，MBR），这两个参数用于具有保证速率属性的承载。而对于不具有保证速率属性的承载，使用参数最大总速率（Aggregated Maximum Bit Rate，AMBR）来限制一个终端的所有不具有保证速率属性的承载的最大总速率。 根据核心网确定的 QoS 参数，无线接入网负责执行无线承载部分的 QoS 管理，例如无线资源的调度策略和排队管理策略等。 RRC 协议可以执行一部分 QoS 管理的功能，主要包括：半持续资源调度的配置，以及通过配置终端上行逻辑信道的优先级，实现对一个终端内多个上行承载的速率控制。 ","date":"2019-06-21","objectID":"/lte_rrc/:1:4","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":"核心网信令的直接传输 除了 RRC 协议信息之外，RRC 消息还可以用于承载核心网的非接入层（NAS）信息。采用所定义的上行／下行 NAS 信息直接传输的 RRC 过程，可以通过隧道打包的方式，在终端用户和网络核心网之间传输 NAS 信息。 上行（NAS）信息的直接传输\" 上行（NAS）信息的直接传输 下行（NAS）信息的直接传输\" 下行（NAS）信息的直接传输 ","date":"2019-06-21","objectID":"/lte_rrc/:1:5","tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/"},{"categories":["WirelessCommunication"],"content":" LTE MAC 层详解 ","date":"2019-06-10","objectID":"/lte_mac/:0:0","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":"媒体接入控制（MAC） 媒体接入控制（Medium Access Control，MAC）层接收来自上层的 RLC 层的逻辑信道，经过处理后，以传输信道的方式输出到下层的物理层。 MAC 层的主要功能包括： 逻辑信道向传输信道的映射与复用 根据不同优先级进行动态的资源调度 选择传输格式实现动态的速率自适应 混合自动重传（HybridAutomatic Repeat reQuest，HARQ）的纠错功能 ","date":"2019-06-10","objectID":"/lte_mac/:1:0","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":"逻辑信道 逻辑信道根据所传输的信息的类型进行定义。LTE 定义的逻辑信道包括： 用于传输系统广播消息的广播控制信道（Broadcast Control CHannel，BCCH） 用于传输寻呼消息的寻呼控制信道（Paging Control CHannel，PCCH） 分别用于空闲状态和连接状态的终端传输控制信息的公用和专用控制信道（Common/ Dedicated Control CHannel，CCCH/DCCH） 用于传输用户数据信息的专用业务信道（Dedicated Traffic CHannel，DTCH） ","date":"2019-06-10","objectID":"/lte_mac/:1:1","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":"传输信道 传输信道根据信息传输的方式进行定义。传输信道以传输块为单位在发送时间间隔（Transmission Time Interval，TTI）所定义的时间长度内进行每一次的发送，LTE 中设计的 TTI 长度是 1ms。每个传输块都有定义的传输格式，它由网络的调度功能动态地确定，包括传输块大小、调制方式和多天线方案等。 LTE 定义的传输信道包括： 广播信道（Paging CHannel，PCH），采用固定的传输格式，用于传输广播控制信道； 上行共享信道／下行共享信道（Downlink/Uplink Shared CHannel，DL-SCH/UL-SCH），支持基于无线信道状态的实时调度、动态的速率自适应、HARQ 软合并和多天线空间复用的传输方式，是 LTE 进行上行和下行数据传输的主要的传输信道。 在 LTE 空中接口 MAC 层协议功能的处理过程中，逻辑信道向传输信道以及最终的物理信道的映射关系如下所示： 下行信道映射\" 下行信道映射 上行信道映射\" 上行信道映射 ","date":"2019-06-10","objectID":"/lte_mac/:1:2","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":"MAC 协议数据单元格式 MAC 包头可以包含多个子包头，每个子包头对应于 MAC PDU 负荷部分的 1 个 MAC 控制单元、MAC SDU 或者填充比特字段。 MAC 协议数据单元 PDU 的格式\" MAC 协议数据单元 PDU 的格式 子包头的格式如图所示： MAC 层的子包头\" MAC 层的子包头 R（Reserve）字段为保留字段，数值设为 0 E（Extension）字段指示本子包头后面是否还有其他的子包头，或者是包头部分已经结束，将要开始 MAC 控制单元或者 MAC SDU 的传输 LCID（Logical Channel ID）字段指示 MAC SDU 所属逻辑信道的标识、MAC 控制单元的类型或者是填充比特 F（Format）字段指示随后的 L 字段的长度，7 个比特或者 15 个比特 L（Length）字段指示与子包头相对应的 MAC SDU 或者 MAC 控制单元的字节长度 ","date":"2019-06-10","objectID":"/lte_mac/:1:3","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":"MAC 层功能和 MAC 控制单元 下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程 随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程\" 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决 如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI\" MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识\" MAC 控制单元——终端冲突解决标识 数据的调度和传输 数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度 LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度\" 半持续调度 HARQ MAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程\" 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告 终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告\" MAC 控制单元——缓存状态报告 功率余量报告 上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余","date":"2019-06-10","objectID":"/lte_mac/:1:4","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-10","objectID":"/lte_mac/:2:0","tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/"},{"categories":["WirelessCommunication"],"content":" LTE RLC 层详解 ","date":"2019-06-06","objectID":"/lte_rlc/:0:0","tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/"},{"categories":["WirelessCommunication"],"content":"无线链路控制（RLC） 无线链路控制（Radio Link Control，RLC）层的主要功能是： 根据下层指示的数据包传输大小对来自上层的数据包进行连接、分段和重组 数据包的顺序传输和重复性检测 自动重传请求（Automatic Repeat Request，ARQ）的数据纠错 针对每一个无线承载配置一个 RLC 实体，经过 RLC 层协议功能的处理后，数据以逻辑信道的方式输出到下层的 MAC 层。根据所传输消息的不同特点，RLC 实体有 3 种工作模式： 透明模式（Transparent Mode，TM） 确认模式（Acknowledged Mode，AM） 非确认模式（Unacknowledged Mode，UM） ","date":"2019-06-06","objectID":"/lte_rlc/:1:0","tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/"},{"categories":["WirelessCommunication"],"content":"透明模式（TM） 此模式下，RLC 子层是完全透明的，不执行任何功能，例如不添加 RLC 包头、不进行数据分段或者连接，即来自上层的数据在 RLC 层不进行任何处理，“透明”地传输到下层的 MAC 层。透明模式用于广播、寻呼和公用控制信道等信息需要传输给多个用户的情况，相对应于广播、上下行公用控制和寻呼等逻辑信道。 TM 模式数据消息的 RLC PDU 格式\" TM 模式数据消息的 RLC PDU 格式 ","date":"2019-06-06","objectID":"/lte_rlc/:1:1","tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/"},{"categories":["WirelessCommunication"],"content":"确认模式（AM） 此模式用于提供高可靠性的数据传输服务，例如 TCP/IP 数据业务或者 RRC 控制信令的传输，包括承载上下行专用数据信息和专用控制信息的逻辑信道。 在此模式下，RLC 子层执行所有功能，包括： 数据包的连接、分段和重组 数据包的顺序传输和重复性检测 基于滑动窗进行错误数据包重新传输的 ARQ 纠错机制 AM 模式的 RLC PDU 由 RLC 包头和 RLC SDU 组成，RLC 包头包括 D/C，RF，P，FI， E 和 SN 字段。如果 RLC PDU 中包含多于 1 个数据字段，那么相对应的 RLC 包头还将包括 E 和 LI 字段，以分别对应于各个数据字段。 AM 模式数据消息的 RLC PDU 格式\" AM 模式数据消息的 RLC PDU 格式 以下是 RLC 包头各个字段的具体含义: D/C（Data/Control）字段：指示该 RLC PDU 是RLC 数据 PDU还是RLC 控制 PDU RF（Re-segmentation Flag）字段：指示该 RLC PDU 是一个 AM 模式``PDU，还是一个 AM 模式的 PDU 分段。因为，在 AM 模式的情况，数据包进行 ARQ 重传的时候，可能需要对初次传输时的 AM PDU 进行分段，因而形成 AM PDU 分段 P（Polling）字段指示是否要求接收端对等的 RLC 实体进行 1 次 RLC 状态的报告 FI（Framing Indicator）字段：指示 RLC PDU 的数据字段是否是 RLC SDU 的开始或者结尾部分。2 个比特的信息指示了是开始不是结尾、是结尾不是开始、既不是结尾也不是开始、既包含了结尾也包含了开始一共 4 种可能的状态 E（Extension）字段指示后面是否还有 E 和 LI 字段 SN（Sequence Number）字段：指示 RLC PDU 的序号，序号采用递增的方式。对于 AM 模式下重传的 AM PDU 或者 AM PDU 分段，采用初传的 AM PDU 所对应的序号 LI（Length Indicator）字段：指示对应的数据字段的字节长度 在 AM 模式下，RLC 层使用 ARQ 纠错机制对传输错误的数据包进行重传，由于下层指示的数据包传输大小可能与初次传输时候的情况有所不同，可能需要对初次传输的 AM PDU 进行分段，因此形成了AM PDU 分段的格式。与 AM PDU 相比较，AM PDU 分段在包头部分多了两个字段：LSF 和 SO。 AM 模式数据消息的 RLC PDU 分段的格式\" AM 模式数据消息的 RLC PDU 分段的格式 LSF（Last Segment Flag）字段指示这个 AM PDU 分段是否是所对应的初次传输的 AM PDU 的最后一个分段。 SO（Segment Offset）字段指示这个 AM PDU 分段在所对应的初次传输的 AM PDU 中的位置，具体是这个 AM PDU 分段的第 1 个字节在所对应的初次传输的 AM PDU 中的字节位置。 除了 RLC 数据 PDU 之外，AM 模式下还可能传输 RLC 控制 PDU，进行 RLC 状态的报告。由数据接收方的 RLC 实体向数据发送方对等的 RLC 实体发送 RLC 状态 PDU，报告 AM PDU 数据包的接收状态，包括正确接收的数据包的最后序号，以及接收错误的数据包的序号。 RLC 状态 PDU\" RLC 状态 PDU CPT（Control PDU Type）字段指示该 RLC 控制 PDU 的类型 ACK_SN（Acknowledgement SN）字段指示接收正确的数据包的最后一个序列号，不包含 ACK_SN 本身所指示的数据包，以及由 NACK_SN 所指出的接收错误的数据包 E1（Extension bit 1）字段指示后面是否跟随有 NACK_SN，E1 和 E2 字段 NACK_SN（Negative Acknowledgement SN）字段指示接收错误或者部分出错的 AM PDU 数据包的序列号 E2（Extension bit 2）字段指示这个 NACK_SN 后面是否跟随有 SOstart 和 SOend 字段 SOstart 在 AM PDU 数据包部分出错的情况下，SOstart 字段指示出错部分的第一个字节在 AM PDU 数据包中的位置 SOend 在 AM PDU 数据包部分出错的情况下，SOend 字段指示出错部分的最后一个字节在 AM PDU 数据包中的位置 ","date":"2019-06-06","objectID":"/lte_rlc/:1:2","tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/"},{"categories":["WirelessCommunication"],"content":"非确认模式（UM） 此模式与确认模式的区别是不进行错误数据包重传的 ARQ 纠错。UM 模式主要用于对数据传输正确性的要求不是很高的场景，例如广播信道或者 VoIP 业务，包括上下行专用数据逻辑信道和多媒体广播多播业务（Multimedia Broadcast Multicast Service，MBMS）专用的控制和数据逻辑信道。UM 模式 RLC 子层仍然执行数据包的连接、分段和重组，数据包的顺序传输和重复性检测的功能。 与 AM 模式相比较，UM 模式的 RLC PUD 少了 3 个字段：D/C、RF 和 P。因为 RLC 控制 PDU 只在 AM 模式进行传输，UM 模式仅传输 RLC 数据 PDU，因此不需要指示 RLC 控制或者 RLC 数据信息的 D/C 字段。UM 模式不进行 ARQ 纠错的重传，因此不会出现数据包重传需要重新分段的情况，所以不需要指示数据分段的 RF 字段。P 字段所指示的 RLC 状态报告也仅适用于 AM 模式，因此 UM 模式的情况下不需要这个字段。 UM 模式数据消息的 RLC PDU 格式\" UM 模式数据消息的 RLC PDU 格式 ","date":"2019-06-06","objectID":"/lte_rlc/:1:3","tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-06","objectID":"/lte_rlc/:2:0","tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/"},{"categories":["WirelessCommunication"],"content":" LTE PDCP 层详解 ","date":"2019-06-03","objectID":"/lte_pdcp/:0:0","tags":["LTE"],"title":"LTE 系列：PDCP 层","uri":"/lte_pdcp/"},{"categories":["WirelessCommunication"],"content":"分组数据会聚协议（PDCP） 分组数据会聚协议（Packet Data Convergence Protocol，PDCP）层的主要功能是进行 IP 数据包头压缩、数据加密和控制信令的完整性保护。 对于来自上层的数据包，将针对每一个无线承载建立一个 PDCP 实体。首先对数据包进行编号，然后根据配置对数据包进行 IP 包头压缩，数据加密和控制信令完整性保护的操作，形成 PDCP 服务数据单元（Service Data Unit，SDU），最后添加包含编号的 PDCP 包头，形成 PDCP 协议数据单元（Protocol Data Unit，PDU）作为 PDCP 子层协议功能的处理结果向下层 RLC 子层输出。 PDCP 协议数据单元格式\" PDCP 协议数据单元格式 R 表示预留的字段，都填充为 0 D/C 字段指示控制面或者数据面的 PDCP 包，控制面为 0，数据面为 1 MAC-I 是控制信令完整性保护的字段，在不使用完整性保护功能的时候，都填充为 0 ","date":"2019-06-03","objectID":"/lte_pdcp/:1:0","tags":["LTE"],"title":"LTE 系列：PDCP 层","uri":"/lte_pdcp/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-03","objectID":"/lte_pdcp/:2:0","tags":["LTE"],"title":"LTE 系列：PDCP 层","uri":"/lte_pdcp/"},{"categories":["WirelessCommunication"],"content":" LTE PDCP 协议详解 ","date":"2019-05-26","objectID":"/upper_layer_protocol/:0:0","tags":["LTE"],"title":"LTE 系列：无线接入网上层协议","uri":"/upper_layer_protocol/"},{"categories":["WirelessCommunication"],"content":"无线接入网 由 E-NodeB 组成的无线接入网是系统与终端用户进行通信的接口，它的功能分为数据面和控制面两个部分： 数据面负责用户数据信息的传输 控制面负责系统控制功能以及相关信息的传输和处理 LTE 接入网协议架构\" LTE 接入网协议架构 分组数据会聚协议（PDCP） 无线链路控制（RLC） 媒体接入控制（MAC） 无线资源控制（RRC） 无线接入网向核心网提供无线承载服务。 针对每一个用户可以建立 1 个或者多个的无线承载，来自核心网 S1 接口的 IP 数据包根据不同的服务质量要求（Quality of Service，QoS）可以映射在不同的无线承载上。然后，数据包将分别经过 PDCP$\\Longrightarrow$RLC$\\Longrightarrow$MAC 各层协议地处理： PDCP 层完成的功能包括 IP 数据包的头压缩、数据加密以及控制信令的完整性保护。 RLC 层主要进行自动重传请求（Automatic Repeat Request，ARQ）的功能。 MAC 层的主要功能包括动态资源调度、逻辑信道复用以及混合自动重传（Hybrid Automatic Repeat Request，HARQ）。 经过 MAC 层协议的处理后，形成 1 个或者多个传输信道。最终通过物理层的处理在无线信号上进行传输。 LTE 接入网协议功能和数据处理流程\" LTE 接入网协议功能和数据处理流程 控制面主要的控制功能包括： 无线接入网的无线资源管理（Radio Resource Control，RRC）。无线资源管理（RRC）的主要功能包括系统信息的广播、终端的移动性管理，以及信令和数据的连接控制。 来自核心网移动性管理实体（MME）的非接入层（NAS）消息的控制功能，包括 EPS 系统承载（Evolved Packet System，EPS）的管理，空闲状态终端的移动性处理和寻呼，终端鉴权以及安全性方面的控制。 ","date":"2019-05-26","objectID":"/upper_layer_protocol/:1:0","tags":["LTE"],"title":"LTE 系列：无线接入网上层协议","uri":"/upper_layer_protocol/"},{"categories":["WirelessCommunication"],"content":"参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-05-26","objectID":"/upper_layer_protocol/:2:0","tags":["LTE"],"title":"LTE 系列：无线接入网上层协议","uri":"/upper_layer_protocol/"},{"categories":["WirelessCommunication"],"content":" LTE 系统总体架构分解 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:0:0","tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/"},{"categories":["WirelessCommunication"],"content":"系统架构演进 系统架构演进（又名 SAE，System Architecture Evolution）是 3GPP 所制定的 LTE 无线通信的核心网络标准。 SAE 是基于 GPRS 核心网的演进，其主要差别为： 简化架构 全 IP 网络（AIPN） 支持提供更高吞吐量和更低延迟的接入网 多个异构接入网络的互通，包括 E-UTRA（LTE 和 LTE 升级版的接入网），3GPP 已有系统（例如 GPRS 和 UMTS 的接入网 GERAN 和 UTRAN），也支持与非 3GPP 系统之间的互通（例如 WiMAX、CDMA2000 或 WIFI） SAE 是的传输使用全 IP 网络，从而支持系统的控制平面和用户平面的分离。 SAE 体系结构的主要组成部分是核心分组网演进（EPC，Evolved Packet Core )，也被称为 SAE 核心。EPC 作用与 GPRS 网络相似，包含移动性管理组件（MME），服务网关（S-GW）和 PDN 网关（PDN Gateway）等网元。 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:1:0","tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/"},{"categories":["WirelessCommunication"],"content":"系统架构 LTE 系统可以分为核心网和无线接入网两个部分，如下图所示： LTE 系统总体架构图\" LTE 系统总体架构图 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:2:0","tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/"},{"categories":["WirelessCommunication"],"content":"核心网 核心网包括： 移动性管理实体（MME） 服务网关（S-GW） 分组数据网网关（P-GW） MME实体负责移动性管理相关的控制功能，包括： 对终端位置跟踪区域列表的管理 对处于空闲状态的终端发起寻呼 为终端选择接入的 P-GW 和 S-GW 漫游和鉴权功能 非接入层（Non-Access Stratum，NAS）信令功能 信令安全和接入层（Access Stratum，AS）的安全控制 接入网之间的移动性管理（包括接入网内切换时的 MME 选择，向 2G 或者 3G 的不同接入网切换时的 SGSN 选择） 网络承载管理的功能 服务网关（S-GW）负责数据承载的相关功能，包括： 数据包的路由和转发，E-NodeB 之间切换或者 E-NodeB 和 GSM/WCDMA/TD-SCDMA 系统的不同接入网之间切换时的数据锚点 上下行传输层数据包的优先级标识 运营商内部和运营商之间的终端计费 对用户通信进行合法侦听的功能 PDN 网关（P-GW）是核心网与外部因特网的接口，完成的主要功能包括 针对每个用户的数据包过滤 终端的 IP 地址分配 基于业务的计费功能 门控和速率强制功能 下行传输层数据包的优先级标识 进行合法侦听的功能 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:2:1","tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/"},{"categories":["WirelessCommunication"],"content":"无线接入网 无线接入网是系统与移动用户终端进行通信的接口，LTE 无线接入网采用扁平的网络结构，仅包含一种网络节点，即 E-NodeB（LTE 基站）： E-NodeB 之间通过 X2 接口进行互连，E-NodeB 通过 S1 接口与核心网进行连接，分为 S1-MME 和 S1-U 接口分别与核心网的 MME 和 S-GW 设备进行连接。为了实现负荷分担和容灾备份的功能，E-NodeB 和 MME/S-GW 之间可以进行多对多的连接，即 1 个 MME/S-GW 可以和多个 E-NodeB 连接，1 个 E-NodeB 也可以和多个 MME/S-GW 连接。 E-NodeB 负责无线接入网部分的功能，主要包括：无线资源管理（包括无线承载控制、无线接入控制、连接的移动性控制、动态的资源调度），IP 头压缩和用户数据加密，为附着的终端选择进行控制功能的 MME 实体，将用户数据路由至 S-GW 服务网关，寻呼、广播和公共报警消息的调度与传输，以及配置用于终端移动性管理和数据调度的物理层信号测量和测量的上报。E-NodeB 之间通过 X2 接口进行互连，X2 接口主要用于支持终端在 E-NodeB 之间的切换，包括信令的交互以及切换过程中可能进行的数据转发，X2 接口还可以用于在小区之间交互无线资源管理的消息，实现小区间协调进行干扰抑制的功能。 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:2:2","tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/"},{"categories":["WirelessCommunication"],"content":"参考 [1] SAE [2] LTE-Advanced 关键技术详解 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:3:0","tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/"},{"categories":["ChitChat"],"content":" 条形码以及二维码的过去与将来 说明 本文是最早以 TechKoala 的名字所写的文章，发布于电脑爱好者 2013 年第 06 期。说来当时以邮汇方式发的稿费至今没有收到，2333  面对我们随时可以看见的条形码，说出来你也许会不信，如果没有这个家伙，整个世界的经济都无法正常运行。这些黑白条码不但能让机场不弄丢你的行李，能对快件的包裹进行跟踪，而且还能在网上对各种信件进行查询。它们既可以用在食品包装上，也可以用在图书的扉页。这个时候看看手上的《电脑爱好者》杂志，你发现了吗？ ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:0","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"条形码的由来  三十多年前的一天，一位名叫道森的购物者走进马什超市，购买了一包箭牌口香糖，扫扫条形码然后付钱。这在今天稀疏平常的事，当时却是标志性事件 — 由此，条形码迎来了它的里程碑，从此走到你我的眼前。 伍德蓝德\" 伍德蓝德  说到条形码，就不得不说它的发明者 —— 伍德蓝德。他出生于新泽西州，从小便对技术发明具有浓厚的兴趣，具备非凡的动手能力。他生长在二战前后，战争期间，他不得不中断学业，参与研发原子弹的曼哈顿工程，这个看似八竿子打不着边的事，却使他对发明愈发迷恋。二战之后，美国经济快速发展，规模宏大的超市面临着一个巨大的问题，他们无法精确掌握库存情况，唯一的办法是手工清理，但耗时又费力。于是他们向德雷赛尔大学求助，恰巧伍德蓝德得知，于是，伍德蓝德开始与自己的朋友苏沃一起研究这个解决方案。蓝德本来是出于商业目的，但随着研究的深入，这项工作彻底改变了他的人生。类似历史上的诸多发明，开始时，蓝德遇到了许多次失败，但他没有放弃。他毅然辍学全心投入，坚信成功不远，但总差那么一层窗户纸。后来，他去了迈阿密的住所放松，那里有优美的居住环境、安静的思考空间，他期待能有灵感迸发。  老天不负有心人。有一天，他在沙滩坐定，苦苦思索：“如何才能给每件物品分类呢？编号？对！莫尔斯电码？可是这样太复杂了，一般人也没办法分辨。” 想到此，他开始无聊地在沙滩上用手画沙子，一条一条，突然，一个神奇的图案出现在蓝德脑海 — 如果用粗细、间距不同的竖线构成图案，那就可以实现对商品编码。就这样，条码的原型在沙滩上诞生了。待到出现文章开头的一幕时，已经过去了三十多年，可喜的是，我们的主人公是一位有耐心的人。 ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:1","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"条形码的标准与应用  与现在的条形码不同，蓝德发明的第一条条形码不是由线条构成，而是一组同心圆，通过照片扫描器读取。它形如箭靶，美国人称其为 “公牛眼”。遗憾的是，以美国当时的工艺和经济水平，他们还没有能力印制出这种编码。 公牛眼\" 公牛眼  后来，伍德蓝德加入了 IBM 公司，并把自己的专利卖给了 IBM。然而，伟大的成果却并非属于 IBM，几经转手，机遇来到了 RCA 公司。直到条形码大展宏图时，IBM 公司里的人才知道：“哦，原来发明条形码的人就在我们公司。”  我们目前所知的第一个商用条形码出现于 1966 年，但人们很快就意识到应该为其制定出一个行业标准。  两年后的夏天，应国家食物连锁协会要求，Logicon 公司开发出了食品工业统一码（UGPIC）。随后，美国统一编码协会建立了 UPC 码系统，并且实现了该码制的标准化。UPC 码首先在杂货零售业中试用，俄亥俄州的 Marsh 超级市场安装了由 NCR（IBM 公司的前身）制造的第一台 UPC 扫描器，而第一个被收银员扫描的便是文章开头所说的标价 69 美分的十片装箭牌口香糖。  直到现在，我们都不可否认的是，正是零售业的成功应用才促进了条形码技术的发展。  目前，全球每天大约要扫描 80 亿次条形码。而普华永道公司的一项研究报告表明，条形码每年仅在超市和大众零售领域就能为客户、零售商和制造商节约 300 亿美元的成本。令人感到遗憾的是，伍德兰德的朋友，条形码联合发明人苏沃并没有亲眼看到条形码的商业化应用，他在自己 38 岁的时候（1962 年）英年早逝。而伍德蓝德则在 1992 年被当时的美国总统布什授予了国家科技奖章。  令人遗憾的是，前不久，伍德蓝也不幸地告别了人世。据《纽约时代》报道，他于美国当地时间 2012 年 12 月 9 日在自己新泽西的家中逝世，享年 91 岁。蓝德的女儿苏珊评价父亲说：“他参与了整个系统的设计，从使用者的站立方式、激光扫描仪高度到如何保护人们的眼睛不受激光刺激，他是一个绝对的完美主义者。” ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:2","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"条形码的未来  今天，条形码已经占据我们生活的每个角落，从超市购买的食品到手中握住的杂志，我们依靠条形码管理我们的生活，条形码技术也在不断进步。  其实，如今风生水起的二维码也属于条形码，作为后起之秀，它比它的前辈更进一步。自从它出现以来，得到了人们的广泛关注，发展十分迅速。  二维条形码最早发明于日本，它是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的，在代码编制上巧妙地利用构成计算机内部逻辑基础的 “0”、“1” 比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信息自动处理。它具有条形码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、处理图形旋转变化等特点。  一维条形码虽然提高了资料收集与资料处理的速度，但由于受到资料容量的限制，一维条形码仅能标识商品，而不能描述商品，因此相当依赖电脑网络和资料库。在没有资料库或不便连网的地方，一维条形码很难派上用场。此外一维条形码有一个明显的缺点，即垂直方向不携带资料，故资料密度偏低。当初这样设计有二个目的：（1）为了保证局部损坏的条形码仍可正确辨识；（2）使扫描容易完成。  要提高资料密度，又要在一个固定面积上印出所需资料，可用二种方法来解决：（1）在一维条形码的基础上向二维条形码方向扩展；（2）利用图像识别原理，采用新的几何形体和结构设计出二维条形码。前者发展出堆叠式（Stacked）二维条形码，后者则有矩阵式（Matrix）二维条形码之发展，构成现今二维条形码的两大类型： 引用 堆叠式二维条形码的编码原理是建立在一维条形码的基础上，将一维条形码的高度变窄，再依需要堆成多行，其在编码设计、检查原理、识读方式等方面都继承了一维条形码的特点，但由于行数增加，对行的辨别、解码算法及软件则与一维条形码有所不同。较具代表性的堆叠式二维条形码有 PDF417、Code16K、Supercode、Code49 等。 矩阵式二维条形码是以矩阵的形式组成，在矩阵相应元素位置上，用点的出现表示二进制的 “1”，不出现表示二进制的 “0”，点的排列组合确定了矩阵码所代表的意义。其中点可以是方点、圆点或其他形状的点。矩阵码是建立在电脑图像处理技术、组合编码原理等基础上的图形符号自动辨识的码制，已较不适合用 “条形码” 称之。具有代表性的矩阵式二维条形码有 Datamatrix、Maxicode、Vericode、Softstrip、Code1、Philips Dot Code 等。  二维条形码的新技术在 1980 年代晚期逐渐被重视，在 “资料储存量大”、“资讯随着产品走”、“可以传真影印”、“错误纠正能力高” 等特性下，二维条形码在 1990 年代初期已逐渐被使用。现在，几乎所有的社交软件都具备扫一扫的功能，对着抽象的图案一扫，迎来一个多彩的世界已经成为许多人的习惯。  马化腾在去年九月开幕的互联网大会的演讲中便说到：“从微信强化扫二维码的功能之后，我们希望把这个行为定义成更加普及，老百姓一看到码就去扫的概念。我们前几天还在网上看到一个新的名词，就是扫墓，看到墓碑有那个二维码，一扫描就看到这个墓碑的主人过去的生平介绍等等，这些都是非常典型的应用。”  或许，墓碑的例子有些夸张，但是，你不能否认，条形码越来越贴近我们的生活，不再只是局限于购物。也许未来，我们的一切都涵盖在那小小的方寸之间。  碰巧，时隔多年把这篇文章重新整理出来的时候，回形针正好发布了一期关于二维码的视频：  放在这里，作为补充。 ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:3","tags":["QRcode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/"},{"categories":["ChitChat"],"content":"Sybian 联盟\" Sybian 联盟 聊聊 Symbian 的过去 注意 这是一篇写于 2013 年的文章，文章的观点可能已经过时甚至错误，但时过境迁，仅表怀念。  毫不夸张的说，今天我们所拥有的一切，都是建立在它的肩膀上。无论多少人咒骂它的臃肿，嫌弃它的卡顿，都无法改变它作为手机智能操作系统鼻祖的地位。当山寨机还在襁褓中时，当伪智能还在浪费人们的时间时，作为先驱的它便已上路。大多数人接触的第一款真正的智能手机系统，它把软件下载，游戏安装，刷机破解等诸多名词第一次带到了大众视野。它叫 Symbian，也曾辉煌。三十年河东，三十年河西，科技领域本就没有常青树。虽然如今已经沦落，但不妨碍我们一起回味它曾经的辉煌。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:0","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"混沌之初，Symbian 伊始 ​ Symbian，源自一家充满梦想的公司。  1980 年，potter 在伦敦成立了 Psion 公司，这家以数字产品开发和研究为目的，为率先使用电子设备的大公司服务的小公司便是 Symbian 的生母。随着公司的发展，Psion 开始浸淫移动终端市场，他们生产的各类移动设备不仅皮实耐用还能按需求定制，凭借这种 “开放移动” 的理念，Psion 在上世纪 90 年代 成为了欧洲较成功的 PDA 生产商，进而促进了 EPOC 的诞生。在 potter 看来，EPOC 是一种面向普通大众的便携系统。正如他的全称“A new epoch of personal convenience.”（一个人人方便使用电子产品的新时代），他被 Psion 给予了对于人机交互未来的憧憬。  犹如一代闪电，EPOC 划开了混沌的天空，不过真正的风暴才刚来临。  1991 年到 1998 年，Psion 发布了几款给予 EPOC 16 的的设备，作为早期产品，免不了简陋无比，它们充其量只能算是 PDA 模块，只是方便了厂商研发新品。  真正让 EPOC 走向成熟的是一位叫做 Nicholas Myers 的程序设计师。1994 年，他在构思下一代 EPOC 时，设定了开发适应 21 世纪技术性能的系统的目标。正是这样的思路。让他把握住了市场脉搏。1997 年，他成为 Psion 旗下 Symbian 软件公司的 CEO，其上任后发布的 EPOC 32 操作系统，比起前辈，已有了翻天覆地的变化。吸引了人们以及投资者的兴趣。今天我们吧 Myers 成为 “Symbian 之父”。  EPOC 32 与 Windows 极为相似，它是一套 32 位的系统，支持多任务，拥有图形化美观的界面。鉴于当时几乎没有可以直接用于手机的操作系统，它的问世，一下子汇聚了厂商的目光。不过，任何一项新技术新产品的诞生都需要时间的推敲，智能手机系统作为新兴事物，没有哪家厂商敢冒险直接挺近。一番商榷之后，1998 年，爱立信、诺基亚、摩托罗拉和 Psion 共同成立了一家公司，目的是推进手机和 PDA 的智能化，它就是我们今天熟知的 Symbian。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:1","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"拉帮结派，飞速发展  联盟的成立不仅吸引了大量手机厂商，一些上有配件商，例如 ARM 和德州仪器都加入了合作计划。  Symbian 从一成立便秉持着开放的理念，任何组织和个人都能为其开发软件。但刚成立那几年，公司都未能推出一款真真意义上的产品，巨头们也只是作为附属项目在发展。直到 1999 年，Symbian OS v5 平台作为第一款成熟的产品被设计出来，为了争夺 “谁是世界上第一台智能手机”，爱立信没有经过完成的 DEBUG，就匆忙的把他推向市场，生产出 Erisson R380。同时期，摩托也推迟了自己的天拓 A6188。可实际上，两者中无论哪个都不能算严格意义上的智能手机，它们连软件都不能自由安装，真正算起来，搭载了 OS V5.1 的诺基亚 9210 才符合智能机最基本的定义，由此，诺基亚开始领先于其他厂商并保持到了最后。  众所周知，利益面前必有纠纷。诺基亚的崛起必然伴随了很多厂商的陨落，同时，它的存在也让联盟中其他有实力的厂商感到了危机，这为后来阵营的割分埋下了导火索。  Symbian 成立之初提出了著名的三分法：Pearl (珍珠）、Quartz (石英）和 Crystal（水晶）。分别对应手机的三大发展趋势：标砖键盘、触摸屏以及全键盘。诺基亚依靠 Pearl 迅速赢得了市场，逼迫索尼爱立信和摩托罗拉只能另寻他路 –Quartz。于是，联盟分为了两大派系，一是以诺基亚牵头的 S 系列平台，再者便是索尼爱立信主打 UIQ。诺基亚凭借标准键盘占据了大半江山，而后者则主攻触摸屏。这种同床异梦的现象愈演愈烈，直接导致了联盟崩溃的迫近。  当然，上述现象只是苗头，整个联盟正处于高速发展阶段。2002 年，微软的 WM 系统进入市场，这个原本被人们誉为 “Symbian 终结者” 的系统，却远没有它的大哥一般占据市场，反而被后者打的满地找牙。与此同时，诺基亚更是凭借 Pearl 进一步扩展帝国的领土，N70、N73、N95 的横空出世，为诺基亚扎实了自己的实力，待到 Symbian 王朝最鼎盛时，这个姓塞的家族占据了 72% 的智能手机市场，其中更是有九成乃至如日中天的诺基亚。直到现在，都没有哪一家厂商甚至哪一个操作系统打破这个纪录。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:2","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"兄弟反目，联盟瓦解  正如上文所说，一家独大必然引发隐患。而事实证明那一天来了。2008 年，UIQ 宣布倒闭。究其原因，一方面是由于它自身定位与市场的极大反差，而另一方面便是来自于诺基亚的压力。相比 S60，开发者在这个平台上的收益远不及前者。应用程序的短缺自然局限了消费者的购买欲，如此一来，倒闭似乎只是时间问题了。诺基亚的持续壮大，扼杀了其他厂商的利润，长此以往，天平的过分了倾斜让别的厂商不得不退出 Symbian 的纷争。UIQ 的倒闭，标志着诺基亚对于 Symbian 掌控的最大化，后者从此只有一个主人了。  联盟名存实亡，但诺基亚为了避嫌，标榜着 “开放” 而成立了 Symbian 基金会，继续推向面向所有开发者开放的原则，明则共享资源，暗则染指一统智能市场。不幸的是，这是 iPhone 和 Android 问世了。后来的结果，各位看官一定也都清楚。诺基亚的美梦做早了，自大的它快走到了末路。  多年以后，关于那个一统江湖的传说，早已沦为笑谈罢了。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:3","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"成也 Symbian，败也 Symbian  船大难掉头。巨头对于市场末端的变化总是慢半拍。身处多年王位的诺基亚早已麻痹了大意。UIQ 的倒闭，让其认为触摸屏不被市场接受，继续推进 S60 这个老迈的系统被诺基亚看做唯一路线。iPhone 的面市彻底颠覆了人们对于智能手机的认识，一度让人们认为 iPhone 重新定义了智能手机。市场的反应也确实印证了这一点，我们的双手确实是最适合操作的工具。但固守己见的诺基亚貌似看不到这一变化，迟迟不肯跳出键盘的定式思维。虽然后来确实推出了几款诸如 5800 这样销量很不错的触屏手机，当一切来的太晚，苹果做大了，随后的绿皮机器人也成熟了，Symbian 王朝彻底步入了晚年。  失去市场号召力的诺基亚此时的地位一落千丈，对于 Symbian 的态度也是一日三变。曾一度把源代码挂在网站上任人下载，随后又宣布只面向企业用户开源。这时的诺基亚真的急了。不愿投奔机器人阵营沦落为硬件制作商的他，竟甘心跪倒在昔日手下败将的裙下。2011 年 12 月，Symbian Belle 正式更名为诺基亚 Belle。诺基亚连名字都不行再见的 Symbian 从此已经不复存在。  然而，这并不意味着 Symbian 彻底的灭亡。名字虽然没有了，但产品依旧没有改变，与其说它灭亡不如说它失去了原来那般强大的市场号召力。毕竟，凭借 S40 在低端市场的畅销，诺基亚还能在手机市场分的一杯羹。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:4","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"未来？未来！  向微软投怀送抱之后，诺基亚在 Symbian 的建树彻底才枯思竭。以至于不得不推出 808 这样依靠单一买点为噱头吸引市场关注的 “帐篷手机”。Symbian 的今生今世已经无话可说。而未来又在何方？原本打算有所期盼的笔者，本来打算对它的未来有所展望和揣测，不幸的是，本文截稿前的 1 月 24 日，诺基亚公布了 2012 年第四季度最新的财政业绩报告显示，该季度诺基亚实现净利润 2.02 亿欧元，告别 6 连亏，但同时诺基亚官方宣称去年在巴塞罗那发布的 808PureView 将会是最后一款塞班手机，这也意味着塞班这一已经被使用了 15 年之久的智能手机操作系统终于将告别市场，而诺基亚在智能手机领域也终于百分之百微软化。 诺基亚 CEO 斯蒂芬・埃洛普表示：“2012 财年上半年相对艰难，但第四财季表现强劲，设备和服务部门的运营利润率得到了改善。我们将继续执行既定的转移战略，包括继续提升产品竞争力，加速运营，管理成本等。”  因此，至少在看得见的未来，Symbian 已经没有了未来！ ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:5","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":"末了  无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。 信息 P.S. 谨以此文献给那些成长路上的人和事，Symbian 没了，坛子没有了，但我们都还在。这些有关我们青春的事逝去也就随他去了。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:6","tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/"},{"categories":["ChitChat"],"content":" Symbian、黑莓、苹果、微软、Android 五大手机系统，谁先会被淘汰？ ","date":"2010-04-12","objectID":"/mobile_phone_systems/:0:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"BlackBerry  这是一个很难预测的问题，先从黑莓说起吧，黑莓的成功是–针对高级白领和企业人士，提供企业移动办公的一体化解决方案，它让手机邮件发送变的更简单，所以它得到了众多商务人士及企业的青睐，但它在娱乐互联网上缺乏吸引力，一旦其它竞争对手加强在移动办公上的投入及创新，那么黑莓的优势将不复存在（最新的苹果系统 iOS4 已经加强了在企业方面的应用）。虽然它现在份额依然是世界第二、美国第一，但它依然会是第一个被淘汰的。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:1:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Symbian  Symbian 是因为诺基亚而存在的系统，它的兼容性是最差的，实用复杂，速度慢（尤其是上网速度）所以不被看好，之所以它一直以来是世界最大的智能手机系统，那是因为诺基亚的金子招牌在支撑着，除了诺基亚之外的 Symbian 手机（三星、索爱）一直以来销量都不理想。缺乏创新，所以它是第二个被淘汰的系统。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:2:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Android  Android 速度最快的系统，被大家都看好，但它不可能成为第二个苹果，因为它的软件开发平台是开源的，导致了不同版本的出现，中国移动就是最好的例子，现在中国移动自主系统的手机想升级到 Android 最新版本是很困难的，加上品牌、型号不一样，硬件配置及屏幕尺寸不同，导致了同一个游戏在不同品牌及型号之间有着不同的表现，而苹果可以让一个游戏在四代上都是最佳体显（这样可以让软件的开发者利益最大化，而不需要为不同型号手机做出修改），Android 不会被淘汰，也许它会成为世界最大手机系统，但它将会沦为大众系统，我相信不久它将成为山寨手机进军低端智能市场的利器…  最后才是苹果与微软在中高端市场上的巅峰对决… ","date":"2010-04-12","objectID":"/mobile_phone_systems/:3:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Microsoft  虽然现在微软的 PPC 已经被淘汰，但它的 WP7 即将上线，一个替代 PPC 的时代即将到来，从最近放出的 WP7 资料来看，它是非常强大的，拥有众多新功能，凭着微软在 PC 市场上的垄断地位，加上它与 PC 之间的强兼容性，相信它前景广阔。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:4:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"},{"categories":["ChitChat"],"content":"Apple  苹果是一个传奇，能让一款手机买到第三年而依然拥有强大的市场竞争力，不得不说这是一个奇迹，历史上可能只有摩托罗拉的 V998 可以与之相比了，但苹果还在续写传奇，第四代已经出来了，苹果开创了一个手机的新时代，三年了，没有一个对手可以打败它，超越它，它引领着手机一次次的潮流，一次次的把手机用户体验推向一个新的水准，拥有 22 万多个应用商店、加上音乐商店，图书商店，它再一次的把资源整合到了极致，把苹果所有的娱乐产品连成了一个整体，这是其它对手所没有的优势，所以苹果会一直传奇下去… 注意 本文写于 2010 年，时过境迁，有些事情似乎沿着上文预言发展，有些却不然。正如前文《Symbian 的前世今生》中所言：无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:5:0","tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/"}]