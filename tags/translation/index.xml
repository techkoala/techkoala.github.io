<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Translation - 标签 - TechKoala</title>
        <link>https://www.techkoala.top/tags/translation/</link>
        <description>Translation - 标签 - TechKoala</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 14 Jul 2020 23:25:54 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/tags/translation/" rel="self" type="application/rss+xml" /><item>
    <title>NAT系列1：认识NAT</title>
    <link>https://www.techkoala.top/nat/</link>
    <pubDate>Tue, 14 Jul 2020 23:25:54 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat/</guid>
    <description><![CDATA[<pre><code>一文概览NAT
</code></pre>
<h2 id="nat">NAT</h2>
<p>NAT（Network Address Translation，网络地址转换）在计算机网络中是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问互联网的私有网络中。</p>
<p>NAT从大类上都可以分为两类：<code>静态NAT</code>和<code>动态NAT</code>。</p>
<p><code>静态NAT</code>是管理员手动创建和维护映射，通常与NAT的入站类型相关联。</p>
<p><code>动态NAT</code>是路由器根据需要自动创建和维护映射，通常与NAT的出站类型相关联。</p>
<p>每个TCP/IP数据包都包含一个<code>源IP地址</code>、<code>源端口</code>、<code>目的IP地址</code>和<code>目的端口</code>。所有类型的NAT都会使用这些值创建NAT映射。</p>
<pre><code>例如，一个IP为`192.168.0.1`的内部客户机使用端口`56876`，经过NAT转变后IP变
为3.3.3.3（翻译后的源IP）和端口56876（源端口）连接到IP 2.2.2.2（目的IP地
址）的80端口（目的端口）。NAT使用原始内部IP和端口、翻译后IP和端口这4个值创建
一个映射。当数据包从网站返回到路由器时，使用与该映射相关值，NAT将数据包转发到
内部客户端。
</code></pre>
<h2 id="nat的四种类型">NAT的四种类型</h2>
<h3 id="全锥型natfull-cone-nat">全锥型NAT（Full Cone NAT)</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Full_Cone_NAT.png" title="/images/Network/NAT/Full_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Full_Cone_NAT.png" data-sub-html="<h2>全锥型NAT</h2>">
        
    </a><figcaption class="image-caption">全锥型NAT</figcaption>
    </figure>
<p>全锥型NAT是静态NAT，也是唯一一种永久开放端口的NAT，允许从<strong>任何外部主机</strong>进行入站连接。全锥型NAT将一个公共IP地址和端口映射到LAN IP和端口。任何外部主机都可以通过映射的NAT IP和端口向LAN IP发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的NAT也被称为端口转发。这是受限制最少的NAT类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。</p>
<pre><code>例如，我的电脑有一个网站在80端口上运行，我创建了一个一对一的规则，将路由器的
WAN IP 1.1.1.1映射到192.168.0.1，端口80映射到80端口。凡是在80端口向
1.1.1.1发送数据的外部主机都会被NAT转发到192.168.0.1 80端口。
</code></pre>
<p><strong>注意</strong>：端口号不必相同；我可以在56456端口上运行我的网站，但创建NAT映射，将80端口转发到56456端口。这样，外部客户端就会认为我的网站在80端口上，而在任何其他端口上的连接尝试都会被丢弃。</p>
<h3 id="受限锥形natrestricted-cone-nat">受限锥形NAT（Restricted Cone NAT）</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Restricted_Cone_NAT.png" title="/images/Network/NAT/Restricted_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Restricted_Cone_NAT.png" data-sub-html="<h2>受限锥形NAT</h2>">
        
    </a><figcaption class="image-caption">受限锥形NAT</figcaption>
    </figure>
<p>受限锥体NAT是动态NAT，它的工作方式与全锥型NAT相同，但会对进站的IP地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的IP地址。<strong>亦即需要内部主机首先发起连接的外部主机，才能被接受入站。</strong></p>
<pre><code>例如，我的电脑与一个网站(56.45.34.78)进行外向连接，源IP为192.168.0.1，源端
口为56723。NAT使用源端口56723创建一个（动态）映射到我的电脑。使用目的端口
56723（这是出站NAT的源端口）到达的源IP为56.45.34.78（网站IP）的数据包将被接
受，接着网站返回数据至我的PC。任何其他IP即使使用正确的56723端口进行连接尝试将
被丢弃。同样，即使正确的IP使用56723以外的目的端口进行的连接尝试也将被丢弃。
</code></pre>
<h3 id="端口受限锥型natport-restricted-cone-nat">端口受限锥型NAT（Port Restricted Cone NAT)</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Port_Restricted_Cone_NAT.png" title="/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-sub-html="<h2>端口受限锥型NAT</h2>">
        
    </a><figcaption class="image-caption">端口受限锥型NAT</figcaption>
    </figure>
<p>端口受限锥型NAT是动态NAT，它的作用与受限锥形NAT完全相同，但同时对端口进行限制。受限锥形NAT接受来自外部主机任何源端口的连接，而端口受限锥型NAT则进一步要求外部主机的源端口是固定的。</p>
<pre><code>例如，我的电脑在80端口（目标端口）上向网站IP 217.87.69.8建立了一个外向连接。
NAT将我的源IP 192.168.0.1映射到WAN IP 1.1.1.1和源端口56723。当网站发回
数据包时，它的源IP必须是217.87.69.8，目的端口是56723（就像一个受限锥型NAT），
但除此之外，还要求源端口必须是80。如果这三者中的任何一个不一样，端口受限锥型NAT
就会放弃连接。
</code></pre>
<h3 id="对称型natsymmetric-nat">对称型NAT（Symmetric NAT）</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Symmetric_NAT.png" title="/images/Network/NAT/Symmetric_NAT.png" data-thumbnail="/images/Network/NAT/Symmetric_NAT.png" data-sub-html="<h2>对称型NAT</h2>">
        
    </a><figcaption class="image-caption">对称型NAT</figcaption>
    </figure>
<p>对称型NAT是动态NAT，它限制的方式与端口受限锥型NAT完全相同，但处理NAT转换的方式不同。目前讨论的所有类型的NAT在NAT连接时都<strong>不会改变源端口</strong>。</p>
<pre><code>例如，当客户端使用IP 192.168.0.1和源端口56723访问互联网时，NAT将源IP改变为
56.35.67.35，但保持端口号不变，这被称为端口保留。
</code></pre>
<p>而对称型NAT会将端口改为<strong>随机生成的新端口</strong>，甚至是同一客户端到不同目的地的连接也会发生。<strong>亦即为每个连接创建唯一的映射</strong></p>
<pre><code>例如，在端口受限锥型NAT的例子上进行扩展，我的PC向网站IP 217.87.69.8和
56.76.87.98建立两个出站连接。我的电脑使用源IP 192.168.0.1和源端口56723进行
两个连接。到目前为止，在所有类型的NAT上，这两个连接都会被NAT化，只改变源IP地址
而保持源端口不变。然而这次，对称型NAT没有将源端口保留为56723，而是将其中一个连
接的源端口改为45765，另一个连接的源端口改为53132（随机）。这就为每个连接创建了
唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以217.87.69.8必须将
数据包发送到目的端口45765，56.76.87.98必须将数据包发送到端口53132，此外还需
要遵循端口受限锥型NAT的要求。
</code></pre>
<h2 id="对nat的正面评价">对NAT的正面评价</h2>
<ol>
<li>
<p>NAT在一定程度上缓解了IPv4地址短缺的问题，让更多的设备（间接）接入了互联网。</p>
</li>
<li>
<p>NAT全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有NAT功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为UDP的跨局域网的传输提供了方便。</p>
</li>
</ol>
<h2 id="对nat的批评">对NAT的批评</h2>
<ol>
<li>
<p>在一个具有NAT功能的路由器下的主机并没有获得真正的IP地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的TCP连接和无状态协议（比如UDP）无法实现。除非NAT路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。</p>
</li>
<li>
<p>端对端连接是被IAB委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为NAT是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地IP地址，所以他们必须通过NAT来访问ISP网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener noreffer">网络地址转换</a></p>
</li>
<li>
<p>[2] <a href="https://think-like-a-computer.com/2011/09/19/symmetric-nat/" target="_blank" rel="noopener noreffer">What you need to know about symmetric NAT</a></p>
</li>
<li>
<p>[3] <a href="https://portforward.com/nat-types/" target="_blank" rel="noopener noreffer">NAT Types Defined</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>深入浅出DNS解析</title>
    <link>https://www.techkoala.top/dns_update/</link>
    <pubDate>Thu, 02 Jul 2020 15:48:24 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_update/</guid>
    <description><![CDATA[<pre><code>DNS如何工作？当我们更新网站的DNS记录的时候到底发生了什么？更新后必须等待48小时才能生效吗？
为什么有的人看到的是新IP，有的人看到的是旧IP？
</code></pre>
<h2 id="dns分类">DNS分类</h2>
<p>我们知道，DNS服务器有两种：权威服务器（authoritative）和递归服务器（recursive）</p>
<p><code>权威DNS服务器（也称为名称服务器，NS，nameserver）</code>具有其所负责的每个域的IP地址数据库。</p>
<p>例如，<code>github.com</code>的权威DNS服务器是<code>NS-421.awsdNS-52.com</code></p>
<p>您可以像这样要求它提供<code>github.com</code>的IP:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dig @NS-421.awsdNS-52.com github.com
</code></pre></td></tr></table>
</div>
</div><p><code>递归DNS服务器</code>，本身并不知道谁拥有什么IP地址。它们通过询问正确的权威DNS服务器，找出域名的IP地址，然后缓存这个IP地址，以备再次询问。8.8.8.8是一个递归DNS服务器。</p>
<p>当人们访问你的网站时，他们可能会向递归DNS服务器进行DNS查询。那么，递归DNS服务器是如何工作的呢?</p>
<h3 id="递归dns服务器如何工作">递归DNS服务器如何工作</h3>
<p>以<code>8.8.8.8</code>为例，如果我们向其请求<code>github.com</code>的IP地址（A记录），如果它存在缓存，那么就直接返回缓存结果。然而，缓存是有期限的，如果所有缓存都过期了呢？那么情况是这样的：</p>
<ol>
<li>
<p>递归服务器内部硬编码（hardcoded）有根DNS服务器<code>.</code>的IP地址（参见[2][3]），选择一个根DNS服务器，例如<code>198.41.0.4</code></p>
</li>
<li>
<p>询问根DNS服务器有关<code>com.</code>的NS</p>
<p>此步可以使用如下方法模拟：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @198.41.0.4 github.com

...
com.			172800	IN	NS	a.gtld-servers.net.
...
a.gtld-servers.net.	172800	IN	A	192.5.6.30
...
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这里我们得到一个<code>com.</code>的权威NS<code>a.gtld-servers.net.</code>及其IP地址<code>192.5.6.30</code></p>
<p><strong>注</strong>：实际上，99.99%的情况下，此步我们就将得到<code>github.com</code>的A记录，但为了展示DNS解析进程，我们假设这里没有得到。</p>
</li>
<li>
<p>询问该权威NS有关<code>github.com</code>的NS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @192.5.6.30 github.com

...
github.com.		172800	IN	NS	NS-421.awsdNS-52.com.
NS-421.awsdNS-52.com.	172800	IN	A	205.251.193.165
... 
</code></pre></td></tr></table>
</div>
</div><p>这里，我们得到的<code>github.com.</code>NS<code>NS-421.awsdNS-52.com.</code>及其IP地址<code>205.251.193.165</code></p>
</li>
<li>
<p>询问该NS有关<code>github.com</code>的A记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @205.251.193.165 github.com

github.com.		60	IN	A	140.82.112.4
</code></pre></td></tr></table>
</div>
</div><p>至此，在假设没有缓存的情况下，我们通过完整的流程（实际上绝大多数情况不需要完整进行）获得了<code>github.com</code>的IP地址。</p>
</li>
</ol>
<p>此外，使用<code>$ dig @8.8.8.8 +trace github.com</code>可以一次性显示上述所有步骤。</p>
<h2 id="更新dns记录">更新DNS记录</h2>
<p>更新DNS记录时，有两种情况：</p>
<ol>
<li>
<p>保持相同的NS</p>
</li>
<li>
<p>变更NS</p>
</li>
</ol>
<h3 id="首先谈谈生存时间ttlstime-to-live">首先谈谈生存时间（TTLs，time to live）</h3>
<p>上面已经说到，DNS服务器一般存有缓存，而控制缓存是否过期的参数就是TTL。</p>
<p>我们假设得到一个查询结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @205.251.193.165 github.com

github.com.		60	IN	A	140.82.112.4
</code></pre></td></tr></table>
</div>
</div><p>这里的60（秒）即表示TTL，这是一个很短的TTL。理论上，如果每个用户都遵循DNS标准，那么<code>github.com</code>在更改了IP地址后，每个用户都应该在60秒内得到这个新的地址。但实际上呢？</p>
<h3 id="更新同一ns上的dns记录">更新同一NS上的DNS记录</h3>
<p>假设我们已经在域名商处更新了新的DNS记录<code>test.jvNS.ca</code>&ndash;&gt;<code>1.2.3.4</code>，试着查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 test.jvNS.ca

test.jvNS.ca.		299	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p>如果此前没有设置过DNS记录，因为没有缓存，所以立刻生效了。这里可以看到TTL是299。那么，修改IP为<code>5.6.7.8</code>呢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 test.jvNS.ca

test.jvNS.ca.		144	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p>可以看到，IP并没有发生改变且TTL表示缓存还将存在144秒。而且，多次查询，你可能会发现，有时候可以得到新的IP，但有的时候又是旧的IP。</p>
<p>这里是因为像<code>8.8.8.8</code>这样的DNS服务器采用了负载均衡，每次查询可能被分配到不同的后端服务器，而他们的缓存不尽相同。</p>
<p>等待5分钟后，所有的缓存都更新了，再次查询，将会始终返回新IP。</p>
<h3 id="ttl并非总是可靠">TTL并非总是可靠</h3>
<p>与大多数互联网协议一样，并不是所有的终端都服从DNS规范（包括<code>8.8.8.8</code>这样的大型DNS也不尊重TTL）。一些ISP的DNS服务器会将缓存记录的时间比TTL规定的时间长，比如可能是2天而不是5分钟。而且人们总是可以在他们的/etc/hosts中硬编码旧的IP地址。</p>
<p>此外，应用程序（例如浏览器）都内置了自己的DNS缓存，或者本地网关也存在缓存。</p>
<p>这也是为什么，即便正确地设置了对应的TTL（大部分DNS将会在短时间内更新缓存），有些DNS服务器仍然需要更长时间生效，这也导致我们的查询也并不总是会得到新的IP地址。</p>
<h3 id="连同ns一起更新">连同NS一起更新</h3>
<p>假设此前的NS为<code>dNS1.p01.NSone.net</code>，现在我们把他修改为谷歌的NS<code>NS-cloud-b1.googledomaiNS.com</code>。</p>
<p>通常，当你修改完成后，你的域名商会提示你：“修改将在48小时内生效”。</p>
<p>然后设置一个新的A记录指向<code>1.2.3.4</code></p>
<p>dig看看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 examplecat.com

examplecat.com.		17	IN	A	104.248.50.87
</code></pre></td></tr></table>
</div>
</div><p><code>8.8.8.8</code>没有变化，询问别的DNS：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @1.1.1.1 examplecat.com

examplecat.com.		299	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p><code>1.1.1.1</code>更新了。</p>
<p>造成这样不同结果的原因，可能是此前并没有人询问过<code>1.1.1.1</code>，所以他没有缓存，能立刻得到新的IP。</p>
<p>而如果我们向新的NS查询，肯定会得到新的IP记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @NS-cloud-b1.googledomaiNS.com examplecat.com

examplecat.com.		300	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><h3 id="ns的ttl要长很多">NS的TTL要长很多</h3>
<p>域名商提示：“修改将在48小时内生效”的原因是NS记录（告诉递归NS应该向哪个NS查询）的TTL要长的多。</p>
<p>回到上一节中，我们的查询结果显示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @192.5.6.30 github.com

...
github.com.		172800	IN	NS	NS-421.awsdNS-52.com.
NS-421.awsdNS-52.com.	172800	IN	A	205.251.193.165
...
</code></pre></td></tr></table>
</div>
</div><p>172800秒是48小时！这就是为什么更改NS后需要更长的时间来生效。</p>
<h3 id="ns如何得到更新">NS如何得到更新？</h3>
<p>更新NS后，我们向根服务器查询的话就会到得到这样的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig NS @j.gtld-servers.net examplecat.com

examplecat.com.		172800	IN	NS	NS-cloud-b1.googledomaiNS.com
</code></pre></td></tr></table>
</div>
</div><p>你可能会疑惑，新的NS记录是如何在根服务器处更新的呢？是因为当你在域名商那里更改你域名的NS后，他们会负责将这个给更改告知根服务器。</p>
<p>通常这个更新将在几分钟内就生效，但是对于其他一些顶级域名（TLD）（非.com）可能速度稍微慢一些。</p>
<h2 id="总结">总结</h2>
<p>本文展示了DNS的解析过程以及我们更新DNS记录时发送了什么，希望有助于你理解这一过程。</p>
<h2 id="说明">说明</h2>
<p><strong>注</strong>：本文属于<code>Translation</code>系列文章，本系列文章<strong>主要内容</strong>来源于博主对优秀外文文章地翻译和校对，这里并不一定遵循原文的叙述逻辑，内容上也会有一定的增删，原文请见参考。</p>
<p>译文的目的一方面是加深自己学习的印象，另外一方面是希望能够共享优质的内容。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://jvNS.ca/blog/how-updating-dNS-works/" target="_blank" rel="noopener noreffer">What happeNS when you update your DNS?</a></p>
</li>
<li>
<p>[2] <a href="https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131" target="_blank" rel="noopener noreffer">unbound’s source code</a></p>
</li>
<li>
<p>[3] <a href="https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131" target="_blank" rel="noopener noreffer">iana root files</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
