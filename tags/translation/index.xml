<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Translation - 标签 - TechKoala</title>
        <link>https://www.techkoala.top/tags/translation/</link>
        <description>Translation - 标签 - TechKoala</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 18 Jul 2020 10:28:05 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/tags/translation/" rel="self" type="application/rss+xml" /><item>
    <title>SCP 概览</title>
    <link>https://www.techkoala.top/scp/</link>
    <pubDate>Sat, 18 Jul 2020 10:28:05 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/scp/</guid>
    <description><![CDATA[<pre><code>SCP就是SSH协议的文件传输功能吗？
</code></pre>
<h2 id="什么是scp">什么是SCP</h2>
<p>SCP（Secure Copy Protocol，安全复制协议）允许我们在两台计算机之间复制文件（和目录）。</p>
<p>使用起来特别方便：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Shell" data-lang="Shell">$ scp local_file remote_host:/home
</code></pre></td></tr></table>
</div>
</div><p>这将把本地文件 <code>localfile</code> 复制到远程主机的 <code>/home</code> 文件之下。</p>
<p>SCP 使用起来特别便利，因为他能工作在几乎所有的 <code>Unix-like</code> 的系统中，并且 <code>Windows</code> 下拥有许多客户端。但是仅仅复制文件并不是关键。SCP 真正的价值是对 <strong>计算机的身份进行验证</strong> 以及对 <strong>传输文件进行加密</strong>（也就是 S 代表的含义）。</p>
<p>使用前需要首先配置到远程主机的 SSH 连接权限。SCP 的验证提示和 SSH 看起很像，因为 SCP 跑在 SSH 的上层，仅仅把它作为文件数据的管道。事实上，SSH 负责处理所有安全相关的任务，SCP 只是将一些文件扔到 SSH 连接上。</p>
<p>维基百科上的条目讲述了 SCP 的历史，简而言之：在旧的 BSD 系统上曾经有一个叫 RCP 的工具，可以在电脑之间移动文件。在当时受信任的网络时代，每个人都是别人的朋友。后来人们意识到，也许并不是每个人在他们的网络上都是这么好的朋友。于是有人把 RCP 的实现复制到 <code>OpenSSH</code> 的前身上，然后简单地在 SSH 会话上运行它，以保护文件不被非好友发现。问题解决了！从此以后，它就留在了 <code>OpenSSH</code> 中。</p>
<h2 id="scp-工作原理">SCP 工作原理</h2>
<p>SCP 并不是一个标准协议，白并没有一个 RFC 或者任何官方描述如何实现它。<code>OpenSSH</code> 实现是一个事实上的规范。此实现有两个部分：连接建立和之后的有线协议。</p>
<h3 id="连接建立">连接建立</h3>
<p>实际上，这并不是真正的连接。因为它只是利用 SSH 执行命令后的 <code>STDIN/STDOUT</code> ，有点类似Unix管道。OpenSSH中包含两个程序来完成:<code>sshd</code>和<code>scp</code>。<code>sshd</code>是始终运行的服务器守护进程，接受新的SSH连接。<code>scp</code>是伪装成ssh的客户端程序，发送和接受文件。</p>
<p>当<code>scp</code>运行时，他将开启一个新的SSH连接。在该连接上，它会在服务端执行另一个带有特殊标志的<code>scp</code>程序。你可以认为是<code>ssh exec scp [flags]</code>。主要的标志包含<code>-t</code>（&ldquo;to&rdquo;）和<code>-f</code>（&ldquo;from&rdquo;）用于代表接受和发送，而<code>-d</code>表示文件夹，<code>-r</code>表示递归。</p>
<a class="lightgallery" href="/images/Software/SCP/scp-1.png" title="/images/Software/SCP/scp-1.png" data-thumbnail="/images/Software/SCP/scp-1.png">
        
    </a>
<p>值得注意的是，SCP协议是单向的，一端发送文件，另一端接收文件。在远程端<code>scp</code>开始运行后，实际的SCP协议命令开始通过<code>STDIN</code>和<code>STDOUT</code>运行。</p>
<h3 id="有线协议">有线协议</h3>
<p>现在，安全的I/O通道建立起来，并且已经有效地切换到RCP协议上。该协议是<strong>顺序</strong>（一次一个操作）和<strong>同步</strong>（每个命令执行完后才执行下一个命令）执行的。</p>
<p>命令格式大致为（不带括号或空格）：<code>[command type][arguments]\n [optional data]</code></p>
<ul>
<li>
<p>[command type] 通常是一个 ASCII 字符：</p>
<ul>
<li>&lsquo;C&rsquo;- 写入文件</li>
<li>&lsquo;D&rsquo;- 输入目录</li>
<li>&lsquo;E&rsquo;- 退出最后一个目录</li>
<li>&lsquo;T&rsquo;- 设置下一个文件或目录的创建 / 更新时间戳</li>
</ul>
</li>
<li>
<p>[arguments] 是特定于命令的，如文件 / 目录名称、文件大小或时间戳。&ldquo;E&rdquo; 命令没有参数。</p>
</li>
<li>
<p>[optional data] 在上一个命令为 &ldquo;C&rdquo;（创建文件）时发送。数据的大小指定为 &ldquo;C&rdquo; 的参数。</p>
</li>
</ul>
<p>此外，还有控制字节，这些字节是在没有新行的情况下自己发送的：</p>
<ul>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;OK&rdquo;，确认完成最后一个命令（如编写本地文件）。接收方也会在启动时发送此消息，让发送方知道它已准备好接收命令。</p>
</li>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;警告&rdquo;，后面是要向用户显示的行（由新行终止）。</p>
</li>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;错误&rdquo; 后跟随可选消息（和警告相同），但连接随后终止。</p>
</li>
</ul>
<p>下面这个带有注释的图片实例，详细讲述了这个过程：</p>
<a class="lightgallery" href="/images/Software/SCP/scp-2.png" title="/images/Software/SCP/scp-2.png" data-thumbnail="/images/Software/SCP/scp-2.png">
        
    </a>
<h2 id="scp-的问题">SCP 的问题</h2>
<p>看起来，SCP 听起来似乎没什么问题。它是一个简单易用的工具，然而存在一些现实问题。</p>
<h3 id="性能">性能</h3>
<p>有线协议的顺序性：每个命令的强制确认都会增加大量开销。例如，如果沿途丢弃单个确认数据包，则整个连接将暂停，直到重新传输开始。最重要的是，发送所有数据而不压缩或询问接收方是否已经拥有该文件并不理想。</p>
<p>有经验的系统管理员可以告诉您，使用 <code>tar</code> 归档文件并发送比使用 <code>scp</code> 递归命令传输要快得多。事实上，这样的话你甚至无需使用 SCP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Shell" data-lang="Shell"><span class="c1"># Copy a local folder with 10000 files</span>
$ find /tmp/big_folder/ -type f <span class="p">|</span> wc -l
<span class="m">10000</span>

<span class="c1"># Using scp</span>
$ <span class="nb">time</span> scp -r -q /tmp/big_folder/ server:/tmp/big_folder

________________________________________________________
Executed in  882.99 millis	fish       	external
   usr <span class="nb">time</span>  114.09 millis	0.00 micros  114.09 millis
   sys <span class="nb">time</span>  278.46 millis  949.00 micros  277.51 millis

<span class="c1"># Using tar over ssh</span>
$ <span class="nb">time</span> sh -c <span class="s2">&#34;tar cf - /tmp/big_folder | ssh server &#39;tar xC /tmp/ -f -&#39;&#34;</span>
tar: Removing leading <span class="s1">&#39;/&#39;</span> from member names

________________________________________________________
Executed in  215.68 millis	fish       	external
   usr <span class="nb">time</span>   93.22 millis	0.00 micros   93.22 millis
   sys <span class="nb">time</span>   66.51 millis  897.00 micros   65.62 millis
</code></pre></td></tr></table>
</div>
</div><p>在这种比较糟糕的情况下，tar&amp;ssh 的 215.68ms 对比 SCP 的 882.99ms，足足有四倍的速度提升。</p>
<h3 id="安全">安全</h3>
<p>我们已经知道，SCP 靠 SSH 负担安全工作，因此它完全安全&hellip; 吗？</p>
<p>OpenSSH 的发行说明提到：</p>
<pre><code>scp 协议已经过时、不灵活且不容易修复。我们建议使用更现代的协议，如 sftp 和 rsync 来传输文件。
</code></pre>
<p>如果远程端的 shell 打印出任何非交互式会话，则本地 scp 进程将愉快地将该输出解释为 SCP 命令。好的话，这仅仅是打破 SCP 协议中模糊的错误。但在最坏的情况下，远程 shell 启动脚本是恶意的，并向你发送恶意文件，而不是所需的文件。</p>
<p>此外，早在 2018 年，Harry Sintonen 就发现了流行的 SCP 实现（包括 OpenSSH）中的一堆漏洞。包括从修改目录的权限到覆盖任意文件（由于～/.ssh/authorized_keys 或～/.bashrc）、有效地执行代码，以及注入终端转义序列来隐藏任何追踪。这些漏洞对于任何构建网络 CLI 应用程序的人来说都是一个很好的教训。</p>
<h2 id="scp-的替代方案">SCP 的替代方案</h2>
<p>SFTP 被广泛认为是 SCP 的继承者。为了传输层安全性，它仍然在 SSH 上运行，并且不需要单独设置访问。它可以为您提供一个自定义交互式提示来探索远程文件系统，或者您可以使用预先编写的一系列命令编写脚本。
缺点是，您需要学习 SFTP 提示命令，协议本身尚未完全标准化（有很多 RFC 草稿，但作者最终放弃了）。</p>
<p>Rsync 是另一个很好的选择。使用与 scp 命令完全相同 - 它也利用 SSH。Rsync 着重优化性能 - 它执行大量的复杂本地计算从而通过网络发送尽可能少的数据。从技术上讲，它致力于数据同步而不是纯传输文件 - 如果远程和本地内容相似，则只会发送增量。</p>
<p>同样，它也有其自身的缺点：发送方使用大量的 CPU 资源来计算要发送什么，并且接收方使用大量磁盘 IO 将数据按正确的顺序放在一起。与 OpenSSH 不同，Rsync 在大多数系统上并不预安装。</p>
<h2 id="结论">结论</h2>
<p>SCP 是一个简单的工具，它在复制文件方面做得很好，但较新的软件在很多方面都优于它。对于您信任的计算机之间的个人简单使用，SCP 仍然适合。</p>
<p>但是，如果您遇到性能问题或需要满足更高的安全标准，则上面列出的任何备选方案都比 SCP 更可取。选择最适合您需求的，然后试着开始使用。</p>
<h2 id="see-also">See also</h2>
<p>后面的文章将会进一步讲解 SFTP 以及 Rsync。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://gravitational.com/blog/scp-familiar-simple-insecure-slow/" target="_blank" rel="noopener noreffer">SCP - Familiar, Simple, Insecure, and Slow</a></p>
</li>
<li>
<p>[2] <a href="https://en.wikipedia.org/wiki/Secure_copy" target="_blank" rel="noopener noreffer">Wikipedia Secure copy</a></p>
</li>
<li>
<p>[3] <a href="https://lists.mindrot.org/pipermail/openssh-unix-dev/2019-March/037672.html" target="_blank" rel="noopener noreffer">Call for testing: OpenSSH 8.0</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>NAT 系列 2：NAT 引发的问题以及解决方法</title>
    <link>https://www.techkoala.top/nat_issues_solutions/</link>
    <pubDate>Wed, 15 Jul 2020 14:19:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat_issues_solutions/</guid>
    <description><![CDATA[<pre><code>NAT 引发的问题以及解决方法
</code></pre>
<h2 id="问题">问题</h2>
<p>对称型 NAT（Symmetric NAT）常常在游玩联机游戏（尤其是 P2P 联机方式）时候给我们造成困扰。如果 Xbox、PS、switch 或者 PC 上的应用程序报告 NAT 是严格、类型 3、类型 D、对称这样的字样，那么就意味着你将会出现联机问题。</p>
<p>理解这个问题之前，首先要认识到，这些设备及软件是无法感知它们是否被 NAT 化的。但是，在 Internet 上与之通信的任何设备都应该使用公共 IP 地址，例如 1.1.1.1。在进行任何连接尝试时，都必须知道目标公共 IP 地址和端口。在上面的所有示例中，你应该发现了网站 IP 地址和端口均已知，这些地址是固定的，并且未曾发生更改。但是，某些程序会使用一系列动态端口。在运行游戏时，你的主机选择一个随机端口来进行游戏。由于其他主机不知道你的 IP 地址或端口，因此必须在连接之前以某种方式了解它。你的主机会将游戏的 IP 地址和端口发送到 Xbox Live 或 PS 网络，这样其他主机便可以在其中检索它，然后直接与你连接。但问题是，它发送的是内部 IP 地址 192.168.0.1 和端口 54324，而不是 Nat 后的公共 IP。它应该发送的是（例如）1.1.1.1 的公共 IP 地址和端口 54324。而且当处于对称型 NAT 时，该端口也会发生更改，因此它必须发送经过 NAT 处理的端口，例如 54254，而不是主机本身的内部端口（54324）。</p>
<p>** 这不仅仅是游戏面对的问题，这一直是 NAT 的问题。**</p>
<p>那么，主机如何得知它位于 NAT 之后，并告诉其他主机将数据发送到 NAT 后的 IP 地址和端口而不是其自身的内部 IP 地址和端口？</p>
<h2 id="解决办法">解决办法</h2>
<h3 id="stunsession-traversal-utilities">STUN（Session Traversal Utilities）</h3>
<p>Stun 是 NAT 的 Session Traversal Utilities 的缩写，你可能已经猜到了它的名字，它是一个实用工具的集合，以帮助 NAT 设备穿越内网。简单地说，STUN 允许你的主机 / PC 或内部设备了解它的公共 NAT 的 IP 地址和端口是什么。一旦实现了这一点，你的设备现在可以发送正确的 IP 和端口，其他设备也可以连接到你。但是，它在对称型 NAT 下无法工作，在对称型 NAT 中，你的主机可以得知它的公共 IP 地址，但无法得知它的公共端口（因为，端口是 NAT 随机生成的）。</p>
<p>STUN 的工作原理很简单。你连接到一个运行 STUN 协议的服务器 (Xbox Live Servers)，它从接收的数据包中读取源 IP 地址和源端口，这些当然会是 NAT 后的（这是我们需要的）。然后 STUN 将这些信息返回给客户端，它的工作就完成了。你的主机现在知道了它的 NAT 后的 IP 和端口，并且会把这些信息发送到其他设备上。</p>
<figure><a class="lightgallery" href="/images/Network/NAT/STUN_Algorithm.png" title="/images/Network/NAT/STUN_Algorithm.png" data-thumbnail="/images/Network/NAT/STUN_Algorithm.png" data-sub-html="<h2>STUN 算法</h2>">
        
    </a><figcaption class="image-caption">STUN 算法</figcaption>
    </figure>
<p>如果你还记得，除了对称型 NAT 之外，所有其他类型的 NAT 都不会改变源端口。这意味着当我的主机创建一个 NAT 映射时，它将对所有这种类型的连接使用它，当向互联网上的个设备发送和接收数据包时，它使用同一个映射，因此它使用相同的公共 IP 地址和端口；</p>
<p>但在对称型 NAT 的情况下，每一个连接都有一个不同的映射，有一个不同的（随机生成的）端口，意味着连接到 STUN 服务器也将有它自己独特的映射，表现的就像一个新的设备接入一样。这意味着每个映射都有不同的端口，在这种情况下，STUN 检测到的端口现在已经没有用了，因为这个映射是 STUN 服务器独有的。无论映射到其他设备的端口是什么，都是未知的，STUN 也没有办法检测到它。由于你的主机无法得知每个映射到每个主机的公共 NAT 化端口，因此无法将这些信息传递给你，也就意味着没有设备可以连接到你的游戏，这就是对称型 NAT 导致如此多游戏联机问题的原因。</p>
<h3 id="dmzdemilitarized-zone">DMZ（Demilitarized zone)</h3>
<p>路由器上的外围网络（也称 DMZ）功能用于消除对 Internet 的限制。它主要是将你的设备移到你的网络防火墙之外的区域，将部分用于提供对外服务的服务器主机划分到一个特定的子网 ——DMZ 内，在 DMZ 的主机能与同处 DMZ 内的主机和外部网络的主机通信，而同内部网络主机的通信会被受到限制。这使 DMZ 的主机能被内部网络和外部网络所访问，而内部网络又能避免外部网络所得知。</p>
<p><strong>注意</strong> 当你设置外围网络时在主机上使用静态 IP 地址十分重要。要设置静态 IP 地址，请使用路由器的 DHCP 预留功能（如果可用）。如果该功能不可用，你将需要在你的设备 上配置手动 IP 设置。</p>
<h3 id="upnpuniversal-plug-and-play">UPnP（Universal Plug and Play）</h3>
<p>UPnP（Universal Plug and Play）是帮助路由器有效通信的一个标准。如果路由器或网关支持 UPnP，则它在默认情况下可能已启用。开启 UPnP 功能后，局域网中的计算机可以请求路由器自动进行端口转换。这样，互联网上的计算机就能在需要时访问局域网计算机上的资源（如 MSN Messenger 或迅雷、BT、PPLive 等支持 UPnP 协议的应用程序）。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="www.think-like-a-computer.com/2011/09/19/symmetric-nat/" rel="">Symmetric NAT and It’s Problems | Think Like A Computer</a></p>
</li>
<li>
<p>[2] <a href="https://zh.wikipedia.org/wiki/STUN" target="_blank" rel="noopener noreffer">Wikipedia STUN</a></p>
</li>
<li>
<p>[3] <a href="https://zh.wikipedia.org/wiki/DMZ" target="_blank" rel="noopener noreffer">Wikipedia DMZ</a></p>
</li>
<li>
<p>[4] <a href="https://support.xbox.com/help/Hardware-Network/connect-network/xbox-one-nat-error" target="_blank" rel="noopener noreffer">解决 NAT 错误和多人游戏问题</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>NAT 系列 1：认识 NAT</title>
    <link>https://www.techkoala.top/nat/</link>
    <pubDate>Tue, 14 Jul 2020 23:25:54 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat/</guid>
    <description><![CDATA[<pre><code>一文概览 NAT
</code></pre>
<h2 id="nat">NAT</h2>
<p>NAT（Network Address Translation，网络地址转换）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。</p>
<p>NAT 从大类上都可以分为两类：<code>静态 NAT</code> 和 <code>动态 NAT</code>。</p>
<p><code>静态 NAT</code> 是管理员手动创建和维护映射，通常与 NAT 的入站类型相关联。</p>
<p><code>动态 NAT</code> 是路由器根据需要自动创建和维护映射，通常与 NAT 的出站类型相关联。</p>
<p>每个 TCP/IP 数据包都包含一个 <code>源 IP 地址</code>、<code>源端口</code>、<code>目的 IP 地址</code> 和 <code>目的端口</code>。所有类型的 NAT 都会使用这些值创建 NAT 映射。</p>
<pre><code>例如，一个 IP 为 `192.168.0.1` 的内部客户机使用端口 `56876`，经过 NAT 转
变后 IP 变为 3.3.3.3（翻译后的源 IP）和端口 56876（源端口）连接到 IP 
2.2.2.2（目的 IP 地址）的 80 端口（目的端口）。NAT 使用原始内部 IP 和端口、
翻译后 IP 和端口这 4 个值创建一个映射。当数据包从网站返回到路由器时，使用与该
映射相关值，NAT 将数据包转发到内部客户端。
</code></pre>
<h2 id="nat-的四种类型">NAT 的四种类型</h2>
<h3 id="全锥型-natfull-cone-nat">全锥型 NAT（Full Cone NAT)</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Full_Cone_NAT.png" title="/images/Network/NAT/Full_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Full_Cone_NAT.png" data-sub-html="<h2>全锥型 NAT</h2>">
        
    </a><figcaption class="image-caption">全锥型 NAT</figcaption>
    </figure>
<p>全锥型 NAT 是静态 NAT，也是唯一一种永久开放端口的 NAT，允许从 ** 任何外部主机 ** 进行入站连接。全锥型 NAT 将一个公共 IP 地址和端口映射到 LAN IP 和端口。任何外部主机都可以通过映射的 NAT IP 和端口向 LAN IP 发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的 NAT 也被称为端口转发。这是受限制最少的 NAT 类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。</p>
<pre><code>例如，我的电脑有一个网站在 80 端口上运行，我创建了一个一对一的规则，将路由器的
WAN IP 1.1.1.1 映射到 192.168.0.1，端口 80 映射到 80 端口。凡是在 80 端
口向 1.1.1.1 发送数据的外部主机都会被 NAT 转发到 192.168.0.1 80 端口。
</code></pre>
<p>** 注意：** 端口号不必相同；我可以在 56456 端口上运行我的网站，但创建 NAT 映射，将 80 端口转发到 56456 端口。这样，外部客户端就会认为我的网站在 80 端口上，而在任何其他端口上的连接尝试都会被丢弃。</p>
<h3 id="受限锥形-natrestricted-cone-nat">受限锥形 NAT（Restricted Cone NAT）</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Restricted_Cone_NAT.png" title="/images/Network/NAT/Restricted_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Restricted_Cone_NAT.png" data-sub-html="<h2>受限锥形 NAT</h2>">
        
    </a><figcaption class="image-caption">受限锥形 NAT</figcaption>
    </figure>
<p>受限锥体 NAT 是动态 NAT，它的工作方式与全锥型 NAT 相同，但会对进站的 IP 地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的 IP 地址。** 亦即需要内部主机首先发起连接的外部主机，才能被接受入站。**</p>
<pre><code>例如，我的电脑与一个网站 (56.45.34.78) 进行外向连接，源 IP 为 192.168.0.1，
源端口为 56723。NAT 使用源端口 56723 创建一个（动态）映射到我的电脑。使用目
的端口 56723（这是出站 NAT 的源端口）到达的源 IP 为 56.45.34.78（网站 IP）
的数据包将被接受，接着网站返回数据至我的 PC。任何其他 IP 即使使用正确的 56723 
端口进行连接尝试将被丢弃。同样，即使正确的 IP 使用 56723 以外的目的端口进行的
连接尝试也将被丢弃。
</code></pre>
<h3 id="端口受限锥型-natport-restricted-cone-nat">端口受限锥型 NAT（Port Restricted Cone NAT)</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Port_Restricted_Cone_NAT.png" title="/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-sub-html="<h2>端口受限锥型 NAT</h2>">
        
    </a><figcaption class="image-caption">端口受限锥型 NAT</figcaption>
    </figure>
<p>端口受限锥型 NAT 是动态 NAT，它的作用与受限锥形 NAT 完全相同，但同时对端口进行限制。受限锥形 NAT 接受来自外部主机任何源端口的连接，而端口受限锥型 NAT 则进一步要求外部主机的源端口是固定的。</p>
<pre><code>例如，我的电脑在 80 端口（目标端口）上向网站 IP 217.87.69.8 建立了一个外向连
接。NAT 将我的源 IP 192.168.0.1 映射到 WAN IP 1.1.1.1 和源端口 56723。当
网站发回数据包时，它的源 IP 必须是 217.87.69.8，目的端口是 56723（就像一个
受限锥型 NAT），但除此之外，还要求源端口必须是 80。如果这三者中的任何一个不一
样，端口受限锥型 NAT 就会放弃连接。
</code></pre>
<h3 id="对称型-natsymmetric-nat">对称型 NAT（Symmetric NAT）</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Symmetric_NAT.png" title="/images/Network/NAT/Symmetric_NAT.png" data-thumbnail="/images/Network/NAT/Symmetric_NAT.png" data-sub-html="<h2>对称型 NAT</h2>">
        
    </a><figcaption class="image-caption">对称型 NAT</figcaption>
    </figure>
<p>对称型 NAT 是动态 NAT，它限制的方式与端口受限锥型 NAT 完全相同，但处理 NAT 转换的方式不同。目前讨论的所有类型的 NAT 在 NAT 连接时都 ** 不会改变源端口 **。</p>
<pre><code>例如，当客户端使用 IP 192.168.0.1 和源端口 56723 访问互联网时，NAT 将源 IP 
改变为 56.35.67.35，但保持端口号不变，这被称为端口保留。
</code></pre>
<p>而对称型 NAT 会将端口改为 ** 随机生成的新端口 <strong>，甚至是同一客户端到不同目的地的连接也会发生。</strong> 亦即为每个连接创建唯一的映射 **</p>
<pre><code>例如，在端口受限锥型 NAT 的例子上进行扩展，我的 PC 向网站 IP 217.87.69.8 和
56.76.87.98 建立两个出站连接。我的电脑使用源 IP 192.168.0.1 和源端口 56723 进行
两个连接。到目前为止，在所有类型的 NAT 上，这两个连接都会被 NAT 化，只改变源 IP 地址
而保持源端口不变。然而这次，对称型 NAT 没有将源端口保留为 56723，而是将其中一个连
接的源端口改为 45765，另一个连接的源端口改为 53132（随机）。这就为每个连接创建了
唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以 217.87.69.8 必须将
数据包发送到目的端口 45765，56.76.87.98 必须将数据包发送到端口 53132，此外还需
要遵循端口受限锥型 NAT 的要求。
</code></pre>
<h2 id="对-nat-的正面评价">对 NAT 的正面评价</h2>
<ol>
<li>
<p>NAT 在一定程度上缓解了 IPv4 地址短缺的问题，让更多的设备（间接）接入了互联网。</p>
</li>
<li>
<p>NAT 全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT 依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为 UDP 的跨局域网的传输提供了方便。</p>
</li>
</ol>
<h2 id="对-nat-的批评">对 NAT 的批评</h2>
<ol>
<li>
<p>在一个具有 NAT 功能的路由器下的主机并没有获得真正的 IP 地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的 TCP 连接和无状态协议（比如 UDP）无法实现。除非 NAT 路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。</p>
</li>
<li>
<p>端对端连接是被 IAB 委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为 NAT 是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地 IP 地址，所以他们必须通过 NAT 来访问 ISP 网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。</p>
</li>
<li>
<p>NAT 使得 IP 协议从面向无连接变成立面向连接。NAT 必须维护专用 IP 地址与公用 IP 地址以及端口号的映射关系。在 TCP/IP 协议体系中，如果一个路由器出现故障，不会影响到 TCP 协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在 NAT 时，最初设计的 TCP/IP 协议过程将发生变化，Internet 可能变得非常脆弱。</p>
</li>
<li>
<p>NAT 违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第 N 层是不能修改第 N+1 层的报头内容的。NAT 破坏了这种各层独立的原则。</p>
</li>
<li>
<p>NAT 同时存在对高层协议和安全性的影响问题。RFC 对 NAT 存在的问题进行了讨论。NAT 的反对者认为这种临时性的缓解 IP 地址短缺的方案推迟了 IPv6 迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener noreffer">Wikipedia NAT</a></p>
</li>
<li>
<p>[2] <a href="https://think-like-a-computer.com/2011/09/19/symmetric-nat/" target="_blank" rel="noopener noreffer">What you need to know about symmetric NAT | Think Like A Computer</a></p>
</li>
<li>
<p>[3] <a href="https://portforward.com/nat-types/" target="_blank" rel="noopener noreffer">NAT Types Defined</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>深入浅出 DNS 解析</title>
    <link>https://www.techkoala.top/dns_update/</link>
    <pubDate>Thu, 02 Jul 2020 15:48:24 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_update/</guid>
    <description><![CDATA[<pre><code>DNS 如何工作？当我们更新网站的 DNS 记录的时候到底发生了什么？更新后必须等待 48 小时才能生效吗？
为什么有的人看到的是新 IP，有的人看到的是旧 IP？
</code></pre>
<h2 id="dns-分类">DNS 分类</h2>
<p>我们知道，DNS 服务器有两种：权威服务器（authoritative）和递归服务器（recursive）</p>
<p><code>权威 DNS 服务器（也称为名称服务器，NS，nameserver）</code> 具有其所负责的每个域的 IP 地址数据库。</p>
<p>例如，<code>github.com</code> 的权威 DNS 服务器是 <code>NS-421.awsdNS-52.com</code></p>
<p>您可以像这样要求它提供 <code>github.com</code> 的 IP:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dig @NS-421.awsdNS-52.com github.com
</code></pre></td></tr></table>
</div>
</div><p><code>递归 DNS 服务器</code>，本身并不知道谁拥有什么 IP 地址。它们通过询问正确的权威 DNS 服务器，找出域名的 IP 地址，然后缓存这个 IP 地址，以备再次询问。8.8.8.8 是一个递归 DNS 服务器。</p>
<p>当人们访问你的网站时，他们可能会向递归 DNS 服务器进行 DNS 查询。那么，递归 DNS 服务器是如何工作的呢？</p>
<h3 id="递归-dns-服务器如何工作">递归 DNS 服务器如何工作</h3>
<p>以 <code>8.8.8.8</code> 为例，如果我们向其请求 <code>github.com</code> 的 IP 地址（A 记录），如果它存在缓存，那么就直接返回缓存结果。然而，缓存是有期限的，如果所有缓存都过期了呢？那么情况是这样的：</p>
<ol>
<li>
<p>递归服务器内部硬编码（hardcoded）有根 DNS 服务器 <code>.</code> 的 IP 地址（参见 [2][3]），选择一个根 DNS 服务器，例如 <code>198.41.0.4</code></p>
</li>
<li>
<p>询问根 DNS 服务器有关 <code>com.</code> 的 NS</p>
<p>此步可以使用如下方法模拟：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @198.41.0.4 github.com

...
com.			172800	IN	NS	a.gtld-servers.net.
...
a.gtld-servers.net.	172800	IN	A	192.5.6.30
...
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这里我们得到一个 <code>com.</code> 的权威 NS<code>a.gtld-servers.net.</code> 及其 IP 地址 <code>192.5.6.30</code></p>
<p><strong>注</strong>：实际上，99.99% 的情况下，此步我们就将得到 <code>github.com</code> 的 A 记录，但为了展示 DNS 解析进程，我们假设这里没有得到。</p>
</li>
<li>
<p>询问该权威 NS 有关 <code>github.com</code> 的 NS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @192.5.6.30 github.com

...
github.com.		172800	IN	NS	NS-421.awsdNS-52.com.
NS-421.awsdNS-52.com.	172800	IN	A	205.251.193.165
... 
</code></pre></td></tr></table>
</div>
</div><p>这里，我们得到的 <code>github.com.</code>NS<code>NS-421.awsdNS-52.com.</code> 及其 IP 地址 <code>205.251.193.165</code></p>
</li>
<li>
<p>询问该 NS 有关 <code>github.com</code> 的 A 记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @205.251.193.165 github.com

github.com.		60	IN	A	140.82.112.4
</code></pre></td></tr></table>
</div>
</div><p>至此，在假设没有缓存的情况下，我们通过完整的流程（实际上绝大多数情况不需要完整进行）获得了 <code>github.com</code> 的 IP 地址。</p>
</li>
</ol>
<p>此外，使用 <code>$ dig @8.8.8.8 +trace github.com</code> 可以一次性显示上述所有步骤。</p>
<h2 id="更新-dns-记录">更新 DNS 记录</h2>
<p>更新 DNS 记录时，有两种情况：</p>
<ol>
<li>
<p>保持相同的 NS</p>
</li>
<li>
<p>变更 NS</p>
</li>
</ol>
<h3 id="首先谈谈生存时间ttlstime-to-live">首先谈谈生存时间（TTLs，time to live）</h3>
<p>上面已经说到，DNS 服务器一般存有缓存，而控制缓存是否过期的参数就是 TTL。</p>
<p>我们假设得到一个查询结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @205.251.193.165 github.com

github.com.		60	IN	A	140.82.112.4
</code></pre></td></tr></table>
</div>
</div><p>这里的 60（秒）即表示 TTL，这是一个很短的 TTL。理论上，如果每个用户都遵循 DNS 标准，那么 <code>github.com</code> 在更改了 IP 地址后，每个用户都应该在 60 秒内得到这个新的地址。但实际上呢？</p>
<h3 id="更新同一-ns-上的-dns-记录">更新同一 NS 上的 DNS 记录</h3>
<p>假设我们已经在域名商处更新了新的 DNS 记录 <code>test.jvNS.ca</code>&ndash;&gt;<code>1.2.3.4</code>，试着查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 test.jvNS.ca

test.jvNS.ca.		299	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p>如果此前没有设置过 DNS 记录，因为没有缓存，所以立刻生效了。这里可以看到 TTL 是 299。那么，修改 IP 为 <code>5.6.7.8</code> 呢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 test.jvNS.ca

test.jvNS.ca.		144	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p>可以看到，IP 并没有发生改变且 TTL 表示缓存还将存在 144 秒。而且，多次查询，你可能会发现，有时候可以得到新的 IP，但有的时候又是旧的 IP。</p>
<p>这里是因为像 <code>8.8.8.8</code> 这样的 DNS 服务器采用了负载均衡，每次查询可能被分配到不同的后端服务器，而他们的缓存不尽相同。</p>
<p>等待 5 分钟后，所有的缓存都更新了，再次查询，将会始终返回新 IP。</p>
<h3 id="ttl-并非总是可靠">TTL 并非总是可靠</h3>
<p>与大多数互联网协议一样，并不是所有的终端都服从 DNS 规范（包括 <code>8.8.8.8</code> 这样的大型 DNS 也不尊重 TTL）。一些 ISP 的 DNS 服务器会将缓存记录的时间比 TTL 规定的时间长，比如可能是 2 天而不是 5 分钟。而且人们总是可以在他们的 /etc/hosts 中硬编码旧的 IP 地址。</p>
<p>此外，应用程序（例如浏览器）都内置了自己的 DNS 缓存，或者本地网关也存在缓存。</p>
<p>这也是为什么，即便正确地设置了对应的 TTL（大部分 DNS 将会在短时间内更新缓存），有些 DNS 服务器仍然需要更长时间生效，这也导致我们的查询也并不总是会得到新的 IP 地址。</p>
<h3 id="连同-ns-一起更新">连同 NS 一起更新</h3>
<p>假设此前的 NS 为 <code>dNS1.p01.NSone.net</code>，现在我们把他修改为谷歌的 NS<code>NS-cloud-b1.googledomaiNS.com</code>。</p>
<p>通常，当你修改完成后，你的域名商会提示你：“修改将在 48 小时内生效”。</p>
<p>然后设置一个新的 A 记录指向 <code>1.2.3.4</code></p>
<p>dig 看看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 examplecat.com

examplecat.com.		17	IN	A	104.248.50.87
</code></pre></td></tr></table>
</div>
</div><p><code>8.8.8.8</code> 没有变化，询问别的 DNS：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @1.1.1.1 examplecat.com

examplecat.com.		299	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p><code>1.1.1.1</code> 更新了。</p>
<p>造成这样不同结果的原因，可能是此前并没有人询问过 <code>1.1.1.1</code>，所以他没有缓存，能立刻得到新的 IP。</p>
<p>而如果我们向新的 NS 查询，肯定会得到新的 IP 记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @NS-cloud-b1.googledomaiNS.com examplecat.com

examplecat.com.		300	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><h3 id="ns-的-ttl-要长很多">NS 的 TTL 要长很多</h3>
<p>域名商提示：“修改将在 48 小时内生效” 的原因是 NS 记录（告诉递归 NS 应该向哪个 NS 查询）的 TTL 要长的多。</p>
<p>回到上一节中，我们的查询结果显示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @192.5.6.30 github.com

...
github.com.		172800	IN	NS	NS-421.awsdNS-52.com.
NS-421.awsdNS-52.com.	172800	IN	A	205.251.193.165
...
</code></pre></td></tr></table>
</div>
</div><p>172800 秒是 48 小时！这就是为什么更改 NS 后需要更长的时间来生效。</p>
<h3 id="ns-如何得到更新">NS 如何得到更新？</h3>
<p>更新 NS 后，我们向根服务器查询的话就会到得到这样的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig NS @j.gtld-servers.net examplecat.com

examplecat.com.		172800	IN	NS	NS-cloud-b1.googledomaiNS.com
</code></pre></td></tr></table>
</div>
</div><p>你可能会疑惑，新的 NS 记录是如何在根服务器处更新的呢？是因为当你在域名商那里更改你域名的 NS 后，他们会负责将这个给更改告知根服务器。</p>
<p>通常这个更新将在几分钟内就生效，但是对于其他一些顶级域名（TLD）（非.com）可能速度稍微慢一些。</p>
<h2 id="总结">总结</h2>
<p>本文展示了 DNS 的解析过程以及我们更新 DNS 记录时发送了什么，希望有助于你理解这一过程。</p>
<h2 id="说明">说明</h2>
<p><strong>说明：<strong>本文属于 <code>Translation</code> 系列文章，本系列文章</strong>主要内容</strong>来源于博主对优秀外文文章地翻译和校对，这里并不一定遵循原文的叙述逻辑，内容上也会有一定的增删，原文请见参考。</p>
<p>译文的目的一方面是加深自己学习的印象，另外一方面是希望能够共享优质的内容。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://jvNS.ca/blog/how-updating-dNS-works/" target="_blank" rel="noopener noreffer">What happeNS when you update your DNS?</a></p>
</li>
<li>
<p>[2] <a href="https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131" target="_blank" rel="noopener noreffer">unbound’s source code</a></p>
</li>
<li>
<p>[3] <a href="https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131" target="_blank" rel="noopener noreffer">iana root files</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
