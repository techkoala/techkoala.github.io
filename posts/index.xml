<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - TechKoala - Input/Output </title>
        <link>https://www.techkoala.top/posts/</link>
        <description>所有文章 | TechKoala - Input/Output </description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.top (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.top (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/posts/" rel="self" type="application/rss+xml" /><item>
    <title>OpenWRT overlay 空间扩容</title>
    <link>https://www.techkoala.top/openwrt_resize/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_resize/</guid>
    <description><![CDATA[<blockquote>
<p>安装 AdguardHome 运行几天后，可怜的剩余空间被日志耗尽，不得不对 OpenWRT overlay 进行扩容，记录一下</p>
</blockquote>
<h2 id="什么是-overlay">什么是 overlay</h2>
<p><code>OpenWRT</code> 一般使用的文件系统是 <code>SquashFS</code> ，这个文件系统的特点就是：<strong>只读</strong>。</p>
<p>一个只读的文件系统要怎么做到保存设置和安装软件的呢？这里就是使用 <code>/overlay</code> 的分区，<code>overlay</code> 顾名思义就是覆盖在上面一层的意思。虽然原来的文件不能修改，但把修改的部分放在 <code>overlay</code> 分区上，然后映射到原来的位置，读取的时候就可以读到修改过的文件了。</p>
<p>为什么要用这么复杂的方法呢？ <code>OpenWRT</code> 当然也可以使用 <code>EXT4</code> 文件系统，但使用 <code>SquashFS + overlay</code> 的方式有一定的优点。</p>
<ul>
<li><code>SquashFS</code> 是经过压缩的，在路由器这种小型 <code>ROM</code> 的设备可以放下更多的东西。</li>
<li><code>OpenWRT</code> 的恢复出厂设置也要依赖于这个方式。在你重置的时候，它只需要把 <code>overlay</code> 分区清空就可以了，一切都回到了刚刷进去的样子。</li>
</ul>
<p>如果是 <code>EXT4</code> 文件系统，就只能够备份每个修改的文件，在恢复出厂设置的时候复制回来，十分复杂。</p>
<p>当然，<code>SquashFS + overlay</code> 也有它的缺点：</p>
<ul>
<li>修改文件的时候会占用更多的空间。首先你不能够删除文件，因为删除文件实际上是在 <code>overlay</code> 分区中写入一个删除的标识，反而占用更多的空间。</li>
<li>另外在修改文件的时候相当于增加了一份文件的副本，占用了双份的空间。</li>
</ul>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/overlay.webp" title="/images/Network/OpenWRT_overlay/overlay.webp" data-thumbnail="/images/Network/OpenWRT_overlay/overlay.webp" data-sub-html="<h2>overlay 示意图</h2>">
        
    </a><figcaption class="image-caption">overlay 示意图</figcaption>
    </figure>
<h2 id="创建新分区">创建新分区</h2>
<p>首先，需要创建一个新的分区，这里使用的是 <code>cfdisk</code></p>
<p>如果没有，首先使用下列命令进行安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ opkg install cfdisk
</code></pre></td></tr></table>
</div>
</div><p>输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cfdisk
</code></pre></td></tr></table>
</div>
</div><p>打开磁盘管理界面：</p>
<p><figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/cfdisk.webp" title="/images/Network/OpenWRT_overlay/cfdisk.webp" data-thumbnail="/images/Network/OpenWRT_overlay/cfdisk.webp" data-sub-html="<h2>磁盘界面</h2>">
        
    </a><figcaption class="image-caption">磁盘界面</figcaption>
    </figure>
这里可以看到，一共有两个已有分区，现在新建一个分区：</p>
<p>选中 <code>Free Space</code>，再选中 <code>New</code>，输入需要的大小，比如 5G。</p>
<p>接着选择 <code>primary</code></p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/primary.webp" title="/images/Network/OpenWRT_overlay/primary.webp" data-thumbnail="/images/Network/OpenWRT_overlay/primary.webp" data-sub-html="<h2>选择主分区</h2>">
        
    </a><figcaption class="image-caption">选择主分区</figcaption>
    </figure>
<p>选择 <code>Write</code>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/write.webp" title="/images/Network/OpenWRT_overlay/write.webp" data-thumbnail="/images/Network/OpenWRT_overlay/write.webp" data-sub-html="<h2>写入更改</h2>">
        
    </a><figcaption class="image-caption">写入更改</figcaption>
    </figure></p>
<p>输入 <code>yes</code>，完成新分区的创建</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/yes.webp" title="/images/Network/OpenWRT_overlay/yes.webp" data-thumbnail="/images/Network/OpenWRT_overlay/yes.webp" data-sub-html="<h2>确认</h2>">
        
    </a><figcaption class="image-caption">确认</figcaption>
    </figure>
<h2 id="格式化分区">格式化分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkfs.ext4 /dev/sda3
</code></pre></td></tr></table>
</div>
</div><p>格式化分区</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/format.webp" title="/images/Network/OpenWRT_overlay/format.webp" data-thumbnail="/images/Network/OpenWRT_overlay/format.webp" data-sub-html="<h2>格式化分区</h2>">
        
    </a><figcaption class="image-caption">格式化分区</figcaption>
    </figure>
<h2 id="挂载新分区">挂载新分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mount /dev/sda3 /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><p>挂载分区</p>
<h2 id="转移到新分区">转移到新分区</h2>
<p>然后将原来 upper 层中的数据复制到新的分区中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">cp -r /overlay/* /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><h2 id="web-界面配置修改">Web 界面配置修改</h2>
<p>进入 <code>OpenWRT</code> Web 界面的<code>挂载点</code>对配置进行修改：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/openwrt.webp" title="/images/Network/OpenWRT_overlay/openwrt.webp" data-thumbnail="/images/Network/OpenWRT_overlay/openwrt.webp" data-sub-html="<h2>Web 界面</h2>">
        
    </a><figcaption class="image-caption">Web 界面</figcaption>
    </figure>
<p>再挂载点处点击添加然后配置如下：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/mountpoint.webp" title="/images/Network/OpenWRT_overlay/mountpoint.webp" data-thumbnail="/images/Network/OpenWRT_overlay/mountpoint.webp" data-sub-html="<h2>挂载点配置</h2>">
        
    </a><figcaption class="image-caption">挂载点配置</figcaption>
    </figure>
<h2 id="完成">完成</h2>
<p>到这一步，只需要重启 <code>OpenWRT</code> 即可成功扩容。到 系统 -&gt; 软件包 可以看到空间变大后的容量。</p>
<h2 id="自动挂载">自动挂载</h2>
<p>默认情况下分区再重启后会自动挂载，如果遇到没有挂载的情况，需要编辑 <code>/etc/rc.local</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ vim /etc/rc.local
</code></pre></td></tr></table>
</div>
</div><p>在 <code>exit 0</code> 之前加入一行 <code>mount /dev/sda3 /overlay</code> 即可。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://blog.msm.moe/mount-sd-card-to-overlay-on-openwrt/" target="_blank" rel="noopener noreffer">OpenWrt 下把 SD 卡挂载到 /overlay ，扩大软件空间</a></p>
</li>
<li>
<p>[2] <a href="https://www.jianshu.com/p/8179b19cfa6d" target="_blank" rel="noopener noreffer">软路由 LEDE 折腾 overlay 分区扩容之路</a></p>
</li>
<li>
<p>[3] <a href="https://www.vediotalk.com/archives/13889" target="_blank" rel="noopener noreffer">ESXI 下 OpenWrt 扩容 Overlay,增加安装插件空间</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>单独编译 OpenWRT ipk 插件</title>
    <link>https://www.techkoala.top/openwrt_compile_single_ipk/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_compile_single_ipk/</guid>
    <description><![CDATA[<blockquote>
<p>为 OpenWRT 编译单独的 ipk 插件</p>
</blockquote>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">必须先完整编译一次固件才能单独编译 ipk</div>
        </div>
    </div>
<p>当需要单独更新 OpenWRT 某个插件或者需要增加安装某个插件的时候，可以单独编译对应的 ipk 插件进行安装，而不必编译整个系统。</p>
<h3 id="下载源码">下载源码</h3>
<p>使用 <code>git clone</code> 对应的源码插件到下面的文件夹中</p>
<h3 id="存放路径">存放路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/package
</code></pre></td></tr></table>
</div>
</div><h3 id="配置">配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make menuconfig
</code></pre></td></tr></table>
</div>
</div><p>然后进入对应的子菜单中找到对应插件按 <M> 表示选中插件，但不编译进固件。</p>
<h3 id="编译">编译</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make package/xxxxx/compile <span class="nv">V</span><span class="o">=</span><span class="m">99</span>
</code></pre></td></tr></table>
</div>
</div><p>xxxxx 就是你需要单独编译的程序。</p>
<h3 id="ipk-生成路径">ipk 生成路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/bin/packages/x86_64/xxxx
</code></pre></td></tr></table>
</div>
</div><h3 id="上传-ipk-至路由器">上传 ipk 至路由器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scp xxxxxxx.ipk root@192.168.1.1:/tmp
</code></pre></td></tr></table>
</div>
</div><h3 id="安装">安装</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">opkg install /tmp/xxxxx.ipk
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>5G 将是一个彻底的失败</title>
    <link>https://www.techkoala.top/5g_will_be_a_complete_failure/</link>
    <pubDate>Sat, 03 Oct 2020 00:17:12 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/5g_will_be_a_complete_failure/</guid>
    <description><![CDATA[<blockquote>
<p>为什么说 5G 将是一个彻底的失败？</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：杨学志</p>
<p>链接：https://www.txrjy.com/thread-1061715-1-1.html</p>
<p>来源：通信人家园</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="无线通信产业发展史">无线通信产业发展史</h2>
<p>无线通信产业已经发展了四代，目前正处于 5G 产业化前夕，是当下到一个最热的话题，5G 如何发展，前景如何，是各个方面包括学术界、产业界、投资界以及政府都非常关心的。另外，中国已经启动 6G 研究的消息也见诸报端，未来无线通信产业如何发展，是不是会继续有 6、7、8、9G，也引起了大家的关切。为了回答这些问题，我们首先简单地回顾一下无线通信产业发展的历史。</p>
<p>无线通信产业是由<strong>需求</strong>和<strong>技术</strong>两个轮子驱动前进的。</p>
<p>早在 1947 年，贝尔实验室的科学家就提出了蜂窝通信的概念，其中的核心技术是频率复用和切换。基于这一概念，贝尔实验室于 1978 年研制出<code>先进移动电话系统</code>（Advanced Mobile Phone Service，AMPS），这就是第一代移动通信系统。<code>AMPS</code> 是一个模拟通信系统，采用<code>频分多址</code>（FDMA）的复用技术，主要技术手段是滤波器，容易受噪声的干扰，语音质量较差。</p>
<p>随着集成电路技术的发展，第二代移动通信系统采用了数字技术，并采用 <code>TDMA</code> 和信道编码技术，使得通信系统向宽带化发展，语音质量得到了较大的改善。其中欧洲制定的 <code>GSM</code> 系统非常成功，至今仍在广泛使用。</p>
<p>20 世纪 90 年代互联网蓬勃发展，顺应这一时代要求，产业界制订了 3G 标准用以实现移动互联网。3G 采用了高通公司开发的 <code>CDMA</code> 技术。<code>CDMA</code> 一度被认为是一个神奇的技术，高通公司宣称 <code>CDMA</code> 的频谱效率可以达到 AMPS 的 18 倍，但是实践表明这个观点太过于浮夸了，<code>CDMA</code> 存在自干扰问题，其频谱效率只比 <code>GSM</code> 高 10%左右，并且 3G 的主流标准 <code>WCDMA</code> 的系统设计过于复杂，导致部署成本比较高，所以一直无法替代 <code>GSM</code> 系统。</p>
<p>第四代移动通信采用了 <code>OFDM</code> 技术，从根本上克服了 <code>CDMA</code> 的技术缺陷，并且简化了系统设计，成就了一代成功的移动通信系统。<code>OFDM</code> 如何克服 <code>CDMA</code> 的缺陷，具体可以参考我的《通信之道-从微积分到 5G》。</p>
<p>如果我们稍微总结一下，可以发现，1G 发掘出了移动通信的巨大需求，但是采用了比较落后的技术体制，因此长不大。2G 进行了数字化革命，从而获得巨大成功。3G 是为了新出现的移动互联网需求而诞生，但是在技术上走了弯路，全球的 3G 业务都不是太成功；而 4G 回归了正确的技术路线，目前 4G 业务蓬勃发展。</p>
<p>随着 4G 的成功商用，按照无线通信十年一代的发展规律，产业界开始了 5G 的研发。按照业界目前的一般口径，5G 在 2020 年左右开始规模商用。中国政府已经为 5G 分配了 500MHz 的频谱，三大运营商也已经在多个城市开展了商用实验，商用前的准备工作正在紧锣密鼓地进行。 很多人认为 5G 牌照会在年内（2019）发放。</p>
<p>对于 5G 的讨论，也要从技术和需求两条线来讨论。</p>
<h2 id="无线通信技术体制">无线通信技术体制</h2>
<p>无线通信产业基本上可以用“端管云”三个字进行概括。 端就是终端，包括电脑， PAD，手机等。云就是存储在网络上的内容，如新浪、百度、淘宝的数据中心，而管就是连接终端和云之间的这条通道。</p>
<h3 id="端管云">端管云</h3>
<p>这条管道可以分为两段。一段是终端到基站（或者路由器），这段是无线通信，也叫空中接口；另一段是基站到云，是有线通信。云都是挂在因特网上的，因此因特网是这条管道当中必经之路。移动通信有核心网，基站首先挂在核心网上，再连接到因特网。核心网主要是起运营支撑作用，比如身份的识别，计费等等。而另一个体系是大家都熟悉的 <code>WiFi</code>，没有核心网，路由器是直接戳到因特网的。这就构成了两大生态体系，也就是传说中的 <code>CT</code> 和 <code>IT</code>，它们之间的合作与竞争将贯穿无线通信产业的走向。</p>
<p>在无线通信产业当中，空中接口这一段的产值，包括终端和基站，占绝大部分。如果做一个类比，通信网络可以类比人体的循环系统或这神经系统。骨干网的部分可以类比中枢神经或者主动脉，虽然容量很大，但是只有几条。骨干网络的销售额不大，但是占据战略制高点；而空中接口部分相当于神经末梢或者毛细血管，数量庞大，占据无线通信产业的主要市场份额。</p>
<p>有线网络现在都光纤化了。光纤的发明是基于高锟的理论，他因此获得诺贝尔奖。光纤的容量大，成本低，彻底改变了人类通信的面貌。最早的光纤线路的速率只有 45Mbps，后来以令人乍舌的速度发展，目前一根光纤已经可以达到 1Tbps。而光纤要比同等长度面条便宜，这是真正的高科技。早期光纤只用于骨干线路（比如北京和上海之间），随着成本的降低，目前光纤已经入户了。 由于光纤的存在，有线网络的主要工作在于怎么组织和利用光纤的容量，如 <code>IPV6</code>，<code>SDN</code> 等等，基本上是逻辑性的工作，总体来说是比较简单的。</p>
<p>空中接口部分就比有线网困难多了。在有线通信当中，信号在一个精心制造的介质里面传播，无论是铜线还是光纤，信号质量非常好，随便搞搞就能达到很高的速率。而无线信号的传播环境就恶劣得多得多。无线电波在传播过程中衰减很快，还受到建筑物、山体、树木的阻挡，很多时候需要经过反射或者穿透障碍物才能达到接收机。并且，无线电波不是规规矩矩地沿着规定的路线走，会走到不希望的地方，造成对他人的干扰。但是无线通信有一个好处，就是摆脱了线的束缚，可以拿着手机随便走，这种便利性是有线通信所无法比拟的。所以尽管挑战很大，无数的研究者前仆后继，攻克无线通信当中的道道难关。</p>
<h3 id="网络分层协议">网络分层协议</h3>
<p>刚才说的这些事，背后是网络的分层结构。最底下的一层叫物理层，其他的可以和合并起来叫高层。物理层是处理物理信号的，比如电或者是光，就是如何把信息转换成可以用来传输的电信号或者光信号。物理层解决的是通信能力的问题，或者是带宽的问题。有了这么多的带宽之后，怎么组织和利用是高层要做的事。</p>
<p>这个和邮政系统非常类似。物理层相当于运送信件或者包裹的方式，可以是马车，汽车、轮船、飞机，这提供了运送的能力。但是寄信的时候，我们要在信封上写通信地址，要跑到邮局交给柜台，后然分拣打包装车，到了目的地后要有邮递员送到收信地址，这些都是高层做的事情。</p>
<p>所以大家能看出来，通信网络的核心技术在物理层。当然高层也必不可少，但相对来说可以变化的空间不大。 如果说我们的邮政系统比以前先进，主要不是体现在邮局的布置上，而是运输方式的改进，以前是马车，现在改飞机了。虽说邮局也进步了，比如装了玻璃柜台，或者信件实现了机器分拣，但不是主要的因素。</p>
<p>光纤是现代通信网络的最重要的基石，就是物理层技术。高层技术当中大家最熟悉的是 <code>IP</code> 协议。<code>IPV4</code> 获得广泛应用后，虽说存在一些问题，试图通过 <code>IPV6</code> 去解决。但是 <code>IPV6</code> 经过二三十年也没有取代 <code>IPV4</code>，就是因为高层技术相对简单，改进的空间不大。</p>
<h2 id="无线通信技术演进">无线通信技术演进</h2>
<p>同样，空中接口的核心技术也在物理层，每一代移动通信是由这些核心技术所定义的。这些核心技术，也就是《通信原理》课程里面的知识。</p>
<h3 id="3g-核心技术">3G 核心技术</h3>
<p>空中接口的核心技术可以分为 5 个大类，分别是<code>调制</code>、<code>编码</code>、<code>多址</code>、<code>组网</code>和<code>多天线</code>。比核心技术更基础的是基础理论，包括电磁理论和信息论。</p>
<p>大家都知道，高通公司开发了 <code>CDMA</code> 技术，并且成为 3G 三大标准（ <code>WCDMA</code>，<code>CDMA</code>2000 和 <code>TD-SCDMA</code>）的核心技术，从而一跃成为芯片业巨头。 上图所示的是 <code>WCDMA</code> 的核心技术。高通的贡献主要在多址和组网两个领域。</p>
<p>虽然普遍认为高通开发了 <code>CDMA</code> 技术，但是 <code>CDMA</code> 并不是高通发明的，发明人是好莱坞艳星海蒂.拉玛。<code>CDMA</code> 技术的标准接收机叫 <code>Rake 接收机</code>，也于 1950 年代由贝尔实验室发明。实际上由于当时普遍认为 <code>CDMA</code> 的保密性好，一直应用于军事通信。而高通解决的是 <code>CDMA</code> 的民用问题，这在当时是普遍不被看好的。</p>
<p>高通解决 <code>CDMA</code> 民用有三招，分别是<code>功率控制</code>（Power Ctrl）、<code>同频复用</code>（UFR）和<code>软切换</code>。功率控制解决远近效应，同频复用提升频谱效率，软切换解决切换连续性。这构成了高通 <code>CDMA</code> 的技术体系。 这里只简要介绍一下，技术人员可以参考我的书《通信之道》。因为 UFR 并不是专利，所以高通其实在 <code>CDMA</code> 上就两个核心专利，其中软切换专利获得美国专利局的授权还载入了高通发展史。</p>
<ul>
<li>
<p>3G 在编码领域的主要进展是采用了 <code>Turbo</code> 码，这是法国电信所资助的教授发明的，是通信发展史上的里程碑，因为它首次充分逼近了香农在 1948 年所提出的信道容量。</p>
</li>
<li>
<p>在多天线领域，<code>Alamouti 编码</code>应用到了广播信道多编码。因为广播信道在整个业务当中的比重并不大，所以这个编码的作用相对重要性低一些。但是这个编码是多天线技术领域的里程碑，有非常大的影响力。</p>
</li>
<li>
<p>调制是最基础的通信技术，没有之一。因为基础，所以稳定，一直到现在的 5G 都没有太大的变化。</p>
</li>
</ul>
<p>可以看出，高通在 3G 的多址和组网两个方面拥有核心技术。当然，在把核心技术工程化的过程当中也建立起由几千个专利组成的专利组合。凭着这些专利和芯片的联合运作，收取了大量的高通税。</p>
<p>其实从现在的眼光看，<code>Turbo</code> 码和 <code>Alamouti 码</code>是更重要的核心技术。但这两个核心技术在法国电信和 <code>ATT</code> 这样的大公司里面，没有进行商业化运作的机制，只是收了一些专利费，没有形成象高通这么大的商业。</p>
<h3 id="4g-核心技术">4G 核心技术</h3>
<p>到了 4G 之后，<code>CDMA</code> 技术被 <code>OFDM</code> 技术所取代。主要的原因是 <code>CDMA</code> 存在自干扰的问题。高通的功率控制和软切换试图去解决这个问题，但采取的方法是在 <code>CDMA</code> 缺陷的基础上进行补救，但是怎么补也补不彻底。</p>
<p>而 <code>OFDM</code> 从根本上克服了 <code>CDMA</code> 自干扰的缺陷，使得频谱效率得到了很大的提高，那这些补救措施也就没必要了。 所以在 4G 时代，高通的技术体系被摧毁了。 采用 <code>OFDM</code> 技术带来了新的问题，解决这些问题导致了三个创新的出现，这就是我在华为提出的 <code>sOFDM</code> 和软频率复用（SFR）以及爱立信提出的 <code>SC-FDMA</code> 技术。 我在华为还提出了随机波束赋形（random beam forming）技术，解决了非常火热的循环延时分集（Cyclic Delay Diversity）的严重缺陷。 在调制和编码领域仍然采用了 3G 的方案。</p>
<p>可以看出，华为在 4G 的核心技术上已经取代了高通。但是很可惜，由于华为公司的跟随基因，无法发挥手上的专利核武的威力，还要向高通交钱，也只是向苹果收了点小钱。但是华为因此避免了专利核武打击，加上华为在产品上的优势，所以华为日子过得很好，在 4G 时代成为第一大设备制造商。</p>
<h3 id="5g-核心技术">5G 核心技术</h3>
<p>5G 标准已经制定完成了，盖棺定论后已经可以看得很清楚了。</p>
<p>首先调制这块还是没有变，太基础了，想变也变不动。</p>
<p>因为联想投票门的事情，编码这块的故事很多人都知道。相比于 3G/4G 采用的 <code>Turbo</code> 码，5G 采用了 <code>LDPC</code> 和 <code>Polar</code> 码。 这两个码都是鼎鼎大名，是 <code>Turbo</code> 码之后通信技术发展的里程碑性的技术。 但是由于 <code>Turbo</code> 码已经比较接近香农限，虽然这两个码更接近，但是对系统容量的提升已经不大，大概是 1 ～ 2%左右。</p>
<p>多址这块，对于 5G 三大场景之一的 <code>eMBB</code> 这块没有变，还是采用了 <code>OFDM</code>。其中爱立信提出的 <code>SC-FDMA</code> 从 4G 的必选项变成了可选项，这是因为它相对于 <code>OFDM</code>A 并没有什么技术优势。</p>
<p>多址这块 <code>NOMA</code> 有很大的热度，一度被公认为 5G 的必选技术。5G 标准的早期，几乎所有的厂家都支持这个方向。 但是经过我的论证，<code>NOMA</code> 比 <code>OFDM</code> 的增益严格为零，这是用信息论严格证明的。 所以 <code>NOMA</code> 既复杂又没增益，属于技术退步。</p>
<p>另外华为还推了 <code>F-OFDM</code>，与 <code>sOFDM</code> 正好相反。<code>sOFDM</code> 的思想是所有的带宽所有的环境都用统一的参数，从而获得规模经济效应。<code>F-OFDM</code> 强调对不同的环境采用不同参数从而更好的适应环境。 这种做法并没有什么增益，反而丢失了规模效应这个大西瓜，也属于技术退步。</p>
<p>组网方面没有听到什么消息，工作假设应该还是同频复用。<code>SFR</code> 和 <code>CoMP</code> 都是组网方案。<code>SFR</code> 非常简单，不需要标准化。<code>CoMP</code> 虽然一度被认为是更先进的技术，但经历了轰轰烈烈的标准工作和产品开发之后，已经是失败了。</p>
<p>多天线这块最响亮的就是 <code>massive MIMO</code>，号称可以成百倍地提升系统容量，从媒体上看几乎可以是 5G 的代名词。 <code>MIMO</code> 这个理论 1995 年提出，已经 23 年了。它所揭示的对容量的巨大提升致使它一直是学界和工业界的热点。但是这个技术一直到 4G 都不是很成功。这个技术有个特点，一演示就成功，一实用就趴窝。记得 20 年前我还是小白的时候，在电信展上就看到厂家演示空分复用，用相同的时频资源实现两个用户的同时通信，还互不干扰。在一个选择的场景下 <code>MIMO</code> 技术是很容易演示成功的，但是在复杂的实际环境中所涉及的问题的难度，是两个数量级的差别。当然 <code>MIMO</code> 是一个有潜力的领域，但是其实用化问题仍然没有解决。</p>
<p><code>MIMO</code> 的问题还在于，虽然能够提高容量，但是要增加设备，有成本的。其实 <code>MIMO</code> 最朴素的应用就是古老的三扇区天线，一个全向小区分割成三个扇区，容量在理论上增加了三倍，这就是 <code>MIMO</code> 的原理，虽然说是古板了一点。所以粗暴一点，搞个 9 扇区，12 扇区，也就是 <code>mMIMO</code> 了，这个华为已经有产品了。这和是不是 5G 没关系。</p>
<p>综合来看，5G 相对于 4G 来说，几乎没有技术进步，在一些地方还退步了。比如说 <code>NOMA</code>，<code>F-OFDM</code>，还有为了保证短时延而采用的自包含结构。</p>
<p>还有，5G 采用了更高的频谱。在中国是 3.5GHz，还好一点。美国用了 28GHz。频率越高覆盖越小，这是无线通信的基本知识。所以同样的网络覆盖，比起 4G 的 2.6GHz，3.5GHz 的投资要高出 50%（我也是看来的，看起来合理），而 28GHz 实现覆盖就是开玩笑了，花 5 倍的银子也是正常的。
所以从技术角度看，5G 比 4G 没有进步，成本会更高。</p>
<h2 id="5g-需求">5G 需求</h2>
<p>5G 的需求，大概可以用高速率、低延迟、大连接来概括。</p>
<p>大家知道，4G 设计当初的速率目标是 100Mbps，随着技术的演进，4G Cat 11 的速率已经达到 600Mbps。5G 进一步把速率目标提高到 1Gbps 以上。为了满足一些低延迟业务的需求，5G 要求空中接口的延迟时间为 1ms，而 4G 的这一指标为 30ms 左右。4G 主要是为移动互联网设计的，强调的是人与网络之间的高速连接，而同时连接到网络的终端的数量并不是一个需要特别考虑的问题。而在蓬勃发展的物联网时代，每一件物体都有可能有联网要求，因此连接数量会有数量级的增加，5G 需要具有支持海量连接的能力。</p>
<p>5G 最抓眼球的就是它的速率。看新闻经常是比光纤还快，一秒下一个大片，快到把人脸吹成骷髅，等等。
但是有什么样的业务需要这样的速率呢？</p>
<p>虽然暂时想不出，但是有一个非常流行的观点是，先修好路，自然会有车。3G、4G 都是这样，微博、微信、抖音什么的，以前根本就想不到。等 4G 来了之后，这些应用也就有了。</p>
<p>很显然，这个观点首先在逻辑上就有很大的问题。修好了路没有车也很正常啊，你就没见过没人走的路吗？ 按照 3G、4G 的情况去推断 5G，这个也不靠谱。就像你已经活了 80 岁，不能按此推断你还能再活 80 岁。2G 和 3G 都处于带宽短缺的时代，所以形成了修好路必有车的错觉。然而到了 4G 之后，带宽已经不再短缺了。</p>
<p>还有一个流行的观点是，科技发展往往超出人的想象力，所以保守的预测往往是错误的。比如比尔盖茨当年说，计算机 640k 内存应该是够了。而现在已经是 640G 了，6 个数量级的增长。</p>
<p>必须认识到，通信和计算机有很大的不同。</p>
<p>计算机所涉及的所有零部件，<code>CPU</code>，内存，硬盘，都有一个共同的源泉就是半导体工艺。半导体集成度在近十年提高了 1000 倍，大家共同水涨船高。但是通信不一样。通信需要一个受体，以目前最广泛的 <code>eMBB</code> 为例，这个受体就是人。人是肉长的而不是沙子做的，它能够处理的最大信息速率，也就是带宽，是固定的，超过了人的带宽是没有意义的。</p>
<p>通俗一点说，我在 <code>PAD</code> 上看片，我一般看缺省的高清格式，尽管有超清格式，我一般不会主动选择。为啥？ 因为我的老花眼看不出二者的区别。当然眼睛好的人还是应该能分出来的。高清视频也就是 1 ～ 2Mbps 的速率，目前的 <code>WiFi</code>，4G 都远远地超出了我的需求。</p>
<p>当然，有人会反对。比如目前 4K/8K 视频很火热，有朋友跟我说，看了 4K 视频之后，其他的都没法看了。我天天看高清格式视频，倒是没这种感觉了。当然对于 60 寸的大电视，提高分辨率还是有必要的。但是电影院的屏幕，目前还只是 2K，我认为 4K/8K 更多的是心理上的。用户挑电视的时候会靠在跟前看屏幕上的一小块区域，一个像素一个像素地检查，4K/8K 当然要好。如果在正常观看距离上，比如 2 米，4K 和 2K 会有明显区别吗？我没试验过啊，有兴趣的朋友可以做一下双盲实验。</p>
<p>即使是 4K 视频，速率也只有 30Mbps，4G 支持也不费力啊，怎么会有 1Gbps 的需求呢？这就要说到虚拟现实 <code>VR</code> 了。 <code>VR</code> 要求有沉浸式的体验。啥叫沉浸式？在真实的场景当中，如果我们慢慢地转头，看到的景物也就连续地变化，这就是沉浸的意思。VR 要实现这种效果，不光要传给你正在看的东西，没看的东西也要传给你，转头的时候要现传新视角上的数据来不及，会出现卡顿，就不是沉浸式体验了。这样一来，数据量再增加 30 倍，差不多就到 1G 了。5G 的 1G 速率的需求就是这么来的。</p>
<p><code>VR</code> 作为一种创新的视频形式，相信能够获得一定的应用。VR 的麻烦在于需要一个专门的头盔，哪怕是手机盒做的简易型的，都是不方便携带的。这么一来 <code>VR</code> 一般发生在室内，而且一般是专门用途的场景，比如房地产或者旅游景点的体验店什么的。这些业务一般不会走移动通信，更多的是 <code>WiFi</code> 或者专线。</p>
<p>总是有很多朋友寄希望于未来可能出现的未知业务。虽然具体的业务会层出不穷，我们确实无法预测，但是只要最终的受体是人，人感受信息的通道就是眼睛和耳朵，鼻子舌头皮肤还都用不上，人类进化出新的感觉器官最少也得是 100 万年以后的事情。人眼的带宽就确定了通信的最大速率，这是一个物理瓶颈，不管什么应用出现都是无法突破的。</p>
<p>从现实的情况看，<code>WiFi</code> 的速率总是领先移动网的，即使 <code>WiFi</code> 已经提供给我们 100M 的带宽了，但是我门最多应用的速率还是 1～2M，超出 10M 以上的应用非常少，也只有下载软件的时候有时会达到。所以其实 4G 的速率已经超出需求了，5G 的高速率完全是没必要的。</p>
<p>人的感官能力对时延同样是一个决定因素。</p>
<p>时延当然越短越好，没有人会不喜欢短时延，但是信息论的基本原理决定了短时延会造成高成本。信道编码依靠的是大数定律实现可靠通信，要达到信道容量，理论上需要无穷的时延。因此这个固有原理因素就决定了时延不能非常短。这里就不说其他的处理时延、排队时延和反馈时延了。非要实现低时延也有方法，就是把效率降低，用很高的信噪比去实现很低的速率。这个成本就太高了。任总一直在说，大速率、低时延的通信技术还没有实现。其实根本就不存在这样的技术。</p>
<p>要知道人的感官时延大概是 100 毫秒左右，所以 4G 几十毫秒的时延是比较合适的，1ms 的时延对人没有意义。所以，只要有人参与的应用，就不需要低时延。比如常用的微博微信，甚至是很多人认为需要低时延的手机游戏，在 <code>WiFi</code> 上不都玩得挺好吗。</p>
<p>自动驾驶是被广泛误解为需要低时延的应用。你可以经常看到有文章说，低时延使得刹车距离更短，从而更安全。但是这要基于一个假设，就是刹车指令是通过 5G 网络从远程控制中心传送给汽车的。 显然实际的解决方案不是这样。象刹车这种对时延和可靠性要求都非常高的指令，只能由车在本地产生，采用尽量短的回路。依靠网络传输的，是路线规划和路况信息这样的对可靠性和时延没有特殊要求的信息。Google 汽车已经跑了几百万公里了，并不需要一个低时延的网络。甚至没有网络的时候，汽车也应该能跑，这是起码的要求。</p>
<p>基于同样的原因，象无人工厂这些工业应用也无法通过 5G 网络实现。5G 是一个公共网络，对经济性的要求决定了它无法达到工业级的可靠性。不是说技术上做不到工业级的可靠性，而是能做到也不做，太贵了公众用不起。所有的工业应用必须用专线。远程手术也是同样的道理。</p>
<p>对于这个话题，你经常会看到一个很高大上的技术叫<code>网络切片</code>，意思是在 5G 网络上切出一个高可靠性的通道出来，用来满足工业应用。但是这实际是不可能做到的。一个系统的可靠性取决于最薄弱的一环。如果 5G 网络采用统一的硬件设施，如果不想多花钱，就已经决定了这是一个民用级别的可靠性，是不可能在软件上做点工作使之达到工业级的可靠性。就像特朗普车队，要清道、设岗，要有探路车、开道车、救护车、通信车、陆军一号这些硬东西，要花大把的银子。单靠在大街上挂几个标志是无法保证总统安全的。</p>
<p>虽然低时延高可靠性（uRLLC）是 5G 定义的三大场景之一，但是这与 5G 作为一个公共网络的基本特征相矛盾，是绝无可能实现的。</p>
<p>刚才所说的自动驾驶和无人工厂，属于物联网的例子。接下来我们聊聊普遍意义的物联网。</p>
<p>有句非常有名的话，叫做<code>4G 改变生活，5G 改变社会</code>，说的就是物联网。5G 使我们的社会从互联网发展到万物互联的社会。</p>
<p>虽然普遍认为目前处于物联网爆发的前夕，但是有个问题，物联网未必是移动通信的菜。</p>
<p>移动通信是怎么来的呢？起初就是人要打电话，要到处跑，不光在本地跑，还要出差，还要出国。这个特点要求移动需要统一标准，全球统一。所以要有个叫 <code>3GPP</code> 的组织，几百个公司的人一起制定这个标准，扯来扯去效率是很低的。还要搞个核心网去支持运营，运营商还要养着一大票的运维人员，这些特点就决定了移动通信会比较贵。</p>
<p>所以说，除非移动，不然没有必要用移动通信。 这样移动通信的客户群就很明确，一是人，二是车，另外还有野生动物。所以 <code>eMBB</code>，车联网，野外科学考察等等，是移动通信的正经业务。</p>
<p>但是大多数东西是不动的。 在 <code>WiFi</code> 已经普及的情况下，很大的一块业务会被 <code>WiFi</code> 分流，比如智能家居。并且 <code>eMBB</code> 是 2C 的，而物联网多数是 2B 的，象油田，电力公司这些大企业更倾向于自建网络，就不用向运营商交月租了。以 <code>NB-IoT</code> 为例，一个链接每年 20 块的资费对很多应用是很大的一个负担。这就有了象 <code>Lora</code> 这样的系统的生存空间，成本比 5G 低得多。</p>
<p>所以，从 5G 的三大需求看，高速率和低时延的需求都是不存在的，物联网只有小部分落入 5G 的范围。</p>
<h2 id="移动通信与-wifi">移动通信与 WiFi</h2>
<p>5G 与 <code>WiFi</code> 的关系是无法回避的问题，这其实是本文开始就提到了 <code>CT</code> 与 <code>IT</code> 两大生态体系的关系问题。</p>
<p>首先有一个每个人都能感觉到的事实，<code>WiFi</code> 承载了 80%的流量，我们却不会为它付一分钱，而会为只承载 20% 流量的 4G 付月租。这是为什么？</p>
<p>在信息社会，手机是我们与社会连接的通道。当我们习惯了这种连接之后，丢失连接后就会感到恐慌。 很多人一有机会就查一下微信，微博，电邮，股票，彩票，生怕遗漏了重大机会，或者没能及时回复。 也就是说，随时随地与社会连接，是我们的刚需。 要满足这种刚需，需要一个广覆盖的网络，这正是移动通信的目标和功能。</p>
<p>在 <code>WiFi</code> 火热的时候，有些城市试图建设 <code>WiFi</code> 城市，用 <code>WiFi</code> 来实现覆盖，但是最终都失败了。 因为 <code>WiFi</code> 是由 IT 界设计的，生来就缺乏实现广覆盖的能力。这表现在技术方案上，就不在这里细说了。 后来 IT 界把 <code>WiFi</code> 升级到 <code>WiMax</code>，试图与 CT 竞争，但是 IT 界的基因还是导致了 <code>WiMax</code> 的失败，并且导致北电破产。</p>
<p>由于 <code>WiFi</code> 无法实现广覆盖，它被定义为固网的延伸，已经成功渗透到了多数的家庭、酒店和办公室， 目前 <code>WiFi</code> 的实测速率已经达到 300～400Mbps。 <code>WiFi</code> 提供的是特定地点的高速率通信。路由器很便宜，二百块钱一个，用户自己买一个回来自己就能搞定，想把这些路由器集中控制起来收月租显然是不可行的。</p>
<p><code>IT</code> 与 <code>CT</code> 都试图入侵对方领地。早几年的 <code>WiMax</code> 就是 <code>IT</code> 入侵 <code>CT</code> 的一次失败的尝试。 这几年，也经常听到各种消息，一会儿是小扎，一会儿是马斯克，都要建全球免费 <code>WiFi</code>，周鸿祎说他掌管中国移动，就全免费。当然都没能成功。移动通信所要求的统一标准、广域覆盖，网归网优，客户管理，都决定了运营商是一个分层的官僚体系，与互联网基因格格不入。中国移动每年营收 8000 亿，够买 6 个 360 了，说免就免了，从哪能捞回来这么些钱？用户愿意交这个钱，非不收，那叫啥呢？</p>
<p>反过来，移动通信能取代 <code>WiFi</code> 吗。<code>WiFi</code> 覆盖小，高速率，成本低，使用非许可频段，决定了其免费的必然性。移动通信要取代 <code>WiFi</code>，也必须达到如此低的成本，并且实现免费。这是否能做到呢？如果 4G 能够利用已有的规模优势，做低成本的 <code>Femto 基站</code>，理论上有可能。但是市场规模太小，菊花大厂看不上眼，现有的管理体制也不能适应。而小厂很难有这个技术能力。所以说也是比较难的。</p>
<p>所以说，移动通信和 <code>WiFi</code> 有各自的应用场景。移动通信能够实现 anytime，anywhere 的连接，能够满足用户的刚需，而 <code>WiFi</code> 便宜，无月租，满足用户高速率的应用需求，将长期共存。</p>
<h2 id="5g-之局">5G 之局</h2>
<p>移动通信经过四代的发展之后，人们得到一个似乎的规律，就是单数代不太成功，而偶数代很成功。经过我们的分析后发现，1G 和 3G，都是新的需求促成的，但是技术不太好，而 2G 和 4G 在原有的需求基础上，改进了技术，从而很成功。1G 和 3G 虽然不太成功，但也不能说是失败，毕竟他们是满足新需求的唯一技术。 但是到了 5G，需求是虚构的，技术上并没有进步，所以必然是要失败的。</p>
<p>5G 是目前最火热的话题。特别是孟晚舟事件之后，美帝组团打压华为，国人已经把 5G 看成是中美对决的战场。</p>
<p>对于 5G 的立场，任总曾经发表过一个讲话，说 5G 的需求并没有出现。我心里赞叹任总真是到了从心所欲不逾矩的境界，也不为利益所左右。后来徐直军也发表了对 5G 相对保守的观点。但是后来口风变了，任总为自己的讲话向产品线道了歉。后来华为发文表示要坚决打胜 5G 这一仗。</p>
<p>我们已经知道，移动通信的根本的价值在于实现任何时间，任何地点的连接能力，在此基础上提高网络容量。如果没有覆盖这个前提，只是在局部实现高速率是没有商业价值的。比如说大家一直谈论的可见光通信，因为覆盖小只能服务两三个人，速率太高超过了人的带宽，就没有意义了。 这个问题对毫米波、太赫兹都是如此。
虽然过高的速率没够意义，但是随着用户渗透率的提高，资费的下降，数据量每年增长 30%的情况还会持续很多年。因此移动网络还需要扩容。</p>
<p>移动通信正确对发展方向是，保证连续覆盖的情况下以低成本提高网络容量。当然，并不是我一个人才知道这是正确的方向，实际上这是通信界的常识，2G 和 4G 的成功就是这种模式。</p>
<p>5G 偏离了这种模式，走向了错误的方向。这背后的原因有三个：</p>
<ul>
<li>通信原理的创新遇到瓶颈</li>
<li>半导体工艺获得了爆炸性的发展</li>
<li>无线产业决策链条太长</li>
</ul>
<p>通信技术已经发展百年，因为其战略地位和创造财富的能力，全球最强智力投入其中，但凡简单一点的创新早就发掘完了。用于 <code>Turbo</code> 码解码的 <code>BCJR 算法</code>是 1970 年代发明的，在我历经艰辛终于看懂之后，感叹道，这只能与魔鬼做交易才能搞得出来。 到 2009 年的时候，随着 <code>Turbo</code>，<code>LDPC</code>，<code>Polar</code>，<code>OFDM</code>，<code>MIMO</code> 等领域的进展并且逼近理论极限，学术界普遍感觉到物理层已经死了，再也无法创新了。象 David Tse 这样的被公认为传承香农衣钵的大咖，也感觉无处可走，转行做生物信息去了。</p>
<p>在此同时，半导体技术得到了爆炸性的发展。大家手上的 U 盘，从 10 年前 128M 变成了现在的 128G。在通信原理无法获得突破的情况下，自然地走上利用强大的算力实现高速率的方向。 高算力使得采用更宽的频带，更多的天线成为可能，在通信原理不变的情况下，通过算力使得速率暴力提升 1000 倍是很简单的事情。华为早就整出来 115Gbps 的样机了。看报道我国启动了 6G 研究，速度比 5G 高 10 倍，看得我真是很无奈。</p>
<p>移动通信产业有着与其他产业不同的特点。一般的产业都是研发产品上市，获得反馈并逐步改进，是一个快速迭代的过程。 而移动通信要求在什么还没有之前，大家共同商定一个标准，然后按照这个标准做产品。 何时启动一代通信标准是战略决策，是由政治领导人和商业领导人来做出的。他们当然会咨询技术专家，但是专家们也未必懂，其中还有巨大的利益博弈，显然并不靠谱。行业认同的宏观规律是十年一代。时间一到，各方力量合力推动，就动手干了。大炮一响，黄金万两。即使实际上不能干，也得创造条件干。所以我们看到 5G 出现了很多奇葩的技术，如全双工，毫米波，现在可见光，太赫兹也要上场了。<code>NOMA</code> 和 <code>F-OFDM</code> 比较起来都算是好的。</p>
<p>一代移动通信标准一旦启动，到产品上市之前，所有的玩家都投入了巨大的成本。鉴于通信产业的战略地位，政府意志也为之背书。大家都绑在这个战车上，即使有问题，在碰到南墙之前是不会停下来的。</p>
<p>所以 5G 的问题，不光是华为的问题，或者是中国的问题，美国、欧洲也都是如此。很多网友看到美帝在 5G 上整华为，就觉得美帝反对的东西肯定很重要。中国长期以来落后，都以美国为灯塔。但是经过改开 40 年，中国国力日渐强盛。而通信产业整体上已经获得了领先地位。在这种竞争格局下，即使美帝也会犯错。什么铱星啊，<code>Wimax</code> 啊，不都是美帝整的吗？ 所以我们要有独立的判断，而不是被对方的判断左右。 随着商用的日益迫近，5G 的问题会逐渐暴露出来。比如最近 <code>ATT</code> 的 5G 造假，韩国 5G 被指无用，澳洲未能按计划推出 5G 服务，等等。希望本文能为各方提个醒，尽量减少损失吧。</p>
<p>因为任总的讲话，我认为华为对 5G 是有清醒的认识的，任总最新的讲话又谈到了 5G 的需求没有出现。5G 成功当然好，又能成为华为的产粮田，况且在舆论上华为 5G 已经领先友商 12 个月。但 5G 失败对华为也是有利的。因为华为有着最齐全的产品线，是行业老大，没有技术创新也就意味着现有格局的固化，华为也就能笑到最后了。当然裁员是避免不了的，这对于通信狗们来说不是个好消息。 对于二线的设备商，却是灾难性的，对 5G 的投入无法回收，现有市场份额也会被华为逐渐蚕食。 对于高通更是灭顶之灾，3G 专利过期，4G 没专利，然后 5G 没有了，怎么收专利费？早些年嫌设备和手机不赚钱甩给别人了，现在有点傻眼。趁手上还有点银子，想收个恩智浦，也被贸易战给搅黄了。这日子怕是过不下去了。</p>
<h2 id="未来之路">未来之路</h2>
<p>前面已经讲到，移动通信的发展方向是在保证覆盖的情况下，用低成本的技术提高系统容量。这背后的使能器是核心技术的突破。这也是我近二十年的通信技术研究生涯所始终追求的目标。</p>
<p>尽管学界对通信原理的发展前景很悲观，但是情况正在起变化。</p>
<p>我在 2014 年发布了<code>多级软频率复用技术</code>（multilevel soft frequency reuse，MLSFR），是 <code>SFR</code> 技术的增强版。理论表明，<code>SFR</code> 可以提升频谱效率 10%左右，<code>MLSFR</code> 可以提高 30%。 值得注意的，这是在不增加任何硬件成本的前提下。 这种幅度技术进步，在最近 30 年的通信史上，只有 <code>Turbo</code> 码可以媲美，远远超过高通在 <code>CDMA</code> 领域的技术创新。MLSFR` 将成为未来移动通信组网技术的基石。</p>
<p>影响更加深远的，我已经在信息论上获得了重大突破。大家知道，香农在 1948 年创立了信息论，其中最重要的成果是这个信道容量公式：C=log（1+S/N），是指引着通信技术研究和工业发展的灯塔。</p>
<p>但是香农只给出了最简单的 AWGN 信道的容量。无线通信的信道都是衰落信道，而衰落信道的容量香农只开了个头，后来的学者发展出了一套衰落信道容量的理论，这些可以在经典的通信原理教科书里面找到。</p>
<p>但是，目前的衰落信道容量理论是错误的。</p>
<p>这个问题我思考了 14 年，终于提出了新的衰落信道容量理论并在 2018 年 3 月份完成了论文初稿。大家可以体会一下基础研究的周期。 审稿的过程也非常艰苦。开始投稿了 Nature，但是 Nature 认为满篇都是公式的稿件不符合它们的风格，还是投到应属期刊 IEEE Transactions on Information Theory。经过 5 个月的评审被拒，原因是两个评委认为论文对信息论存在误解。想想当年 <code>Turbo</code> 码论文，评委认为存在 3dB 的误差。重大突破被误解恐怕是一个规律，创新者需要有这样的心里准备。 但是另外一位评委给予了全面的肯定。当然，所有的评审意见都很容易回答，稿件修改之后再次投稿后，评审又进行了三个月，还没有出结果。在中美贸易战的背景下，美国在整华为，也难保政治不会侵蚀学术道德。不管怎么样，大家很快就能看到了。</p>
<p>基础理论的突破预示着无线通信产业的又一次技术革命，而中国就是这次革命的源头。</p>
<p>成功的道路并不拥挤，我们砥砺前行。</p>
<p>致敬改革开放 40 周年。</p>]]></description>
</item><item>
    <title>Linux 系统信息查询</title>
    <link>https://www.techkoala.top/system_info/</link>
    <pubDate>Sun, 13 Sep 2020 22:35:06 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/system_info/</guid>
    <description><![CDATA[<blockquote>
<p>记录一些常用的 Linux 系统信息查询命令</p>
</blockquote>
<p>日常使用 Linux 过程中，偶尔会需要查询一下系统信息，特别是在对于使用云端主机时，了解必要的信息十分重要。本文总结了一些常用的信息以及相应的查询命令。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">善用 grep 类命令作为配合，高效筛选想要的信息内容。</div>
        </div>
    </div>
<h2 id="系统信息">系统信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ uname -a              <span class="c1"># 查看内核/操作系统/CPU 信息</span>
$ head -n <span class="m">1</span> /etc/issue  <span class="c1"># 查看操作系统版本</span>
$ hostname              <span class="c1"># 查看计算机名</span>
$ lspci -tv             <span class="c1"># 列出所有 PCI 设备</span>
$ lsusb -tv             <span class="c1"># 列出所有 USB 设备</span>
$ lsmod                 <span class="c1"># 列出加载的内核模块</span>
$ env                   <span class="c1"># 查看环境变量</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="系统资源">系统资源</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat /proc/cpuinfo             <span class="c1"># 查看 CPU 信息</span>
$ lscpu                         <span class="c1"># 查看 CPU 信息</span>
$ lshw -short                   <span class="c1"># 当前服务器 CPU、内存、磁盘等详细信息</span>
$ free -m                       <span class="c1"># 查看内存使用量和交换区使用量</span>
$ df -h                         <span class="c1"># 查看各分区使用情况</span>
$ du -sh                        <span class="c1"># 查看指定目录的大小</span>
$ grep MemTotal /proc/meminfo   <span class="c1"># 查看内存总量</span>
$ grep MemFree /proc/meminfo    <span class="c1"># 查看空闲内存量</span>
$ uptime                        <span class="c1"># 查看系统运行时间、用户数、负载</span>
$ cat /proc/loadavg             <span class="c1"># 查看系统负载</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="磁盘和分区">磁盘和分区</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mount <span class="p">|</span> column -t         <span class="c1"># 查看挂接的分区状态</span>
$ fdisk -l                  <span class="c1"># 查看所有分区</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="网络信息">网络信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ip                    <span class="c1"># 查看网络相关信息，具体用法参见 man 手册</span>
$ iptables -L           <span class="c1"># 查看防火墙设置</span>
$ route -n              <span class="c1"># 查看路由表</span>
$ netstat -lntp         <span class="c1"># 查看所有监听端口</span>
$ netstat -antp         <span class="c1"># 查看所有已经建立的连接</span>
$ netstat -s            <span class="c1"># 查看网络统计信息</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="进程查询">进程查询</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ps -ef            <span class="c1"># 查看所有进程</span>
$ top               <span class="c1"># 实时显示进程状态</span>
$ htop              <span class="c1"># 实时显示进程状态，加强版 top</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="用户信息">用户信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ w                             <span class="c1"># 查看活动用户</span>
$ id &lt;用户名&gt;                    <span class="c1"># 查看指定用户信息</span>
$ last                          <span class="c1"># 查看用户登录日志</span>
$ cut -d: -f1 /etc/passwd       <span class="c1"># 查看系统所有用户</span>
$ cut -d: -f1 /etc/group        <span class="c1"># 查看系统所有组</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="服务">服务</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ crontab -l                    <span class="c1"># 查看当前用户的计划任务</span>
$ chkconfig –list               <span class="c1"># 列出所有系统服务</span>
$ chkconfig –list <span class="p">|</span> grep on     <span class="c1"># 列出所有启动的系统服务</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="软件信息">软件信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ apt list --installed          <span class="c1"># 显示 apt 安装的软件</span>
$ pacman -Qmeq                  <span class="c1"># 显示 aur 软件</span>
$ pacman -Qneq                  <span class="c1"># 显示 pacman 安装的软件</span>
$ pactree package_name          <span class="c1"># 显示软件的依赖树</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>5G NR 系列：波束赋形</title>
    <link>https://www.techkoala.top/beamforming/</link>
    <pubDate>Wed, 09 Sep 2020 16:14:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/beamforming/</guid>
    <description><![CDATA[<blockquote>
<p>什么是波束赋形？波束赋形的基本原理是什么？5G 怎样实现波束赋形？</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：无线深海</p>
<p>链接：https://zhuanlan.zhihu.com/p/144971077</p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="什么是波束赋形">什么是波束赋形？</h2>
<p><strong>波束赋形</strong>这个概念可以拆分成<strong>波束</strong>和<strong>赋形</strong>这两个词来理解。</p>
<ul>
<li><strong>波束</strong>里的<strong>波</strong>字可以认为是电磁波，<strong>束</strong>字的本意是“捆绑”，因此波束的含义是捆绑在一起集中传播的电磁波</li>
<li><strong>赋形</strong>可以简单地理解为“赋予一定的形状”</li>
</ul>
<p>合起来，波束赋形的意思就是<strong>赋予一定形状集中传播的电磁波</strong>。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_12.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_12.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_12.webp" data-sub-html="<h2>分散与集中的光线</h2>">
        
    </a><figcaption class="image-caption">分散与集中的光线</figcaption>
    </figure>
<p>其实，我们常见的光也是一种电磁波，灯泡作为一个点光源，发出的光没有方向性，只能不断向四周耗散；而手电筒则可以把光集中到一个方向发射，能量更为聚焦，从而照地更远。</p>
<p>无线基站也是同理，如下图所示，如果天线的信号全向发射的话，这几个手机只能收到有限的信号，大部分能量都浪费掉了。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_17.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_17.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_17.webp" data-sub-html="<h2>分散与集中的电磁波</h2>">
        
    </a><figcaption class="image-caption">分散与集中的电磁波</figcaption>
    </figure>
<p>而如果能通过波束赋形把信号聚焦成几个波束，专门指向各个手机发射的话，承载信号的电磁能量就能传播地更远，而且手机收到的信号也就会更强。</p>
<p>因此，波束赋形在无线通信中大有可为。</p>
<h2 id="波束赋形的基本原理是什么">波束赋形的基本原理是什么？</h2>
<p>波束赋形的物理学原理，其实就是波的干涉现象。</p>
<p>频率相同的两列波叠加，使某些区域的振动加强，某些区域的振动减弱，而且振动加强的区域和振动减弱的区域相互隔开。</p>
<p>想象一下，在湖边漫步时，你和女朋友在相距很近的两点激起水波，两朵涟漪不断散开，然后交叠起来，形成了下面的图样。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_10.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_10.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_10.webp" data-sub-html="<h2>波的干涉现象</h2>">
        
    </a><figcaption class="image-caption">波的干涉现象</figcaption>
    </figure>
<p>可以看出，有的地方水波增强，有的地方则减弱，并且增强和减弱的地方间隔分布，在最中间的狭窄区域最为明显。</p>
<p>如果波峰和波峰，或者波谷和波谷相遇，则能量相加，波峰更高，波谷更深。这种情况叫做相长干涉。</p>
<p>反之，如果波峰和波谷相遇，两者则相互抵消，震动归于静寂。这种情况叫做相消干涉。</p>
<p>如果把这个现象抽象一下，可以得到下图：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_07.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_07.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_07.webp" data-sub-html="<h2>波的干涉</h2>">
        
    </a><figcaption class="image-caption">波的干涉</figcaption>
    </figure>
<p>在两个馈源正中间的地方由于相长干涉，能量最强，可以认为形成了一个定向的波束，也叫做主瓣；两边则由于相消干涉能量抵消，形成了零陷，再往两边又是相长干涉，但弱于最中间，因此称作旁瓣。</p>
<p>如果我们能继续增强正中央主瓣的能量，使其宽度更窄，并抑制两边的旁瓣，就可以得到干净利落的波束了。</p>
<p>其实，普通天线一直在做这样的事情。</p>
<p>天线内部排布着一系列的电磁波源，称作振子，或者天线单元。这些天线单元也利用干涉原理来形成定向的波束。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_04.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_04.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_04.webp" data-sub-html="<h2>单列天线</h2>">
        
    </a><figcaption class="image-caption">单列天线</figcaption>
    </figure>
<p>由上图可以看出，纵向排列的天线单元越多，最中间的可集中的能量也就越多，波束也就越窄。</p>
<p>但这只是一个垂直截面而已，其实完整的波束在空间是三维的，水平和垂直的宽度可能截然不同。</p>
<p>下图是一个天线的振子排列，以及辐射能量三维分布图。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_06.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_06.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_06.webp" data-sub-html="<h2>纵向双列天线</h2>">
        
    </a><figcaption class="image-caption">纵向双列天线</figcaption>
    </figure>
<p>可以看出，上述天线内振源的排布方式为纵向，横向的数量很少，因此其波束在垂直方向的能量集中，而水平方向的角度还是比较宽的，像一个薄薄的大饼。</p>
<p>这种传统的天线水平方向的辐射角度多为 60 度，进行大面积的地面信号覆盖是一把好手，但要垂直覆盖高楼就有些力不从心了，称作“波束赋形”还是不够格。</p>
<p>如果我们把这些天线单元的排布改成矩形，电磁波辐射能量将在最中央形成一个很粗的主瓣，周边是一圈的旁瓣，这就有点波束赋形的意思了。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_01.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_01.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_01.webp" data-sub-html="<h2>矩形天线</h2>">
        
    </a><figcaption class="image-caption">矩形天线</figcaption>
    </figure>
<p>为了让波束更窄能量更集中，天线单元还需要更多更密，水平和垂直两个维度也都要兼顾，原本的天线就变成了大规模天线阵列。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_05.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_05.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_05.webp" data-sub-html="<h2>大规模矩形天线</h2>">
        
    </a><figcaption class="image-caption">大规模矩形天线</figcaption>
    </figure>
<p>这下，生成的波束就犀利多了，用大规模天线阵列来支持波束赋形，稳了！</p>
<p>但是这样还有问题，那就是这个最大波束位于正中央，且其传播方向和天线阵列垂直，而手机是一直随着用户移动的，所在的位置完全不确定，主波束虽然犀利，但照射不到手机上也是白搭。</p>
<p>那么，能不能让波束偏移一定的角度，对准手机来发射呢？</p>
<p>首先我们看看中央的主波束的形成过程：多列波的相位相同，也就是波峰和波谷在同一时间是对齐的，则它们到达手机时，就可以相长干涉，信号通过叠加得以增强。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_02.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_02.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_02.webp" data-sub-html="<h2>到达同相，相长干涉</h2>">
        
    </a><figcaption class="image-caption">到达同相，相长干涉</figcaption>
    </figure>
<p>如果手机和天线阵列有一定的夹角，则各列波到达手机时，相位难以对齐，可能是波峰和波谷相遇，也可能是在其他相位进行叠加，难以达到相长干涉，信号叠加的效果。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_15.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_15.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_15.webp" data-sub-html="<h2>到达异相，无法相长</h2>">
        
    </a><figcaption class="image-caption">到达异相，无法相长</figcaption>
    </figure>
<p>这可咋办？总不能通过旋转天线来让波束跟随手机吧？</p>
<p>其实，周期性是波最大的特点，不同的相位总是周期性的出现，错过了这个波峰，还有下一个波峰要来，因此相位是可以调整的。</p>
<p>通过调整不同天线单元发射信号的振幅和相位（权值），即使它们的传播路径各不相同，只要在到达手机的时候相位相同，就可以达到信号叠加增强的结果，相当于天线阵列把信号对准了手机。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_14.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_14.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_14.webp" data-sub-html="<h2>相位控制</h2>">
        
    </a><figcaption class="image-caption">相位控制</figcaption>
    </figure>
<p>下图是一个示例，可以看出天线阵列通过调整发射信号的相位，让波束偏移了 θ 度，从而可以精确对准手机发射信号。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_13.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_13.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_13.webp" data-sub-html="<h2>相位控制</h2>">
        
    </a><figcaption class="image-caption">相位控制</figcaption>
    </figure>
<h2 id="5g-怎样实现波束赋形">5G 怎样实现波束赋形？</h2>
<p>由此可见，波束赋形的关键在于天线单元相位的管控，也就是天线权值的处理。</p>
<p>根据波束赋形处理位置和方式的不同，可分为</p>
<ul>
<li>数字波束赋形</li>
<li>模拟波束赋形</li>
<li>混合波束赋形</li>
</ul>
<h3 id="模拟波束赋形">模拟波束赋形</h3>
<p>所谓模拟波束赋形，就是通过处理射频信号权值，通过移相器来完成天线相位的调整，处理的位置相对靠后。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_16.webp" data-sub-html="<h2>模拟波束赋形</h2>">
        
    </a><figcaption class="image-caption">模拟波束赋形</figcaption>
    </figure>
<p>模拟波束赋形的特点是基带处理的通道数量远小于天线单元的数量，因此容量上受到限制，并且天线的赋形完全是靠硬件搭建的，还会受到器件精度的影响，使性能受到一定的制约。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_08.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_08.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_08.webp" data-sub-html="<h2>模拟波束赋形框图</h2>">
        
    </a><figcaption class="image-caption">模拟波束赋形框图</figcaption>
    </figure>
<h3 id="数字波束赋形">数字波束赋形</h3>
<p>数字波束赋形则在基带模块的时候就进行了天线权值的处理，基带处理的通道数和天线单元的数量相等，因此需要为每路数据配置一套射频链路。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_11.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_11.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_11.webp" data-sub-html="<h2>数字波束赋形</h2>">
        
    </a><figcaption class="image-caption">数字波束赋形</figcaption>
    </figure>
<p>数字波束赋形的优点是</p>
<ul>
<li>赋形精度高</li>
<li>实现灵活</li>
<li>天线权值变换响应及时</li>
</ul>
<p>缺点是</p>
<ul>
<li>基带处理能力要求高</li>
<li>系统复杂</li>
<li>设备体积大</li>
<li>成本较高</li>
</ul>
<p>Sub6G 频段，作为当前 5G 容量的主力军，载波带宽可达 100MHz，一般采用采用数字波束赋形，通过 64 通道发射来实现小区内时频资源的多用户复用，下行最大可同时发射 24 路独立信号，上行独立接收 12 路数据，扛起了 5G 超高速率的大旗。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_09.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_09.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_09.webp" data-sub-html="<h2>数字波束赋形框图</h2>">
        
    </a><figcaption class="image-caption">数字波束赋形框图</figcaption>
    </figure>
<p>在毫米波 mmWave 频段，由于频谱资源非常充沛，一个 5G 载波的带宽可达 400MHz，如果单个 AAU 支持两个载波的话，带宽就达到了惊人的 800MHz！</p>
<p>如果还要像 Sub6G 频段的设备一样支持数字波束赋形的话，对基带处理能力要求太高，并且射频部分功放的数量也要数倍增加，实现成本过高，功耗更是大得吓人。</p>
<h3 id="混合波束赋形">混合波束赋形</h3>
<p>因此，业界将数字波束赋形和模拟波束赋形结合起来，使在模拟端可调幅调相的波束赋形，结合基带的数字波束赋形，称之为混合波束赋形。</p>
<p>混合波束赋形数字和模拟融合了两者的优点：</p>
<ul>
<li>基带处理的通道数目明显小于模拟天线单元的数量</li>
<li>复杂度大幅下降</li>
<li>成本降低</li>
<li>系统性能接近全数字波束赋形</li>
<li>非常适用于高频系统</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_03.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_03.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_03.webp" data-sub-html="<h2>混合波束赋形框图</h2>">
        
    </a><figcaption class="image-caption">混合波束赋形框图</figcaption>
    </figure>
<p>这样一来，毫米波频段的设备基带处理的通道数较少，一般为 4T4R，但天线单元众多，可达 512 个，其容量的主要来源是超大带宽和波束赋形。</p>
<p>在波束赋形和 Massive MIMO 的加成之下，5G 在 Sub6G 频谱下单载波最多可达 7Gbps 的小区峰值速率，在毫米波频谱下单载波也最多达到了约 4.8Gbps 的小区峰值速率。</p>]]></description>
</item><item>
    <title>3GPP Releases</title>
    <link>https://www.techkoala.top/3gpp_releases/</link>
    <pubDate>Thu, 03 Sep 2020 15:16:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/3gpp_releases/</guid>
    <description><![CDATA[<blockquote>
<p>Meanings of 3GPP releases</p>
</blockquote>
<h2 id="3gpp-release-schedule-and-summary">3GPP Release schedule and summary</h2>
<table>
<thead>
<tr>
<th>3GPP RELEASE</th>
<th>RELEASE DATE</th>
<th>DETAILS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Phase 1</td>
<td>1992</td>
<td>Basic GSM</td>
</tr>
<tr>
<td>Phase 2</td>
<td>1995</td>
<td>GSM features including EFR Codec</td>
</tr>
<tr>
<td>Release 96</td>
<td>Q1 1997</td>
<td>GSM Updates, 14.4 kbps user data</td>
</tr>
<tr>
<td>Release 97</td>
<td>Q1 1998</td>
<td>GSM additional features, GPRS</td>
</tr>
<tr>
<td>Release 98</td>
<td>Q1 1999</td>
<td>GSM additional features, GPRS for PCS 1900, AMR, EDGE</td>
</tr>
<tr>
<td>Release 99</td>
<td>Q1 2000</td>
<td>3G UMTS incorporating WCDMA radio access</td>
</tr>
<tr>
<td>Release 4</td>
<td>Q2 2001</td>
<td>UMTS all-IP Core Network</td>
</tr>
<tr>
<td>Release 5</td>
<td>Q1 2002</td>
<td>IMS and HSDPA</td>
</tr>
<tr>
<td>Release 6</td>
<td>Q4 2004</td>
<td>HSUPA, MBMS, IMS enhancements, Push to Talk over Cellular, operation with WLAN</td>
</tr>
<tr>
<td>Release 7</td>
<td>Q4 2007</td>
<td>Improvements in QoS &amp; latency, VoIP, HSPA+, NFC integration, EDGE Evolution</td>
</tr>
<tr>
<td>Release 8</td>
<td>Q4 2008</td>
<td>Introduction of LTE, SAE, OFDMA, MIMO, Dual Cell HSDPA</td>
</tr>
<tr>
<td>Release 9</td>
<td>Q4 2009</td>
<td>WiMAX / LTE / UMTS interoperability, Dual Cell HSDPA with MIMO, Dual Cell HSUPA, LTE HeNB</td>
</tr>
<tr>
<td>Release 10</td>
<td>Q1 2011</td>
<td>LTE-Advanced, Backwards compatibility with Release 8 (LTE), Multi-Cell HSDPA</td>
</tr>
<tr>
<td>Release 11</td>
<td>Q3 2012</td>
<td>Heterogeneous networks (HetNet), Coordinated Multipoint (CoMP), In device Coexistence (IDC), Advanced IP interconnection of Services,</td>
</tr>
<tr>
<td>Release 12</td>
<td>March 2015</td>
<td>Enhanced Small Cells operation, Carrier Aggregation (2 uplink carriers, 3 downlink carriers, FDD/TDD carrier</td>
</tr>
<tr>
<td>Release 13</td>
<td>Q1 2016</td>
<td>LTE-U / LTE-LAA, LTE-M, Elevation beamforming / Full Dimension MIMO, Indoor positioning, LTE-M Cat 1.4MHz &amp; Cat 200kHz introduced</td>
</tr>
<tr>
<td>Release 14</td>
<td>Mid 2017</td>
<td>Elements on road to 5G</td>
</tr>
<tr>
<td>Release 15</td>
<td>End 2018</td>
<td>5G Phase 1 specification</td>
</tr>
<tr>
<td>Release 16</td>
<td>2020</td>
<td>5G Phase 2 specification</td>
</tr>
<tr>
<td>Release 17</td>
<td>~Sept 2021</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="https://www.electronics-notes.com/articles/connectivity/3gpp/standards-releases.php" target="_blank" rel="noopener noreffer">3GPP Specification Release Numbers</a></li>
</ul>]]></description>
</item><item>
    <title>全站迁移到 Vercel</title>
    <link>https://www.techkoala.top/migrated_to_vercel/</link>
    <pubDate>Wed, 26 Aug 2020 16:18:53 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/migrated_to_vercel/</guid>
    <description><![CDATA[<blockquote>
<p>加速访问！</p>
</blockquote>
<h2 id="when">When</h2>
<p>网站已于 2020-8-26 迁移至 <a href="https://vercel.com" target="_blank" rel="noopener noreffer">Vercel</a></p>
<h2 id="why">Why</h2>
<p>鉴于目前 <code>Github</code> 以及 <code>Cloudflare</code> 在国内的访问速度一日不如一日，所以开始寻找了替代服务。刚好有 V2er 发帖求助相同的需求，于是顺着<a href="https://www.v2ex.com/t/701487" target="_blank" rel="noopener noreffer">帖子</a>的推荐选择了 <code>Vercel</code>。</p>
<h2 id="what">What</h2>
<p>下面是 <code>Vercel</code> 官网的介绍：</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">Vercel is a cloud platform for <strong>static sites</strong> and <strong>Serverless Functions</strong> that fits perfectly with your workflow. It enables developers to host <strong>Jamstack</strong> websites and web services that <strong>deploy instantly</strong>, <strong>scale automatically</strong>, and requires <strong>no supervision</strong>, all with <strong>no configuration</strong>.</div>
        </div>
    </div>
<p>相比于 <code>Github Pages</code>、<code>Netlify</code> 等，<code>Vercel</code> 拥有<strong>台湾</strong>和<strong>香港</strong>节点，对国内用户更加友好，并且免费套餐足够应付小流量情况了。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/vercel.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/vercel.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/vercel.webp" data-sub-html="<h2>Vercel</h2>">
        
    </a><figcaption class="image-caption">Vercel</figcaption>
    </figure>
<h2 id="how">How</h2>
<p>此前，本网站是托管在 <code>Github Pages</code>,然后通过 <code>Clouflare</code> 进行代理访问，因此只需要在 <code>Cloudfalre</code> 原配置上就行修改即可。</p>
<ol>
<li>首先，直接使用 <code>Github</code> 账号（或 <code>Gitlab</code> 等）登录 <code>Vercel</code> 即可（<strong>注：</strong> 不可以使用 <code>QQ</code> 邮箱为主邮箱的 <code>Github</code> 账号，<code>Vercel</code> 不识别部分邮箱域名，如果你是，请到 <code>Github</code> 修改主邮箱）</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import.webp" data-sub-html="<h2>导入 Github 项目</h2>">
        
    </a><figcaption class="image-caption">导入 Github 项目</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import2.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import2.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import2.webp" data-sub-html="<h2>选择需要导入的文件夹，默认为根文件夹</h2>">
        
    </a><figcaption class="image-caption">选择需要导入的文件夹，默认为根文件夹</figcaption>
    </figure>
<ol start="2">
<li>完成导入后，配置你的预编译设置（由于本站是在本地使用 <code>Hugo</code> 编译好后 <code>push</code> 到 <code>Github</code> 上的所以这里选择 <code>Other</code>，然后勾选 <code>OVERRIDE</code>，不填写编译内容，表示不需要进行编译）如果你想要 <code>Vercel</code> 代替你编译，可以在这里选择相应的配置。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/build.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/build.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/build.webp" data-sub-html="<h2>编译选项</h2>">
        
    </a><figcaption class="image-caption">编译选项</figcaption>
    </figure>
<ol start="3">
<li>待你完成编译配置后，等待 <code>Vercel</code> 完成编译和部署，你就可以得到一个可以访问的网站了，当然域名是一个二级域名。接下来我们配置自定义域名，首先点击你的项目，进入 设置 &gt; 域名。然后添加你的域名，一开始你添加好的域名不会和图片上一样，会显示为正确配置，这是因为我们还需要到 <code>Cloudflare</code> 进行调整。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/domain.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/domain.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/domain.webp" data-sub-html="<h2>域名设置</h2>">
        
    </a><figcaption class="image-caption">域名设置</figcaption>
    </figure>
<ol start="4">
<li>
<p>来到 Cloudflare 的 DNS 配置页面，首先删除此前指向 Github Pages 的两个解析，然后添加一个<code>CNAME</code>类型的解析，设置名字设置为<code>www</code>,内容填入<code>cname.vercel-dns.com</code>；</p>
<p><strong>注：</strong> 关键一步是，这里一定要设置<code>Proxy Status</code>为<code>DNS only</code>，否则，你的网站依然会经过 <code>Cloudflare</code> 的代理来访问。</p>
</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/cloudflare.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/cloudflare.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/cloudflare.webp" data-sub-html="<h2>Cloudflare DNS 配置</h2>">
        
    </a><figcaption class="image-caption">Cloudflare DNS 配置</figcaption>
    </figure>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">这里我还添加一个 <code>A</code> 记录指向<code>76.76.21.21</code>，因为我默认将根域名跳转到<code>www</code>。这个根据实际情况决定，但同样记得设置设置<code>Proxy Status</code>为<code>DNS only</code>。</div>
        </div>
    </div>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="https://vercel.com/docs/introduction" target="_blank" rel="noopener noreffer">Introduction to Vercel</a></li>
</ul>]]></description>
</item><item>
    <title>DNS 列表</title>
    <link>https://www.techkoala.top/dns_list/</link>
    <pubDate>Fri, 21 Aug 2020 18:44:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_list/</guid>
    <description><![CDATA[<blockquote>
<p>列举国内外常用的 DNS</p>
</blockquote>
<h2 id="ipv4">IPv4</h2>
<h3 id="国内">国内</h3>
<h4 id="知名-dns-服务">知名 DNS 服务</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>114 常规 DNS</td>
<td>114.114.114.114</td>
<td>114.114.115.115</td>
</tr>
<tr>
<td>114 拦截钓鱼病毒木马网站</td>
<td>114.114.114.119</td>
<td>114.114.115.119</td>
</tr>
<tr>
<td>114 拦截色情网站</td>
<td>114.114.114.110</td>
<td>114.114.115.110</td>
</tr>
<tr>
<td>阿里 AliDNS</td>
<td>223.5.5.5</td>
<td>223.6.6.6</td>
</tr>
<tr>
<td>百度 BaiduDNS</td>
<td>180.76.76.76</td>
<td></td>
</tr>
<tr>
<td>DNSPod DNS+</td>
<td>119.29.29.29</td>
<td>182.254.116.116</td>
</tr>
<tr>
<td>CNNIC SDNS</td>
<td>1.2.4.8</td>
<td>210.2.4.8</td>
</tr>
<tr>
<td>oneDNS</td>
<td>117.50.11.11</td>
<td>52.80.66.66</td>
</tr>
<tr>
<td>DNS 派电信/移动/铁通</td>
<td>101.226.4.6</td>
<td>218.30.118.6</td>
</tr>
<tr>
<td>DNS 派联通</td>
<td>123.125.81.6</td>
<td>140.207.198.6</td>
</tr>
</tbody>
</table>
<h4 id="全国各地电信-dns-服务器-ip-地址">全国各地电信 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>安徽电信 DNS</td>
<td>61.132.163.68</td>
<td>202.102.213.68</td>
</tr>
<tr>
<td>北京电信 DNS</td>
<td>219.141.136.10</td>
<td>219.141.140.10</td>
</tr>
<tr>
<td>重庆电信 DNS</td>
<td>61.128.192.68</td>
<td>61.128.128.68</td>
</tr>
<tr>
<td>福建电信 DNS</td>
<td>218.85.152.99</td>
<td>218.85.157.99</td>
</tr>
<tr>
<td>甘肃电信 DNS</td>
<td>202.100.64.68</td>
<td>61.178.0.93</td>
</tr>
<tr>
<td>广东电信 DNS</td>
<td>202.96.128.86</td>
<td>202.96.128.166</td>
</tr>
<tr>
<td></td>
<td>202.96.134.33</td>
<td>202.96.128.68</td>
</tr>
<tr>
<td>广西电信 DNS</td>
<td>202.103.225.68</td>
<td>202.103.224.68</td>
</tr>
<tr>
<td>贵州电信 DNS</td>
<td>202.98.192.67</td>
<td>202.98.198.167</td>
</tr>
<tr>
<td>河南电信 DNS</td>
<td>222.88.88.88</td>
<td>222.85.85.85</td>
</tr>
<tr>
<td>黑龙江电信</td>
<td>219.147.198.230</td>
<td>219.147.198.242</td>
</tr>
<tr>
<td>湖北电信 DNS</td>
<td>202.103.24.68</td>
<td>202.103.0.68</td>
</tr>
<tr>
<td>湖南电信 DNS</td>
<td>222.246.129.80</td>
<td>59.51.78.211</td>
</tr>
<tr>
<td>江苏电信 DNS</td>
<td>218.2.2.2</td>
<td>218.4.4.4</td>
</tr>
<tr>
<td></td>
<td>61.147.37.1</td>
<td>218.2.135.1</td>
</tr>
<tr>
<td>江西电信 DNS</td>
<td>202.101.224.69</td>
<td>202.101.226.68</td>
</tr>
<tr>
<td>内蒙古电信</td>
<td>219.148.162.31</td>
<td>222.74.39.50</td>
</tr>
<tr>
<td>山东电信 DNS</td>
<td>219.146.1.66</td>
<td>219.147.1.66</td>
</tr>
<tr>
<td>陕西电信 DNS</td>
<td>218.30.19.40</td>
<td>61.134.1.4</td>
</tr>
<tr>
<td>上海电信 DNS</td>
<td>202.96.209.133</td>
<td>116.228.111.118</td>
</tr>
<tr>
<td></td>
<td>202.96.209.5</td>
<td>180.168.255.118</td>
</tr>
<tr>
<td>四川电信 DNS</td>
<td>61.139.2.69</td>
<td>218.6.200.139</td>
</tr>
<tr>
<td>天津电信 DNS</td>
<td>219.150.32.132</td>
<td>219.146.0.132</td>
</tr>
<tr>
<td>云南电信 DNS</td>
<td>222.172.200.68</td>
<td>61.166.150.123</td>
</tr>
<tr>
<td>浙江电信 DNS</td>
<td>202.101.172.35</td>
<td>61.153.177.196</td>
</tr>
<tr>
<td></td>
<td>61.153.81.75</td>
<td>60.191.244.5</td>
</tr>
</tbody>
</table>
<h4 id="全国各地联通-dns-服务器-ip-地址">全国各地联通 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京联通 DNS</td>
<td>123.123.123.123</td>
<td>123.123.123.124</td>
</tr>
<tr>
<td></td>
<td>202.106.0.20</td>
<td>202.106.195.68</td>
</tr>
<tr>
<td>重庆联通 DNS</td>
<td>221.5.203.98</td>
<td>221.7.92.98</td>
</tr>
<tr>
<td>广东联通 DNS</td>
<td>210.21.196.6</td>
<td>221.5.88.88</td>
</tr>
<tr>
<td>河北联通 DNS</td>
<td>202.99.160.68</td>
<td>202.99.166.4</td>
</tr>
<tr>
<td>河南联通 DNS</td>
<td>202.102.224.68</td>
<td>202.102.227.68</td>
</tr>
<tr>
<td>黑龙江联通</td>
<td>202.97.224.69</td>
<td>202.97.224.68</td>
</tr>
<tr>
<td>吉林联通 DNS</td>
<td>202.98.0.68</td>
<td>202.98.5.68</td>
</tr>
<tr>
<td>江苏联通 DNS</td>
<td>221.6.4.66</td>
<td>221.6.4.67</td>
</tr>
<tr>
<td>内蒙古联通</td>
<td>202.99.224.68</td>
<td>202.99.224.8</td>
</tr>
<tr>
<td>山东联通 DNS</td>
<td>202.102.128.68</td>
<td>202.102.152.3</td>
</tr>
<tr>
<td></td>
<td>202.102.134.68</td>
<td>202.102.154.3</td>
</tr>
<tr>
<td>山西联通 DNS</td>
<td>202.99.192.66</td>
<td>202.99.192.68</td>
</tr>
<tr>
<td>陕西联通 DNS</td>
<td>221.11.1.67</td>
<td>221.11.1.68</td>
</tr>
<tr>
<td>上海联通 DNS</td>
<td>210.22.70.3</td>
<td>210.22.84.3</td>
</tr>
<tr>
<td>四川联通 DNS</td>
<td>119.6.6.6</td>
<td>124.161.87.155</td>
</tr>
<tr>
<td>天津联通 DNS</td>
<td>202.99.104.68</td>
<td>202.99.96.68</td>
</tr>
<tr>
<td>浙江联通 DNS</td>
<td>221.12.1.227</td>
<td>221.12.33.227</td>
</tr>
<tr>
<td>辽宁联通 DNS</td>
<td>202.96.69.38</td>
<td>202.96.64.68</td>
</tr>
</tbody>
</table>
<h4 id="全国各地移动-dns-服务器-ip-地址">全国各地移动 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>江苏移动 DNS</td>
<td>221.131.143.69</td>
<td>112.4.0.55</td>
</tr>
<tr>
<td>安徽移动 DNS</td>
<td>211.138.180.2</td>
<td>211.138.180.3</td>
</tr>
<tr>
<td>山东移动 DNS</td>
<td>218.201.96.130</td>
<td>211.137.191.26</td>
</tr>
</tbody>
</table>
<h3 id="香港地区">香港地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>香港宽频 DNS</td>
<td>203.80.96.10</td>
<td></td>
</tr>
<tr>
<td>和记环球电讯 DNS</td>
<td>202.45.84.58</td>
<td>202.45.84.59</td>
</tr>
<tr>
<td>Pacific SuperNet DNS</td>
<td>202.14.67.4</td>
<td>202.14.67.14</td>
</tr>
</tbody>
</table>
<h3 id="台湾地区">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信 DNS</td>
<td>168.95.1.1</td>
<td>168.95.192.1</td>
</tr>
<tr>
<td>数位联合电信 DNS</td>
<td>139.175.252.16</td>
<td>139.175.55.244</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>101.101.101.101</td>
<td>101.102.103.104</td>
</tr>
</tbody>
</table>
<h3 id="韩国">韩国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>KT olleh DNS</td>
<td>168.126.63.1</td>
<td>168.126.63.2</td>
</tr>
<tr>
<td>SK Broadband DNS</td>
<td>210.220.163.82</td>
<td>219.250.36.130</td>
</tr>
<tr>
<td>LG U+ DNS</td>
<td>164.124.101.2</td>
<td>203.248.252.2</td>
</tr>
<tr>
<td></td>
<td>164.124.107.9</td>
<td>203.248.242.2</td>
</tr>
</tbody>
</table>
<h3 id="美国">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cloudflare DNS</td>
<td>1.1.1.1</td>
<td>1.0.0.1</td>
</tr>
<tr>
<td>Google DNS</td>
<td>8.8.8.8</td>
<td>8.8.4.4</td>
</tr>
<tr>
<td>IBM Quad9</td>
<td>9.9.9.9</td>
<td>149.112.112.112</td>
</tr>
<tr>
<td>DNS.SB</td>
<td>185.222.222.222</td>
<td>185.184.222.222</td>
</tr>
<tr>
<td>OpenDNS</td>
<td>208.67.222.222</td>
<td>208.67.220.220</td>
</tr>
<tr>
<td>V2EX DNS</td>
<td>199.91.73.222</td>
<td>178.79.131.110</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>74.82.42.42</td>
<td>66.220.18.42</td>
</tr>
</tbody>
</table>
<h3 id="其他地区">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>77.88.8.8</td>
<td>77.88.8.1</td>
</tr>
<tr>
<td>俄罗斯 SafeDNS</td>
<td>195.46.39.39</td>
<td>195.46.39.40</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>84.200.69.80</td>
<td>84.200.70.40</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>77.109.148.136</td>
<td>77.109.148.137</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>91.239.100.100</td>
<td>89.233.43.71</td>
</tr>
<tr>
<td>荷兰 Freenom World Public DNS</td>
<td>80.80.80.80</td>
<td>80.80.81.81</td>
</tr>
</tbody>
</table>
<h2 id="ipv6">IPv6</h2>
<h3 id="国内-1">国内</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>百度</td>
<td>2400:da00::6666</td>
<td></td>
</tr>
<tr>
<td>阿里</td>
<td>2400:3200::1</td>
<td>2400:3200:baba::1</td>
</tr>
<tr>
<td>CNNIC</td>
<td>2001:dc7:1000::1</td>
<td></td>
</tr>
<tr>
<td>下一代互联网北京研究中心</td>
<td>240C::6666</td>
<td>240C::6644</td>
</tr>
</tbody>
</table>
<h4 id="高校">高校</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京邮电大学</td>
<td>2001:da8:202:10::36</td>
<td>2001:da8:202:10::37</td>
</tr>
<tr>
<td>上海交通大学</td>
<td>2001:da8:8000:1:202:120:2:100</td>
<td>2001:da8:8000:1:202:120:2:101</td>
</tr>
<tr>
<td>中科院网络信息中心</td>
<td>2001:cc0:2fff:1::6666</td>
<td></td>
</tr>
<tr>
<td>北京交通大学</td>
<td>2001:da8:205:2060::188</td>
<td></td>
</tr>
<tr>
<td>清华大学</td>
<td>2001:da8:ff:305:20c:29ff:fe1f:a92a</td>
<td></td>
</tr>
<tr>
<td>清华大学 TUNA 协会</td>
<td>2001:da8::666</td>
<td></td>
</tr>
<tr>
<td>北京科技大学</td>
<td>2001:da8:208:10::6</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="台湾地区-1">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信</td>
<td>2001:b000:168::1</td>
<td>2001:b000:168::2</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>2001:de4::101</td>
<td>2001:de4::102</td>
</tr>
</tbody>
</table>
<h3 id="美国-1">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GOOGLE</td>
<td>2001:4860:4860::8888</td>
<td>2001:4860:4860::8844</td>
</tr>
<tr>
<td>CloudFlare DNS</td>
<td>2606:4700:4700::1111</td>
<td>2606:4700:4700::1001</td>
</tr>
<tr>
<td>IBM</td>
<td>2620:fe::fe</td>
<td>2620:fe::9</td>
</tr>
<tr>
<td>Cisco OpenDNS</td>
<td>2620:0:ccc::2</td>
<td>2620:0:ccd::2</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>2001:470:20::2</td>
<td>2001:470:0:9d::2</td>
</tr>
<tr>
<td>Verisign Public DNS</td>
<td>2620:74:1b::1:1</td>
<td>2620:74:1c::2:2</td>
</tr>
<tr>
<td>Neustar Recursive DNS</td>
<td>2610:a1:1018::1</td>
<td>2610:a1:1019::1</td>
</tr>
</tbody>
</table>
<h3 id="其他地区-1">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>2a02:6b8::feed:0ff</td>
<td>2a02:6b8:0:1::feed:0ff</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>2001:1608:10:25::1c04:b12f</td>
<td>2001:1608:10:25::9249:d69b</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>2001:1620:2078:136::</td>
<td>2001:1620:2078:137::</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>2001:67c:28a4::</td>
<td>2a01:3a0:53:53::</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://www.iplaysoft.com/public-dns.html" target="_blank" rel="noopener noreffer">全球免费公共 dns 解析服务器 ip 地址列表推荐 (解决无法上网/加速/防劫持)</a></p>
</li>
<li>
<p>[2] <a href="http://ip.cn/dns.html" target="_blank" rel="noopener noreffer">公共 dns 服务器 ip 地址</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>网络分析工具：NetCat</title>
    <link>https://www.techkoala.top/netcat/</link>
    <pubDate>Wed, 19 Aug 2020 23:15:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/netcat/</guid>
    <description><![CDATA[<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-sub-html="<h2>网络瑞士军刀 —— NetCat</h2>">
        
    </a><figcaption class="image-caption">网络瑞士军刀 —— NetCat</figcaption>
    </figure>
<h2 id="什么是-netcat">什么是 NetCat</h2>
<p>简单来说，NetCat (nc) 是一个命令行工具，能够让你很方便、很灵活地操纵 <code>传输层协议</code>（TCP ＆ UDP）</p>
<p>nc 可以在两台设备上面相互交互，即<code>侦听模式</code>/<code>传输模式</code></p>
<p>nc 包含以下主要功能：</p>
<ul>
<li>Telnet 功能</li>
<li>获取 banner 信息</li>
<li>传输文本信息</li>
<li>传输文件 / 目录</li>
<li>加密传输文件，默认不加密</li>
<li>远程控制</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆硬盘</li>
</ul>
<h2 id="使用-netcat">使用 NetCat</h2>
<p>一般来说，nc 的命令行包括如下几个部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc 命令选项 主机 端口
</code></pre></td></tr></table>
</div>
</div><h3 id="命令选项">命令选项</h3>
<blockquote>
<p>本文内容基于 OpenBSD 社区的变种（也叫 OpenBSD netcat，部分命令与原版有差异。 ）</p>
</blockquote>
<p>下面列举了一些常用选项，更多选项参见 <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreffer">OpenBSD manual page</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">选项	   是否有 “选项值”	   说明
-h	   NO	           输出 nc 的帮助
-v	   NO	           在网络通讯时，显示详细的输出信息
-n	   NO	           对命令行中的主机，不进行域名解析，如果主机是 IP 地址，需要用该选项
-p	  YES	           指定端口号
-l	  NO	           开启监听模式，nc 作为服务端，如不加，nc 默认作为客户端
-u	  NO	           使用 UDP 协，如不加该选项，默认是 TCP 协议
-w	  YES	           设置连接的超时间隔（N 秒）
-q	  YES	           让 nc 延时（N 秒）再退出
-z	  NO	           开启 zero-I/O 模式，该选项仅用于端口扫描
-k	  NO	           配合 -l 选项使用，可以重复接受客户端连接
-X	  YES	           指定代理的类型
-x	  YES	           以 IP:port 的格式指定代理
-d    NO               后台模式
</code></pre></td></tr></table>
</div>
</div><h3 id="主机">主机</h3>
<p>这部分可以没有，可以以 <code>IP 地址</code> 形式表示，也可以以 <code>域名</code> 形式表示。</p>
<h3 id="端口">端口</h3>
<p>这部分可以没有，可以是单个端口，可以是端口范围。</p>
<h2 id="常用使用场景示例">常用使用场景示例</h2>
<h3 id="测试某个远程主机的监听端口是否可达">测试某个远程主机的监听端口是否可达</h3>
<p>经常有这种需求，要判断某个主机的监听端口是否能连上。导致监听端口无法连接，通常有两种原因：</p>
<ol>
<li>监听端口没开启</li>
<li>监听端口虽然开启，但是被防火墙阻拦了</li>
</ol>
<p>对第 1 个原因，（如果你能在该主机上运行命令）可以直接用 <code>netstat</code> 这个命令查看监听端口是否开启；但对于第 2 个原因，<code>netstat</code> 就用不上了，这时候就可以用 nc 来帮你搞定。</p>
<p>用如下命令可以测试某个 IP 地址上的某个监听端口是否开启:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv ip port
</code></pre></td></tr></table>
</div>
</div><p><strong>注：</strong>　默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加 <code>-w</code> 选项，设置一个比较小的超时值。在下面的例子中，超时值设为 3 秒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv -w <span class="m">3</span> ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="判断防火墙是否允许-or-禁止某个端口">判断防火墙是否允许 or 禁止某个端口</h3>
<p>假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何验证自己的配置生效？</p>
<p>为了叙述方便，设想如下场景：
有两台主机 ——<code>主机 C</code> 充当客户端，<code>主机 S</code> 充当服务端。
然后要判断<code>主机 S</code> 上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。</p>
<p>在<code>主机 S</code> 上运行 nc，让它在 8080 端口，命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -lv -p <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 “主机 C” 上运行 nc，测试 “主机 S” 上的 8080 端口是否可达</p>
<p><strong>注：</strong>　在默认情况下，nc 开启 listen 模式充当服务端，在接受<strong>第一次</strong>客户端连接之后，就会把监听端口关闭。如果你想要让 nc 始终监听模式，使之能<strong>重复</strong>接受客户端发起的连接，可以追加 <code>-k</code> 选项。</p>
<h3 id="端口扫描">端口扫描</h3>
<p>下面这个命令，用来扫描的端口范围从 1 到 1024</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024
</code></pre></td></tr></table>
</div>
</div><p>选项 -z
是指开启 <code>zero-I/O 模式</code>。该模式 nc 只判断某个监听端口是否能连上，连上后<strong>不</strong>与对端进行数据通讯。</p>
<p>**注：**端口扫描的时候，<code>-v</code> 选项会把成功/失败的结果统统打印出来。通常关注的都是 “扫描成功” 的那些端口。因此，可以用可以配合使用 <code>grep</code> 过滤一下，只打印扫出来的端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024  2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> grep succeeded
</code></pre></td></tr></table>
</div>
</div><p>此外，由于 <code>-v</code> 选项产生的输出位于 <code>stderr</code>，上述命令中的 <code>2&gt;&amp;1</code> 用来把 <code>stderr</code> 合并到 <code>stdout</code>。</p>
<p><strong>另：</strong> nc 默认超时较大，导致扫描速度较慢。建议根据网络情况合理设置超时值，加快扫描速度。</p>
<h3 id="探测服务器类型和软件版本">探测服务器类型和软件版本</h3>
<p>如果某个服务器运行了 SSH 服务端，那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> -n ip <span class="m">22</span>
OR
<span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> domain <span class="m">22</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="端口转发">端口转发</h3>
<p>用 nc 进行端口转发，需要运行两个 nc 进程，一个充当<code>服务端</code>，另一个是<code>客户端</code>，然后用管道让把两个进程的<code>标准输入输出``交叉配对</code>。所谓的<code>交叉配对</code>就是——每一个 nc 进程的<code>标准输出</code>都对接到另一个 nc 进程的<code>标准输入</code>。如此一来，就可以完美地建立双向通讯。</p>
<p>步骤 1：创建命名管道</p>
<p>用下面这个简单的命令创建一个 “命名管道”，其名称叫做 nc_pipe</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mkfifo nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>步骤 2：同时启动两个 nc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p <span class="m">1234</span> &lt; nc_pipe <span class="p">|</span> nc 127.0.0.1 <span class="m">5678</span> &gt; nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。</p>
<h3 id="传输文件">传输文件</h3>
<p>为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端 B 主机运行如下命令
nc -l -p port &gt; file2

然后在发送端 A 主机运行如下命令
nc ip port &lt; file1
</code></pre></td></tr></table>
</div>
</div><p>两者端口号要相同</p>
<h3 id="远程备份整个磁盘">远程备份整个磁盘</h3>
<p>假设你要把 A 主机 <code>/dev/sda</code> 磁盘的原始数据整个复制到 B 主机的 <code>/dev/sdb</code> 磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端（B 主机）运行如下命令
nc -lp port <span class="p">|</span> dd <span class="nv">of</span><span class="o">=</span>/dev/sdb

然后在发送端 A 主机运行如下命令
dd <span class="k">if</span><span class="o">=</span>/dev/sda <span class="p">|</span> nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="远程控制">远程控制</h3>
<p>将 A 主机的 <code>bash</code> 发给 B 主机</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
nc -lp port -c bash

B:
nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="流媒体服务">流媒体服务</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
cat test.mp4 <span class="p">|</span> nc -lp port

B:
nc -nv ip port <span class="p">|</span> mplayer -vo x11 -cache <span class="m">4000</span>
</code></pre></td></tr></table>
</div>
</div><p>A 让 test.MP4 这个文件成为<code>流</code>的形式发送到 B，B 用 mplayer 播放，接收多少播放多少，指定缓存 4000bytes。</p>
<h3 id="信息收集">信息收集</h3>
<p>收集目标机上的进程信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p port &gt; ps.txt
将远程发送过来的内容保存在本地

Ps aux <span class="p">|</span>nc -nv ip port -q <span class="m">1</span>
标准输入完成后 delay 一秒钟，会发送到侦听端

</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreffer">netcat manual page</a></p>
</li>
<li>
<p>[2] <a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html#head-15" target="_blank" rel="noopener noreffer">扫盲 netcat（网猫）的 N 种用法 —— 从 “网络诊断” 到 “系统入侵”</a></p>
</li>
<li>
<p>[3] <a href="https://www.jianshu.com/p/cb26a0f6c622" target="_blank" rel="noopener noreffer">NetCat 使用指南</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>HTTPS 工作原理</title>
    <link>https://www.techkoala.top/how_https_works/</link>
    <pubDate>Sun, 16 Aug 2020 21:52:26 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/how_https_works/</guid>
    <description><![CDATA[<blockquote>
<p>理解 HTTP 协议，对称和非对称加密，了解 HTTPS 协议的工作原理</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：猫尾博客</p>
<p>链接：https://cattail.me/tech/2015/11/30/how-https-works.html</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>读完本文，你能明白</p>
<ul>
<li>什么是 HTTPS，TLS (SSL)，TLS 和 HTTPS 是什么关系</li>
<li>什么是证书和数字签名，它们是如何传递信任的</li>
<li>HTTPS 有什么样的功能，它是如何实现这样的功能的</li>
</ul>
<h2 id="简介">简介</h2>
<p>HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。本文着重描述 TLS 协议的 1.2 版本</p>
<p>下图描述了在 TCP/IP 协议栈中 TLS (各子协议）和 HTTP 的关系</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" data-sub-html="<h2>Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS</h2>">
        
    </a><figcaption class="image-caption">Credit: <a href="https://blogs.msdn.com/213737/ProfileUrlRedirect.ashx" target="_blank" rel="noopener noreffer">Kaushal Kumar Panday</a> From: <a href="https://blogs.msdn.com/b/kaushal/archive/2013/08/03/ssl-handshake-and-https-bindings-on-iis.aspx" target="_blank" rel="noopener noreffer">SSL Handshake and HTTPS Bindings on IIS</a></figcaption>
    </figure>
<p>其中 <code>Handshake protocol</code>，<code>Change Ciper Spec protocol</code> 和 <code>Alert protocol</code> 组成了 <code>SSL Handshaking Protocols</code>。</p>
<p>HTTPS 和 HTTP 协议相比提供了:</p>
<ol>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ol>
<p>其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。</p>
<h2 id="总览">总览</h2>
<p>使用 RSA 算法的 SSL 握手过程是这样的:</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<ol>
<li>[明文] 客户端发送随机数 client_random 和支持的加密方式列表</li>
<li>[明文] 服务器返回随机数 server_random ，选择的加密方式和服务器证书链</li>
<li>[RSA] 客户端验证服务器证书，使用证书中的公钥加密 premaster secret 发送给服务端</li>
<li>服务端使用私钥解密 premaster secret</li>
<li>两端分别通过 client_random，server_random 和 premaster secret 生成 master secret，用于对称加密后续通信内容</li>
</ol>
<h3 id="证书digital-certificate">证书（Digital certificate）</h3>
<p>那么什么是证书呢？</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" data-sub-html="<h2>证书信息</h2>">
        
    </a><figcaption class="image-caption">证书信息</figcaption>
    </figure>
<h3 id="证书中包含了以下信息">证书中包含了以下信息</h3>
<ol>
<li>证书信息：过期时间和序列号</li>
<li>所有者信息：姓名等</li>
<li>所有者公钥</li>
</ol>
<p><strong>为什么服务端要发送证书给客户端?</strong></p>
<p>互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<h3 id="客户端为什么要验证接收到的证书">客户端为什么要验证接收到的证书</h3>
<p><strong>中间人攻击</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">客户端 &lt;------------ 攻击者 &lt;------------ 服务端
        伪造证书            拦截请求
</code></pre></td></tr></table>
</div>
</div><h3 id="客户端如何验证接收到的证书">客户端如何验证接收到的证书</h3>
<p>为了回答这个问题，需要引入<code>数字签名</code> (Digital Signature)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+                +--------+
| is a mathematical   |---- 哈希 ---&gt;| 消息摘要  |--- 私钥加密 ---&gt;| 数字签名 |
|technique used       |              +---------+                +--------+
|to validate the      |
|authenticity and     |
|integrity of a       |
|message, software    |
|or digital document. |
+---------------------+
</code></pre></td></tr></table>
</div>
</div><p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p>
<p>假设消息传递在 Bob，Susan 和 Pat 三人之间发生。Susan 将消息连同数字签名一起发送给 Bob，Bob 接收到消息后，可以这样验证接收到的消息就是 Susan 发送的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+
| is a mathematical   |---- 哈希 ---&gt;|  消息摘要 |
|technique used       |              +---------+
|to validate the      |                 |
|authenticity and     |                 |
|integrity of a       |                 |
|message, software    |                 对
|or digital document. |                 比
+---------------------+                 |
                                        |
                                        |
        +---------+               +----------+
        | 数字签名 |--- 公钥解密 ---&gt;|  消息摘要 |
        +---------+               +----------+
</code></pre></td></tr></table>
</div>
</div><p>当然，这个前提是 Bob 知道 Susan 的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Bob。</p>
<p>此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener noreffer">证书颁发机构</a>（Certificate Authority，简称 CA），CA 数量并不多，Bob 客户端内置了所有受信任 CA 的证书。CA 对 Susan 的公钥（和其他信息）数字签名后生成证书。</p>
<p>Susan 将证书发送给 Bob 后，Bob 通过 CA 证书的公钥验证证书签名。</p>
<p>Bob 信任 CA，CA 信任 Susan 使得 Bob 信任 Susan，信任链（Chain Of Trust）就是这样形成的。</p>
<p>事实上，Bob 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<h2 id="tls-协议">TLS 协议</h2>
<p><code>TLS</code> 协议包括 <code>TLS Record Protocol</code> 和 <code>TLS Handshake Protocol</code>。总览中的流程图仅涉及到 <code>TLS Handshake Protocol</code>。</p>
<h3 id="tls-record-protocol">TLS Record Protocol</h3>
<p>在 <code>TLS</code> 协议中，有四种子协议运行于 <code>Record protocol</code> 之上</p>
<ul>
<li>Handshake protocol</li>
<li>Alert protocol</li>
<li>Change cipher spec protocol</li>
<li>Application data protocol</li>
</ul>
<p>Record protocol 起到了这样的作用</p>
<ul>
<li>在发送端：将数据（Record）分段，压缩，增加 MAC (Message Authentication Code) 和加密</li>
<li>在接收端：将数据（Record）解密，验证 MAC，解压并重组</li>
</ul>
<blockquote>
<p>值得一提的是，Record protocol 提供了数据完整性和隐私性保证，但 Record 类型（type）和长度（length）是公开传输的</p>
</blockquote>
<p>Record Protocol 有三个连接状态 (Connection State)，连接状态定义了压缩，加密和 MAC 算法。所有的 Record 都是被当前状态（Current State）确定的算法处理的。</p>
<p><code>TLS Handshake Protocol</code> 和 <code>Change Ciper Spec Protocol</code> 会导致 <code>Record Protocol</code> 状态切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">empty state -------------------&gt; pending state ------------------&gt; current state
             Handshake Protocol                Change Cipher Spec
</code></pre></td></tr></table>
</div>
</div><p>初始当前状态（Current State）没有指定加密，压缩和 MAC 算法，因而在完成 TLS Handshaking Protocols 一系列动作之前，客户端和服务端的数据都是<strong>明文传输</strong>的；当 TLS 完成握手过程后，客户端和服务端确定了加密，压缩和 MAC 算法及其参数，数据（Record）会通过指定算法处理。</p>
<blockquote>
<p>其中，Record 首先被加密，然后添加 MAC（message authentication code）以保证数据完整性。</p>
</blockquote>
<h3 id="tls-handshaking-protocols">TLS Handshaking Protocols</h3>
<p>Handshakeing protocols 包括 Alert Protocol，Change Ciper Spec Protocol 和 Handshake protocol。本文不会详细介绍 Alert Protocol 和 Change Ciper Spec Protocol。</p>
<p>使用 <code>RSA</code> 算法的握手过程是这样的（已在总览中提到）</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<p>客户端和服务端在握手 hello 消息中明文交换了 <code>client_random</code> 和 <code>server_random</code> ，使用 <code>RSA</code> 公钥加密传输 <code>premaster secret</code> ，最后通过算法，客户端和服务端分别计算 <code>master secret</code>。其中，不直接使用 <code>premaster secret</code> 的原因是：保证 <code>secret</code> 的随机性不受任意一方的影响。</p>
<p>除了使用 <code>RSA</code> 算法在公共信道交换密钥，还可以通过 <code>Diffie–Hellman</code> 算法。<code>Diffie–Hellman</code> 算法的原理是这样的</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-sub-html="<h2>By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</h2>">
        
    </a><figcaption class="image-caption">By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</figcaption>
    </figure>
<p>使用 <code>Diffie–Hellman</code> 算法交换 <code>premaster secret</code> 的流程</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<h2 id="小结">小结</h2>
<p><code>TLS Handshaking Protocols</code> 协商了 <code>TLS Record Protocol</code> 使用的算法和所需参数，并验证了服务端身份；</p>
<p><code>TLS Record Protocol</code> 在协商后保证应用层数据的完整性和隐私性。</p>
<p><code>TLS Handshaking Protocol</code> 的核心是在公开信道上传递 <code>premaster secret</code>。</p>
<h2 id="qa">Q&amp;A</h2>
<h3 id="为什么传输内容不直接使用非对称加密">为什么传输内容不直接使用非对称加密？</h3>
<p>因为性能限制。</p>
<h3 id="https-能保证正常连接">HTTPS 能保证正常连接？</h3>
<p>不能。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support.</div>
        </div>
    </div>
<p>攻击者甚至可以直接丢弃双方的数据包</p>
<h3 id="服务端如何验证客户端身份">服务端如何验证客户端身份？</h3>
<p>通过 <code>Client Certificate</code></p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">This message conveys the client’s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite’s key exchange algorithm, and any negotiated extensions.</div>
        </div>
    </div>
<h3 id="alert-protocol-有什么作用">Alert protocol 有什么作用？</h3>
<p><code>Closure Alerts</code>：防止 <code>Truncation Attack</code></p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">In a truncation attack, an attacker inserts into a message a TCP code indicating the message has finished, thus preventing the recipient picking up the rest of the message. To prevent this, SSL from version v3 onward has a closing handshake, so the recipient knows the message has not ended until this has been performed.</div>
        </div>
    </div>
<p>Error Alerts：错误处理</p>
<h3 id="master-secret-是如何计算的">master secret 是如何计算的</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  master_secret = PRF (pre_master_secret, &#34;master secret&#34;,
                      ClientHello.random + ServerHello.random)
                      [0..47];
</code></pre></td></tr></table>
</div>
</div><h3 id="加密压缩和-mac-算法参数是如何计算的">加密，压缩和 MAC 算法参数是如何计算的</h3>
<p><code>Handshaking Protocols</code> 使得客户端和服务端交换了三个参数：<code>client_random</code>，<code>server_random</code> 和 <code>master_secret</code>，通过以下算法生成算法所需要的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">To generate the key material, compute

  key_block = PRF (SecurityParameters.master_secret,
                  &#34;key expansion&#34;,
                  SecurityParameters.`server_random` +
                  SecurityParameters.`client_random`);

until enough output has been generated.  Then, the key_block is
partitioned as follows:

  client_write_MAC_key [SecurityParameters.mac_key_length]
  server_write_MAC_key [SecurityParameters.mac_key_length]
  client_write_key [SecurityParameters.enc_key_length]
  server_write_key [SecurityParameters.enc_key_length]
  client_write_IV [SecurityParameters.fixed_iv_length]
  server_write_IV [SecurityParameters.fixed_iv_length]
</code></pre></td></tr></table>
</div>
</div><div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key</div>
        </div>
    </div>
<p>使用 <code>Diffie-Hellman</code> 算法的 <code>TLS</code> 握手细节</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" data-sub-html="<h2>Source: https://cipherstuff.wordpress.com/</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://cipherstuff.wordpress.com/">https://cipherstuff.wordpress.com/</a></figcaption>
    </figure>
<h2 id="拓展阅读">拓展阅读</h2>
<ul>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless</a></li>
<li><a href="https://letsencrypt.org/" target="_blank" rel="noopener noreffer">Let’s Encrypt</a></li>
<li>Session resume</li>
<li>证书 Revoke</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener noreffer">TLS1.2 规范</a></p>
</li>
<li>
<p>[2] <a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener noreffer">PKI 规范</a></p>
</li>
<li>
<p>[3] <a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener noreffer">证书和数字签名</a></p>
</li>
<li>
<p>[4] <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">TLS Handshake</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
