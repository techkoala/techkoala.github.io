<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - TechKoala - Input/Output </title>
        <link>https://www.techkoala.top/posts/</link>
        <description>所有文章 | TechKoala - Input/Output </description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.top (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.top (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 02 Nov 2020 21:16:56 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/posts/" rel="self" type="application/rss+xml" /><item>
    <title>LTE 系列：功率控制</title>
    <link>https://www.techkoala.top/lte_power_control/</link>
    <pubDate>Mon, 02 Nov 2020 21:16:56 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/lte_power_control/</guid>
    <description><![CDATA[<blockquote>
<p>LTE 功率控制</p>
</blockquote>
<h2 id="功率控制">功率控制</h2>
<p>针对上行和下行信号的发送特点，物理层定义了相应的功率控制的机制。</p>
<ul>
<li>
<p>对于上行信号，终端的功率控制在<strong>节能</strong>和<strong>抑制用户间干扰</strong>的方面具有重要意义，所以，相应的采用<strong>闭环功率控制</strong>的方式，控制终端在上行单载波符号上的发送功率。</p>
</li>
<li>
<p>对于下行信号，基站合理的功率分配和相互之间的协调能够<strong>抑制小区间的干扰</strong>，提高组网的系统性能，所以，相应的采用<strong>开环功率分配</strong>的机制，控制基站在下行各个子载波上的发送功率。</p>
</li>
</ul>
<h3 id="上行功率控制">上行功率控制</h3>
<p>上行功率控制以<strong>各个终端为单位</strong>，控制终端到达基站的接收功率，使得不同距离的用户都能以适当的功率到达基站，<strong>避免远近效应</strong>。物理层上行采用<strong>部分功率控制</strong>（Fractional Power Control）结合<strong>闭环功率控制</strong>的方案，对无线链路的大尺度衰落和小尺度衰落进行补偿。</p>
<p>在子帧 i，终端 <code>PUSCH</code> 信道的发射功率可以表示为：</p>
<center>$P_{PUSCH}(i)=min\{P_{CMAX},10log_{10}(M_{PUSCH}(i))+P_{O_{PUSCH}} (j)+α(j)·PL+∆TF (i)+f(i)\}[dBm]$</center>
<p>其中：</p>
<ul>
<li>$P_{CMAX}$ 表示终端的最大发射功率</li>
<li>$M_{PUSCH}(i)$ 表示 <code>PUSCH</code> 的传输带宽（RB 数目）</li>
<li>$PL$ 是终端测量得到的下行大尺度损耗</li>
<li>$∆TF (i)$ 表示由调制编码方式和数据类型（控制信息或者数据信息）所确定的功率偏移量。</li>
<li>$KS＝1.25$ 或者 0，表示是否针对不同的调制方式进行补偿</li>
<li>$f(i)$ 是由终端闭环功率控制所形成的调整值。它的数值根据 <code>PDCCH Format0/3/3A</code> 上的功率控制命令进行调整</li>
</ul>
<p>物理层有两种闭环功率控制类型：</p>
<ul>
<li><strong>累计型（accumulation）</strong></li>
<li><strong>绝对值型（absolute）</strong></li>
</ul>
<p>与上行数据调度相类似</p>
<ul>
<li>在 <code>FDD</code> 情况下，<code>PDCCH Format 0/3/3A</code> 功率控制命令和相应的 <code>PUSCH</code> 发送之间的时延是 4ms</li>
<li>在 <code>TDD</code> 情况下，该时延的数值根据上下行时间分配比例的不同而有所不同</li>
</ul>
<p>与功率控制相结合，可以通过小区之间交换干扰情况的信息，进行协调的调度，抑制小区间的同频干扰，小区间 X2 接口上交互的信息有两种：</p>
<ul>
<li><strong>过载指示（Overload Indicator，OI）</strong>：指示本小区每个 <code>PRB</code> 上受到的上行干扰情况。相邻小区通过交换该消息了解对方目前的负载情况，并进行适当的调整</li>
<li><strong>干扰指示（High Interference Indicator，HII）</strong>：指示本小区每个 PRB 对于上行干扰的敏感度情况。该消息反映了本小区的调度安排，相邻小区通过交换该信息了解对方将要采用的调度安排，并进行适当的调整以实现协调的调度。</li>
</ul>
<h3 id="下行功率分配">下行功率分配</h3>
<p>下行功率分配以每个 <code>RE</code> 为单位，控制基站在<strong>各个时刻各个子载波</strong>上的发射功率。</p>
<p>下行功率分配中包括了</p>
<ul>
<li>提高导频信号的发射功率（即 power boosting）</li>
<li>用户调度相结合实现小区间干扰抑制的相关机制</li>
</ul>
<p>小区公用导频信号（CRS）在频率上和时间上采用<strong>恒定</strong>的发射功率，基站通过高层信令指示该发射功率的数值，在接收端，终端通过测量该信号的平均接收功率并与信令指示的发射功率进行比较，获得<strong>大尺度衰落</strong>的数值。</p>
<p>下行共享信道 <code>PDSCH</code> 的发射功率表示为 <code>PDSCH RE</code> 与 <code>CRS RE</code> 的功率比值，即 $ρA$ 和 $ρB$ 。其中</p>
<ul>
<li>$ρA$ 表示时隙内<strong>不带有</strong> <code>CRS</code> 导频信号的 <code>OFDM</code> 符号上（例如：2 天线、<code>Normal CP</code> 的情况下，时隙内的第 1、2、3、5、6 个 <code>OFDM</code> 符号），<code>PDSCH RE</code> 与 <code>CRS RE</code> 的功率比值</li>
<li>$ρB$ 表示时隙内<strong>带有</strong> <code>CRS</code> 导频信号的 <code>OFDM</code> 符号上（例如：2 天线、<code>Normal CP</code> 的情况下，时隙内第 0、4 个 <code>OFDM</code> 符号），<code>PDSCH RE</code> 与 <code>CRS RE</code> 的功率比值</li>
</ul>
<h4 id="提高-crs-导频信号的发射功率即-power-boosting">提高 CRS 导频信号的发射功率（即 power boosting）</h4>
<p>小区通过高层信令指示 $\frac{ρB}{ρA}$，通过不同的比值可以设置导频信号在基站总功率中不同的开销比例，由此实现了不同程度地提高 <code>CRS</code> 导频信号发射功率的功能。</p>
<blockquote>
<p>例：以发射天线数目等于 2 为例，支持 4 种不同的小区配置 $\frac{ρB}{ρA}=[\frac{5}{4},1,\frac{3}{4},\frac{1}{2}]$，分别对应于导频占总功率开销为$[\frac{1}{6}，\frac{1}{3}，\frac{3}{6}，\frac{2}{3}]$的情况。</p>
<p>下图表示了 $\frac{ρB}{ρA} =1$ 和 $\frac{ρB}{ρA} =\frac{1}{2}$ 时天线端口 #0 的信号功率情况，分别实现了导频信号以 3dB 和 9dB 高于同一 <code>OFDM</code> 符号中数据元素的发送功率。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_Physical_Layer/LTE_physical_layer_43.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_Physical_Layer/LTE_physical_layer_43.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_Physical_Layer/LTE_physical_layer_43.webp" data-sub-html="<h2>两种情况下天线端口 #0 的信号功率</h2>">
        
    </a><figcaption class="image-caption">两种情况下天线端口 #0 的信号功率</figcaption>
    </figure>
</blockquote>
<h4 id="用户功率分配和小区间干扰协调">用户功率分配和小区间干扰协调</h4>
<p>在指示 $\frac{ρB}{ρA}$ 的基础上，通过高层参数 $P_A$ 可以确定 $ρA$ 的具体数值，得到基站下行针对用户的 <code>PDSCH</code> 发射功率，该信息将用于 <code>16QAM</code>、<code>64QAM</code> 和 <code>MU-MIMO</code> 等需要幅度信息的检测过程。$P_A$ 和 $ρA$ 的数值关系是</p>
<center>$ρ_A =δ_{power-offset} +P_A$</center>
<p>其中 $δ_{power-offset}$ 用于 <code>MU-MIMO</code> 的场景，例如 $δ_{power-offset} =−3dB$ 可以表示功率平均分配给两个用户的情况。</p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] LTE-Advanced 关键技术详解</li>
</ul>]]></description>
</item><item>
    <title>告知你不为人知的 UDP —— 疑难杂症和使用</title>
    <link>https://www.techkoala.top/udp_intractable_diseases/</link>
    <pubDate>Mon, 26 Oct 2020 11:06:30 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/udp_intractable_diseases/</guid>
    <description><![CDATA[<blockquote>
<p>UDP 说来简单，但是一些细节你都清楚吗？</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：贺嘉</p>
<p>链接：https://zhuanlan.zhihu.com/p/25622691</p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="udp-疑难杂症">UDP 疑难杂症</h2>
<h3 id="udp-的传输方式面向报文">UDP 的传输方式：面向报文</h3>
<p>面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么 UDP 的报文大小由哪些影响因素呢？UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？</p>
<h4 id="udp-报文大小的影响因素主要有以下-3-个">UDP 报文大小的影响因素，主要有以下 3 个</h4>
<ul>
<li>UDP 协议本身，UDP 协议中有 16 位的 UDP 报文长度，那么 UDP 报文长度不能超过 $2^{16}=65536$.</li>
<li>以太网(Ethernet)数据帧的长度，数据链路层的 MTU(最大传输单元)。</li>
<li>socket 的 UDP 发送缓存区大小</li>
</ul>
<h4 id="udp-数据包最大长度">UDP 数据包最大长度</h4>
<p>根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 $2^{16}$ 的个字节。由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的<strong>最大理论长度</strong>是 $2^{16} - 1 - 8 - 20 = 65507$ 字节。</p>
<p>如果发送的数据包超过 65507 字节，send 或 sendto 函数会错误码 1(Operation not permitted，Message too long)，当然啦，一个数据包能否发送 65507 字节，还和 UDP 发送缓冲区大小（Linux 下 UDP 发送缓冲区大小为：<code>cat /proc/sys/net/core/wmem_default</code>）相关，如果发送缓冲区小于 65507 字节，在发送一个数据包为 65507 字节的时候，send 或 sendto 函数会错误码 1(Operation not permitted，No buffer space available)。</p>
<h4 id="udp-数据包理想长度">UDP 数据包理想长度</h4>
<p>理论上 UDP 报文最大长度是 <strong>65507</strong> 字节，实际上发送这么大的数据包效果最好吗？</p>
<ul>
<li>
<p>我们知道 UDP 是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们<strong>最好</strong>能控制 UDP 包在下层协议的传输过程中<strong>不要被切割</strong>。</p>
<p>相信大家都知道 MTU 这个概念。MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet II 帧的结构 DMAC+SMAC+Type+Data+CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小 <strong>64</strong> 字节，最大不能超过 <strong>1518</strong> 字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是 1518 字节，除去以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes 那么剩下承载上层协议的地方也就是 Data 域最大就只能有 <strong>1500</strong> 字节这个值我们就把它称之为 MTU。</p>
<p>在下层数据链路层最大传输单元是 1500 字节的情况下，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是 1500 字节 – IP 头(20 字节) – UDP 头(8 字节) = <strong>1472</strong> 字节。不过鉴于 Internet 上的标准 MTU 值为 <strong>576</strong> 字节，所以建议在进行 Internet 的 UDP 编程时，最好将 UDP 的数据长度控制在 (576-8-20)<strong>548</strong> 字节以内。</p>
</li>
</ul>
<h3 id="udp-数据包的发送和接收问题">UDP 数据包的发送和接收问题</h3>
<h4 id="udp-的通信有界性">UDP 的通信有界性</h4>
<p>在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。</p>
<h4 id="udp-数据包的无序性和非可靠性">UDP 数据包的无序性和非可靠性</h4>
<p>Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。</p>
<h4 id="udp-数据包的接收">UDP 数据包的接收</h4>
<p>Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？</p>
<ul>
<li>由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。</li>
</ul>
<p>在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？</p>
<ul>
<li>由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。</li>
</ul>
<h4 id="udp-包分片问题">UDP 包分片问题</h4>
<p>如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？</p>
<ul>
<li>根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。</li>
</ul>
<h3 id="udp-丢包问题">UDP 丢包问题</h3>
<p>在不考虑 UDP 下层 IP 层的分片丢失，CRC 检验包不完整的情况下，造成 UDP 丢包的因素有哪些呢？</p>
<ol>
<li>UDP socket 缓冲区满造成的 UDP 丢包</li>
</ol>
<ul>
<li>通过 <code>cat /proc/sys/net/core/rmem_default</code> 和 <code>cat /proc/sys/net/core/rmem_max</code> 可以查看 socket 缓冲区的缺省值和最大值。如果 socket 缓冲区满了，应用程序没来得及处理在缓冲区中的 UDP 包，那么后续来的 UDP 包会被内核丢弃，造成丢包。在 socket 缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解 UDP 丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。</li>
</ul>
<ol>
<li>UDP socket 缓冲区过小造成的 UDP 丢包</li>
</ol>
<ul>
<li>如果 Client 发送的 UDP 报文很大，而 socket 缓冲区过小无法容下该 UDP 报文，那么该报文就会丢失。</li>
</ul>
<ol start="2">
<li>ARP 缓存过期导致 UDP 丢包</li>
</ol>
<ul>
<li>
<p>ARP 的缓存时间约 10 分钟，APR 缓存列表没有对方的 MAC 地址或缓存过期的时候，会发送 ARP 请求获取 MAC 地址，在没有获取到 MAC 地址之前，用户发送出去的 UDP 数据包会被内核缓存到 arp_queue 这个队列中，默认最多缓存 3 个包，多余的 UDP 包会被丢弃。</p>
<p>被丢弃的 UDP 包可以从 <code>/proc/net/stat/arp_cache</code> 的最后一列的 <code>unresolved_discards</code> 看到。当然我们可以通过 <code>echo 30 &gt; /proc/sys/net/ipv4/neigh/eth1/unres_qlen</code> 来增大可以缓存的 UDP 包。UDP 的丢包信息可以从 <code>cat /proc/net/udp</code> 的最后一列 drops 中得到，而倒数第四列 inode 是丢失 UDP 数据包的 socket 的全局唯一的虚拟 i 节点号，可以通过这个 inode 号结合 <code>lsof(lsof -P -n | grep 25445445)</code>来查到具体的进程。</p>
</li>
</ul>
<h3 id="udp-冗余传输">UDP 冗余传输</h3>
<p>在外网通信链路不稳定的情况下，有什么办法可以降低 UDP 的丢包率呢？</p>
<p>一个简单的办法来采用<strong>冗余传输</strong>的方式。一般采用较多的是延时双发，双发指的是将原本单发的前后连续的两个包合并成一个大包发送，这样发送的数据量是原来的两倍。这种方式提高丢包率的原理比较简单，例如本例的冗余发包方式，在偶数包全丢的情况下，依然能够还原出完整的数据，也就是在这种情况下，50% 的丢包率，依然能够达到 100% 的数据接收。</p>
<h2 id="udp-真的比-tcp-要高效吗">UDP 真的比 TCP 要高效吗</h2>
<p>相信很多同学都认为 UDP 无连接，无需重传和处理确认，UDP 比较高效。然而 UDP 在大多情况下并不一定比 TCP 高效，TCP 发展至今天，为了适应各种复杂的网络环境，其算法已经非常丰富，协议本身经过了很多优化，如果能够合理配置 TCP 的各种参数选项，那么在多数的网络环境下 TCP 是要比 UDP 更高效的。</p>
<h3 id="影响-udp-高效因素">影响 UDP 高效因素</h3>
<h4 id="无法智能利用空闲带宽导致资源利用率低">无法智能利用空闲带宽导致资源利用率低</h4>
<p>一个简单的事实是 UDP 并不会受到 MTU 的影响，MTU 只会影响下层的 IP 分片，对此 UDP 一无所知。在极端情况下，UDP 每次都是发小包，包是 MTU 的几百分之一，这样就造成 UDP 包的有效数据占比较小(UDP 头的封装成本)；或者，UDP 每次都是发巨大的 UDP 包，包大小 MTU 的几百倍，这样会造成下层 IP 层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个 UDP 包的无效。由于网络情况是动态变化的，UDP 无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而 TCP 有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP 的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。</p>
<h4 id="无法动态调整发包">无法动态调整发包</h4>
<p>由于 UDP 没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP 并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，UDP 的无秩序性和自私性，一个疯狂的 UDP 程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。</p>
<h4 id="改进-udp-的成本较高">改进 UDP 的成本较高</h4>
<p>可能有同学想到针对 UDP 的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，UDP 编程可是比 TCP 要难不少的，考虑到改造成本，为什么不直接用 TCP 呢？当然可以拿开源的一些实现来抄一下(例如：libjingle)，或者拥抱一下 Google 的 QUIC 协议，然而，这些都需要不少成本的。</p>
<p>上面说了这么多，难道真的不该用 UDP 了吗？其实也不是的，在某些场景下，我们还是必须 UDP 才行的。那么 UDP 的较为合适的使用场景是哪些呢？</p>
<h2 id="udp-的使用场合">UDP 的使用场合</h2>
<h3 id="通信实时性和持续性">通信实时性和持续性</h3>
<p>在分组交换通信当中，协议栈的成本主要表现在以下两方面：</p>
<ul>
<li>封装带来的空间复杂度</li>
<li>缓存带来的时间复杂度</li>
</ul>
<p>以上两者是对立影响的，如果想减少封装消耗，那么就必须缓存用户数据到一定量在一次性封装发送出去，这样每个协议包的有效载荷将达到最大化，这无疑是节省了带宽空间，带宽利用率较高，但是延时增大了。如果想降低延时，那么就需要将用户数据立马封装发出去，这样显然会造成消耗更多的协议头等消耗，浪费带宽空间。</p>
<p>因此，我们进行协议选择的时候，需要重点考虑一下<strong>空间复杂度</strong>和<strong>时间复杂度</strong>间的平衡。</p>
<p>通信的持续性对两者的影响比较大，根据通信的持续性有两种通信类型：</p>
<ul>
<li>短连接通信</li>
<li>长连接通信</li>
</ul>
<p>对于短连接通信，一方面如果业务只需要发一两个包并且对丢包有一定的容忍度，同时业务自己有简单的轮询或重复机制，那么采用 UDP 会较为好些。在这样的场景下，如果用 TCP，仅仅握手就需要 3 个包，这样显然有点不划算，一个典型的例子是 DNS 查询。另一方面，如果业务实时性要求非常高，并且不能忍受重传，那么首先就是 UDP 了或者只能用 UDP 了，例如 NTP 协议，重传 NTP 消息纯属添乱(为什么呢？重传一个过期的时间包过来，还不如发一个新的 UDP 包同步新的时间过来)。如果 NTP 协议采用 TCP，撇开握手消耗较多数据包交互的问题，由于 TCP 受 Nagel 算法等影响，用户数据会在一定情况下会被内核缓存延后发送出去，这样时间同步就会出现比较大的偏差，协议将不可用。</p>
<h3 id="多点通信">多点通信</h3>
<p>对于一些多点通信的场景，如果采用有连接的 TCP，那么就需要和多个通信节点建立其双向连接，然后有时在 NAT 环境下，两个通信节点建立其直接的 TCP 连接不是一个容易的事情，在涉及 NAT 穿越的时候，UDP 协议的无连接性使得穿透成功率更高(原因详见：由于 UDP 的无连接性，那么其完全可以向一个组播地址发送数据或者轮转地向多个目的地持续发送相同的数据，从而更为容易实现多点通信。)</p>
<p>一个典型的场景是多人实时音视频通信，这种场景下实时性要求比较高，可以容忍一定的丢包率。比如：对于音频，对端连续发送 p1、p2、p3 三个包，另一端收到了 p1 和 p3，在没收到 p2 的保持 p1 的最后一个音（也是为什么有时候网络丢包就会听到嗞嗞嗞嗞嗞嗞…或者卟卟卟卟卟卟卟卟…重音的原因），等到到 p3 就接着播 p3 了，不需要也不能补帧，一补就越来越大的延时。对于这样的场景就比较合适用 UDP 了，如果采用 TCP，那么在出现丢包的时候，就可能会出现比较大的延时。</p>
<h3 id="udp-使用原则">UDP 使用原则</h3>
<p>通常情况下，UDP 的使用范围是较小的，在以下的场景下，使用 UDP 才是明智的：</p>
<ul>
<li>实时性要求很高，并且几乎不能容忍重传。例子：NTP 协议，实时音视频通信，多人动作类游戏中人物动作、位置</li>
<li>TCP 实在不方便实现多点传输的情况</li>
<li>需要进行 NAT 穿越</li>
<li>对网络状态很熟悉，确保 UDP 网络中没有氓流行为，例如疯狂抢带宽</li>
<li>熟悉 UDP 编程</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="http://blog.csdn.net/dog250/article/details/6896949http://blog.csdn.net/dog250/article/details/6896949" target="_blank" rel="noopener noreffer">Netfilter,iptables/OpenVPN/TCP guard</a></li>
</ul>]]></description>
</item><item>
    <title>DNS 报文详解</title>
    <link>https://www.techkoala.top/dns/</link>
    <pubDate>Tue, 20 Oct 2020 13:24:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns/</guid>
    <description><![CDATA[<blockquote>
<p>本文主要讲解 DNS 的报文结构</p>
</blockquote>
<h2 id="dns-简介">DNS 简介</h2>
<p>简单来说 DNS 负责将我们熟知的域名翻译成 IP 地址，其相关定义由 RFC 1034 和 RFC 1035 给出。</p>
<p>为了更加的扩展性，DNS 由大量的服务器分层次进行组织的，大致来说分为：根 DNS 服务器、顶域名（TLD）DNS 服务器和权威 DNS 服务器。他们的层次结构如下图所示：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Level.webp" data-sub-html="<h2>DNS 的层次结构</h2>">
        
    </a><figcaption class="image-caption">DNS 的层次结构</figcaption>
    </figure>
<p>关于 DNS 的工作过程及相关信息参见<a href="https://www.techkoala.top/dns_update/" target="_blank" rel="noopener noreffer">深入浅出 DNS 解析</a>，本文负责补充 DNS 报文结构。</p>
<h3 id="dns-报文结构">DNS 报文结构</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/DNS_Structure.webp" data-sub-html="<h2>DNS 的报文结构</h2>">
        
    </a><figcaption class="image-caption">DNS 的报文结构</figcaption>
    </figure>
<ul>
<li>
<p>前 12 个字节为<strong>首部</strong>，包含：</p>
<ul>
<li>
<p><strong>标识符</strong>（2 字节），用于标识请求及其响应报文，区分不同的查询</p>
</li>
<li>
<p><strong>标志</strong>（2 字节），其中：</p>
<ul>
<li><strong>QR</strong>（1bit）：查询/响应标志，<code>0</code> 为查询，<code>1</code> 为响应</li>
<li><strong>opcode</strong>（4bit）：<code>0</code> 表示标准查询，<code>1</code> 表示反向查询，<code>2</code> 表示服务器状态请求，<code>[3,15]</code>为保留值</li>
<li><strong>AA</strong>（1bit）：表示授权回答，这个比特位在应答的时候才有意义，指出给出应答的服务器是查询域名的授权解析服务器</li>
<li><strong>TC</strong>（1bit）：表示可截断的，用来指出报文比允许的长度还要长，导致被截断;</li>
<li><strong>RD</strong>（1bit）：表示期望递归，这个比特位被<strong>请求</strong>设置，应答的时候使用的相同的值返回。如果设置了 RD，就建议域名服务器进行递归解析，递归查询的支持是可选的;</li>
<li><strong>RA</strong>（1bit）：表示可用递归，这个比特位在<strong>应答</strong>中设置或取消，用来代表服务器是否支持递归查询;</li>
<li><strong>rcode</strong>（4bit）：表示返回码
<ul>
<li><code>0</code> : 没有错误</li>
<li><code>1</code> : 报文格式错误(Format error) - 服务器不能理解请求的报文</li>
<li><code>2</code> : 服务器失败(Server failure) - 因为服务器的原因导致没办法处理这个请求</li>
<li><code>3</code> : 名字错误(Name Error) - 只有对授权域名解析服务器有意义，指出解析的域名不存在</li>
<li><code>4</code> : 没有实现(Not Implemented) - 域名服务器不支持查询类型</li>
<li><code>5</code> : 拒绝(Refused) - 服务器由于设置的策略拒绝给出应答.比如，服务器不希望对某些请求者给出应答，或者服务器不希望进行某些操作（比如区域传送 zone transfer）</li>
<li><code>[6,15]</code> : 保留值，暂未使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数量字段</strong>（8 字节）：每个区域 2 字节</p>
<ul>
<li><strong>Questions</strong> 表示查询问题区域节的数量</li>
<li><strong>Answers</strong> 表示回答区域的数量</li>
<li><strong>Authoritative namesversers</strong> 表示授权区域的数量</li>
<li><strong>Additional recoreds</strong> 表示附加区域的数量</li>
</ul>
</li>
<li>
<p><strong>问题</strong>（Questions）部分包括：</p>
<ul>
<li>查询的域名 8bit 为单位，长度不受限</li>
<li>查询的协议类型 16bit</li>
<li>查询的类 16bit</li>
</ul>
</li>
<li>
<p><strong>回答</strong>（Answers）/<strong>权威</strong>（Authoritys）/<strong>附加</strong>（Additionals）部分格式相同：</p>
<ul>
<li><strong>NAME</strong> 资源记录包含的域名.</li>
<li><strong>TYPE</strong> 表示 DNS 协议的类型.</li>
<li><strong>CLASS</strong> 表示 RDATA 的类.</li>
<li><strong>TTL</strong> 4 字节无符号整数表示资源记录可以缓存的时间。0 代表只能被传输，但是不能被缓存。</li>
<li><strong>RDLENGTH</strong> 2 个字节无符号整数表示 RDATA 的长度</li>
<li><strong>RDATA</strong> 不定长字符串来表示记录，格式根 TYPE 和 CLASS 有关。比如，TYPE 是 A，CLASS 是 IN，那么 RDATA 就是一个 4 个字节的 ARPA 网络地址。</li>
</ul>
</li>
</ul>
<h2 id="rrs-说明">RRs 说明</h2>
<p>每个 DNS 响应报文包含一条或者多条资源记录（resource records ，RRs），资源记录包含下列字段的 4 元组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">（Name，Value，Type，TTL）
</code></pre></td></tr></table>
</div>
</div><p>其中 TTL 表示生存时间，决定了资源记录应该从缓存中删除的时间。</p>
<ul>
<li>如果是 Type=A，Name 为主机名，Value 是对应的 IP 地址（如 bar.foo.com，xxx.xxx.xxx.xxx，A）</li>
<li>如果是 Type=NS，Name 为一个域（如 foo.com），Value 是知道如何获取该域中的主机 IP 地址的权威 DNS 服务器的主机名（如 foo.com，dns.foo.com，NS）</li>
<li>如果是 Type=CNAME，Value 是别名为 Name 的主机对应的规范主机名。（如 foo.com，relay1.bar.foo.com，CNAME）</li>
<li>如果是 Type=MX，Value 是别名为 Name 的邮件服务器对应的规范主机名。（如 foo.com，mail.bar.foo.com，MX）</li>
</ul>
<h2 id="实例">实例</h2>
<p>这里我们使用 WireShark 抓包实际看看，启动 WireShark 时可以设置捕获过滤器为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">udp port 53
</code></pre></td></tr></table>
</div>
</div><p>这样我们只抓取通过 UDP 53 端口的 DNS 请求，此外如果需要仅仅显示特定的 DNS 查询，还可以进一步应用显示过滤器，例如这里我们仅查看<code>www.techkoala.top</code>的查询记录，则显示过滤器设置为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dns.qry.name==www.techkoala.top
</code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_16.webp" data-sub-html="<h2>16 进制表示</h2>">
        
    </a><figcaption class="image-caption">16 进制表示</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request.webp" data-sub-html="<h2>WireShark 中 DNS 请求报文及其结构</h2>">
        
    </a><figcaption class="image-caption">WireShark 中 DNS 请求报文及其结构</figcaption>
    </figure>
<p>可以看出</p>
<ul>
<li>标识为：0x0000cd13</li>
<li>这是一个请求报文，仅在 Questions 部分有值</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Flags.webp" data-sub-html="<h2>标志部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">标志部分各个字段的值</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Request_Queries.webp" data-sub-html="<h2>查询部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">查询部分各个字段的值</figcaption>
    </figure>
<p>同时 WireShark 还贴心的告诉我们，响应报文的在总抓取包的编号为 10，方便我们快速找到请求报文对应的响应报文。</p>
<p><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_16.webp" data-sub-html="<h2>16进制表示</h2>">
        
    </a><figcaption class="image-caption">16进制表示</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response.webp" data-sub-html="<h2>WireShark 中 DNS 响应报文及其结构</h2>">
        
    </a><figcaption class="image-caption">WireShark 中 DNS 响应报文及其结构</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Flags.webp" data-sub-html="<h2>标志部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">标志部分各个字段的值</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/DNS/Response_Queries.webp" data-sub-html="<h2>查询部分各个字段的值</h2>">
        
    </a><figcaption class="image-caption">查询部分各个字段的值</figcaption>
    </figure></p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] Computer Networking A Top-Down Approach</li>
<li>[2] <a href="https://juejin.im/post/6844903582441963527" target="_blank" rel="noopener noreffer">DNS 请求报文详解</a></li>
</ul>]]></description>
</item><item>
    <title>ARP &amp; RARP 详解</title>
    <link>https://www.techkoala.top/arp_rarp/</link>
    <pubDate>Fri, 16 Oct 2020 15:56:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/arp_rarp/</guid>
    <description><![CDATA[<blockquote>
<p>ARP 以及 RARP 如何工作？</p>
</blockquote>
<h2 id="为什么要有-mac-地址">为什么要有 MAC 地址？</h2>
<p>在说明 ARP 以及 RARP 之前，有必要首先说一下 MAC 地址的必要性。</p>
<p>引用《Computer Networking A Top-Down Approach》中的描述：</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>KEEPING THE LAYERS INDEPENDENT<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">There are several reasons why hosts and router interfaces have MAC addresses in addition to network-layer addresses. First, LANs are designed for arbitrary network-layer protocols, not just for IP and the Internet. If adapters were assigned IP addresses rather than “neutral” MAC addresses, then adapters would not easily be able to support other network-layer protocols (for example, IPX or DECnet). Second, if adapters were to use network-layer addresses instead of MAC addresses, the network-layer address would have to be stored in the adapter RAM and reconfigured every time the adapter was moved (or powered up). Another option is to not use any addresses in the adapters and have each adapter pass the data (typically, an IP datagram) of each frame it receives up the protocol stack. The network layer could then check for a matching network-layer address. One problem with this option is that the host would be interrupted by every frame sent on the LAN, including by frames that were destined for other hosts on the same broadcast LAN. In summary, in order for the layers to be largely independent building blocks in a network architecture, different layers need to have their own addressing scheme. We have now seen three types of addresses: host names for the application layer, IP addresses for the network layer, and
MAC addresses for the link layer.</div>
        </div>
    </div>
<p>简单来说：</p>
<ul>
<li>局域网不仅仅为 IP 和因特网设计，MAC 地址的“中立性”为各种网络层协议（比如 IPX 或者 DECnet)提供了灵活的施展空间</li>
<li>网络层地址往往是动态的，每次更换网络或者重启都需要对适配器进行重新配置</li>
<li>如果取消 MAC 地址，让适配器把收到的每帧都往上层传递，就会带来一个问题：主机会去处理局域网中的每个帧，即使这个帧不属于自己，这就带来了不必要的消耗。</li>
</ul>
<h2 id="arp">ARP</h2>
<p>一句话概括 ARP（Address Resolution Protocol，地址解析协议）的目的就是：负责将<strong>网络层地址</strong>（最常见的就是 IP 地址）解析为/映射到<strong>链路层地址</strong>（MAC 地址）。</p>
<h3 id="报文结构">报文结构</h3>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP.webp" data-sub-html="<h2>ARP 包结构</h2>">
        
    </a><figcaption class="image-caption">ARP 包结构</figcaption>
    </figure>
<p>一般我们讨论以太网中的 ARP 报文时候，ARP 数据会被封装在以太网报文中，其中：</p>
<ul>
<li>
<p>以太网报文：</p>
<ul>
<li><strong>目标以太网地址</strong>：目标 MAC 地址，FF:FF:FF:FF:FF:FF （二进制全 1）为广播地址</li>
<li><strong>源以太网地址</strong>：发送方 MAC 地址</li>
<li><strong>帧类型</strong>：以太类型，<strong>ARP 为 0x0806</strong></li>
</ul>
</li>
<li>
<p>ARP 报文数据：</p>
<ul>
<li><strong>硬件类型</strong>：如以太网（0x0001）、分组无线网</li>
<li><strong>协议类型</strong>：如网际协议(IP)（0x0800）、IPv6（0x86DD）</li>
<li><strong>硬件地址长度</strong>：每种硬件地址的字节长度，一般为 6（以太网）</li>
<li><strong>协议地址长度</strong>：每种协议地址的字节长度，一般为 4（IPv4）</li>
<li><strong>操作码 OP</strong>：1 为 ARP 请求，2 为 ARP 应答，3 为 RARP 请求，4 为 RARP 应答</li>
<li><strong>源硬件地址</strong>：n 个字节，n 由硬件地址长度得到，一般为发送方 MAC 地址</li>
<li><strong>源协议地址</strong>：m 个字节，m 由协议地址长度得到，一般为发送方 IP 地址</li>
<li><strong>目标硬件地址</strong>：n 个字节，n 由硬件地址长度得到，一般为目标 MAC 地址</li>
<li><strong>目标协议地址</strong>：m 个字节，m 由协议地址长度得到，一般为目标 IP 地址</li>
</ul>
</li>
</ul>
<h3 id="工作原理">工作原理</h3>
<ol>
<li>每台主机都会在自己的 ARP 缓冲区 (ARP Cache)中建立一个 ARP 列表，表示 IP 地址和 MAC 地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址，如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的<strong>广播包</strong>（即将目的硬件地址设置为全 1），查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</li>
<li>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP <strong>单播</strong>响应数据包，告诉对方自己是它需要查找的 MAC 地址；</li>
<li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ol>
<h3 id="代理-arp">代理 ARP</h3>
<p>代理 ARP 是指当 ARP 目标不在同一网段时，网关会拦截该 ARP 请求，然后把自己的 MAC 地址回复给请求者：</p>
<p><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/ARP_Proxy.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
但是需要网关需要满足：</p>
<ul>
<li>开启代理 ARP 功能</li>
<li>有目标的路由信息</li>
</ul>
<p>假如不存在网关但使用代理 ARP，则情况如下：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/whitout_GW.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
<p>存在网关的情况下，使用正常 ARP，则情况如下：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/ARP_RARP/with_GW.webp" data-sub-html="<h2>代理 ARP</h2>">
        
    </a><figcaption class="image-caption">代理 ARP</figcaption>
    </figure>
<p>总结而言：</p>
<ul>
<li>没有网关（采用代理 ARP）时：跨网段访问谁，就问谁的 MAC</li>
<li>有网关（采用正常 ARP）时：跨网段访问谁，都问网关的 MAC</li>
<li>无论使用哪种 ARP，跨网段通信时，发送方请求得到的目标 MAC 地址都是网关 MAC</li>
</ul>
<h2 id="rarp">RARP</h2>
<p>RARP（Reverse Address Resolution Protocol，逆地址解析协议），顾名思义，用于将 MAC 地址映射为网络层地址（例如 IP 地址），用于给 MAC 地址分配 IP 地址（通常在需要远程启动(类似无盘工作站)的系统中使用）。其因为较限于 IP 地址的运用以及其他的一些缺点，因此渐为更新的 BOOTP 或 DHCP 所取代。</p>
<p>RARP 使用与 ARP 相同的报头结构，只是其中的操作码有所区别，见上文。</p>
<h3 id="工作原理-1">工作原理</h3>
<ol>
<li>发送主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址；</li>
<li>本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址；</li>
<li>如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用；</li>
<li>如果不存在，RARP 服务器对此不做任何的响应；</li>
<li>源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。</li>
</ol>
<h2 id="安全问题">安全问题</h2>
<h3 id="arp-欺骗">ARP 欺骗</h3>
<p>源主机通过 ARP 协议在局域网内发送广播请求包，按照 ARP 协议的设想应该是对应主机回复，但如果攻击者进行回复，源主机依然会选择相信。这是由 ARP 协议的不验证引起的，它不验证对方是否是所声称 IP 地址的主机。同时，由于 ARP 协议是一种无状态协议，既不验证应答者的身份，也不判断是否发送过 ARP 请求，当收到一条 ARP 应答报文时，它就会更新 ARP 应答缓存表。因此，攻击者甚至可以<strong>主动</strong>向源主机发送 ARP 响应包，迫使源主机更新其 ARP 缓存表。</p>
<p>对此，一个简单的方法是使用静态绑定地址，但是此方法维护起来较为麻烦。</p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] Computer Networking A Top-Down Approach</li>
<li>[2] <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreffer">地址解析协议</a></li>
<li>[3] <a href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreffer">逆地址解析协议</a></li>
<li>[4] <a href="https://www.jianshu.com/p/782f3b60eb19" target="_blank" rel="noopener noreffer">网络协议补完计划&ndash;ARP 协议和 RARP 协议</a></li>
</ul>]]></description>
</item><item>
    <title>OpenWRT overlay 空间扩容</title>
    <link>https://www.techkoala.top/openwrt_resize/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_resize/</guid>
    <description><![CDATA[<blockquote>
<p>安装 AdguardHome 运行几天后，可怜的剩余空间被日志耗尽，不得不对 OpenWRT overlay 进行扩容，记录一下</p>
</blockquote>
<h2 id="什么是-overlay">什么是 overlay</h2>
<p><code>OpenWRT</code> 一般使用的文件系统是 <code>SquashFS</code> ，这个文件系统的特点就是：<strong>只读</strong>。</p>
<p>一个只读的文件系统要怎么做到保存设置和安装软件的呢？这里就是使用 <code>/overlay</code> 的分区，<code>overlay</code> 顾名思义就是覆盖在上面一层的意思。虽然原来的文件不能修改，但把修改的部分放在 <code>overlay</code> 分区上，然后映射到原来的位置，读取的时候就可以读到修改过的文件了。</p>
<p>为什么要用这么复杂的方法呢？ <code>OpenWRT</code> 当然也可以使用 <code>EXT4</code> 文件系统，但使用 <code>SquashFS + overlay</code> 的方式有一定的优点。</p>
<ul>
<li><code>SquashFS</code> 是经过压缩的，在路由器这种小型 <code>ROM</code> 的设备可以放下更多的东西。</li>
<li><code>OpenWRT</code> 的恢复出厂设置也要依赖于这个方式。在你重置的时候，它只需要把 <code>overlay</code> 分区清空就可以了，一切都回到了刚刷进去的样子。</li>
</ul>
<p>如果是 <code>EXT4</code> 文件系统，就只能够备份每个修改的文件，在恢复出厂设置的时候复制回来，十分复杂。</p>
<p>当然，<code>SquashFS + overlay</code> 也有它的缺点：</p>
<ul>
<li>修改文件的时候会占用更多的空间。首先你不能够删除文件，因为删除文件实际上是在 <code>overlay</code> 分区中写入一个删除的标识，反而占用更多的空间。</li>
<li>另外在修改文件的时候相当于增加了一份文件的副本，占用了双份的空间。</li>
</ul>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/overlay.webp" title="/images/Network/OpenWRT_overlay/overlay.webp" data-thumbnail="/images/Network/OpenWRT_overlay/overlay.webp" data-sub-html="<h2>overlay 示意图</h2>">
        
    </a><figcaption class="image-caption">overlay 示意图</figcaption>
    </figure>
<h2 id="创建新分区">创建新分区</h2>
<p>首先，需要创建一个新的分区，这里使用的是 <code>cfdisk</code></p>
<p>如果没有，首先使用下列命令进行安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ opkg install cfdisk
</code></pre></td></tr></table>
</div>
</div><p>输入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cfdisk
</code></pre></td></tr></table>
</div>
</div><p>打开磁盘管理界面：</p>
<p><figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/cfdisk.webp" title="/images/Network/OpenWRT_overlay/cfdisk.webp" data-thumbnail="/images/Network/OpenWRT_overlay/cfdisk.webp" data-sub-html="<h2>磁盘界面</h2>">
        
    </a><figcaption class="image-caption">磁盘界面</figcaption>
    </figure>
这里可以看到，一共有两个已有分区，现在新建一个分区：</p>
<p>选中 <code>Free Space</code>，再选中 <code>New</code>，输入需要的大小，比如 5G。</p>
<p>接着选择 <code>primary</code></p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/primary.webp" title="/images/Network/OpenWRT_overlay/primary.webp" data-thumbnail="/images/Network/OpenWRT_overlay/primary.webp" data-sub-html="<h2>选择主分区</h2>">
        
    </a><figcaption class="image-caption">选择主分区</figcaption>
    </figure>
<p>选择 <code>Write</code>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/write.webp" title="/images/Network/OpenWRT_overlay/write.webp" data-thumbnail="/images/Network/OpenWRT_overlay/write.webp" data-sub-html="<h2>写入更改</h2>">
        
    </a><figcaption class="image-caption">写入更改</figcaption>
    </figure></p>
<p>输入 <code>yes</code>，完成新分区的创建</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/yes.webp" title="/images/Network/OpenWRT_overlay/yes.webp" data-thumbnail="/images/Network/OpenWRT_overlay/yes.webp" data-sub-html="<h2>确认</h2>">
        
    </a><figcaption class="image-caption">确认</figcaption>
    </figure>
<h2 id="格式化分区">格式化分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mkfs.ext4 /dev/sda3
</code></pre></td></tr></table>
</div>
</div><p>格式化分区</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/format.webp" title="/images/Network/OpenWRT_overlay/format.webp" data-thumbnail="/images/Network/OpenWRT_overlay/format.webp" data-sub-html="<h2>格式化分区</h2>">
        
    </a><figcaption class="image-caption">格式化分区</figcaption>
    </figure>
<h2 id="挂载新分区">挂载新分区</h2>
<p>使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mount /dev/sda3 /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><p>挂载分区</p>
<h2 id="转移到新分区">转移到新分区</h2>
<p>然后将原来 upper 层中的数据复制到新的分区中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">cp -r /overlay/* /mnt/sda3
</code></pre></td></tr></table>
</div>
</div><h2 id="web-界面配置修改">Web 界面配置修改</h2>
<p>进入 <code>OpenWRT</code> Web 界面的<code>挂载点</code>对配置进行修改：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/openwrt.webp" title="/images/Network/OpenWRT_overlay/openwrt.webp" data-thumbnail="/images/Network/OpenWRT_overlay/openwrt.webp" data-sub-html="<h2>Web 界面</h2>">
        
    </a><figcaption class="image-caption">Web 界面</figcaption>
    </figure>
<p>再挂载点处点击添加然后配置如下：</p>
<figure><a class="lightgallery" href="/images/Network/OpenWRT_overlay/mountpoint.webp" title="/images/Network/OpenWRT_overlay/mountpoint.webp" data-thumbnail="/images/Network/OpenWRT_overlay/mountpoint.webp" data-sub-html="<h2>挂载点配置</h2>">
        
    </a><figcaption class="image-caption">挂载点配置</figcaption>
    </figure>
<h2 id="完成">完成</h2>
<p>到这一步，只需要重启 <code>OpenWRT</code> 即可成功扩容。到 系统 -&gt; 软件包 可以看到空间变大后的容量。</p>
<h2 id="自动挂载">自动挂载</h2>
<p>默认情况下分区再重启后会自动挂载，如果遇到没有挂载的情况，需要编辑 <code>/etc/rc.local</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ vim /etc/rc.local
</code></pre></td></tr></table>
</div>
</div><p>在 <code>exit 0</code> 之前加入一行 <code>mount /dev/sda3 /overlay</code> 即可。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://blog.msm.moe/mount-sd-card-to-overlay-on-openwrt/" target="_blank" rel="noopener noreffer">OpenWrt 下把 SD 卡挂载到 /overlay ，扩大软件空间</a></p>
</li>
<li>
<p>[2] <a href="https://www.jianshu.com/p/8179b19cfa6d" target="_blank" rel="noopener noreffer">软路由 LEDE 折腾 overlay 分区扩容之路</a></p>
</li>
<li>
<p>[3] <a href="https://www.vediotalk.com/archives/13889" target="_blank" rel="noopener noreffer">ESXI 下 OpenWrt 扩容 Overlay,增加安装插件空间</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>单独编译 OpenWRT ipk 插件</title>
    <link>https://www.techkoala.top/openwrt_compile_single_ipk/</link>
    <pubDate>Fri, 09 Oct 2020 15:57:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/openwrt_compile_single_ipk/</guid>
    <description><![CDATA[<blockquote>
<p>为 OpenWRT 编译单独的 ipk 插件</p>
</blockquote>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">必须先完整编译一次固件才能单独编译 ipk</div>
        </div>
    </div>
<p>当需要单独更新 OpenWRT 某个插件或者需要增加安装某个插件的时候，可以单独编译对应的 ipk 插件进行安装，而不必编译整个系统。</p>
<h3 id="下载源码">下载源码</h3>
<p>使用 <code>git clone</code> 对应的源码插件到下面的文件夹中</p>
<h3 id="存放路径">存放路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/package
</code></pre></td></tr></table>
</div>
</div><h3 id="配置">配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make menuconfig
</code></pre></td></tr></table>
</div>
</div><p>然后进入对应的子菜单中找到对应插件按 <M> 表示选中插件，但不编译进固件。</p>
<h3 id="编译">编译</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">make package/xxxxx/compile <span class="nv">V</span><span class="o">=</span><span class="m">99</span>
</code></pre></td></tr></table>
</div>
</div><p>xxxxx 就是你需要单独编译的程序。</p>
<h3 id="ipk-生成路径">ipk 生成路径</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">~/lede/bin/packages/x86_64/xxxx
</code></pre></td></tr></table>
</div>
</div><h3 id="上传-ipk-至路由器">上传 ipk 至路由器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">scp xxxxxxx.ipk root@192.168.1.1:/tmp
</code></pre></td></tr></table>
</div>
</div><h3 id="安装">安装</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">opkg install /tmp/xxxxx.ipk
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>5G 将是一个彻底的失败</title>
    <link>https://www.techkoala.top/5g_will_be_a_complete_failure/</link>
    <pubDate>Sat, 03 Oct 2020 00:17:12 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/5g_will_be_a_complete_failure/</guid>
    <description><![CDATA[<blockquote>
<p>为什么说 5G 将是一个彻底的失败？</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：杨学志</p>
<p>链接：https://www.txrjy.com/thread-1061715-1-1.html</p>
<p>来源：通信人家园</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="无线通信产业发展史">无线通信产业发展史</h2>
<p>无线通信产业已经发展了四代，目前正处于 5G 产业化前夕，是当下到一个最热的话题，5G 如何发展，前景如何，是各个方面包括学术界、产业界、投资界以及政府都非常关心的。另外，中国已经启动 6G 研究的消息也见诸报端，未来无线通信产业如何发展，是不是会继续有 6、7、8、9G，也引起了大家的关切。为了回答这些问题，我们首先简单地回顾一下无线通信产业发展的历史。</p>
<p>无线通信产业是由<strong>需求</strong>和<strong>技术</strong>两个轮子驱动前进的。</p>
<p>早在 1947 年，贝尔实验室的科学家就提出了蜂窝通信的概念，其中的核心技术是频率复用和切换。基于这一概念，贝尔实验室于 1978 年研制出<code>先进移动电话系统</code>（Advanced Mobile Phone Service，AMPS），这就是第一代移动通信系统。<code>AMPS</code> 是一个模拟通信系统，采用<code>频分多址</code>（FDMA）的复用技术，主要技术手段是滤波器，容易受噪声的干扰，语音质量较差。</p>
<p>随着集成电路技术的发展，第二代移动通信系统采用了数字技术，并采用 <code>TDMA</code> 和信道编码技术，使得通信系统向宽带化发展，语音质量得到了较大的改善。其中欧洲制定的 <code>GSM</code> 系统非常成功，至今仍在广泛使用。</p>
<p>20 世纪 90 年代互联网蓬勃发展，顺应这一时代要求，产业界制订了 3G 标准用以实现移动互联网。3G 采用了高通公司开发的 <code>CDMA</code> 技术。<code>CDMA</code> 一度被认为是一个神奇的技术，高通公司宣称 <code>CDMA</code> 的频谱效率可以达到 AMPS 的 18 倍，但是实践表明这个观点太过于浮夸了，<code>CDMA</code> 存在自干扰问题，其频谱效率只比 <code>GSM</code> 高 10%左右，并且 3G 的主流标准 <code>WCDMA</code> 的系统设计过于复杂，导致部署成本比较高，所以一直无法替代 <code>GSM</code> 系统。</p>
<p>第四代移动通信采用了 <code>OFDM</code> 技术，从根本上克服了 <code>CDMA</code> 的技术缺陷，并且简化了系统设计，成就了一代成功的移动通信系统。<code>OFDM</code> 如何克服 <code>CDMA</code> 的缺陷，具体可以参考我的《通信之道-从微积分到 5G》。</p>
<p>如果我们稍微总结一下，可以发现，1G 发掘出了移动通信的巨大需求，但是采用了比较落后的技术体制，因此长不大。2G 进行了数字化革命，从而获得巨大成功。3G 是为了新出现的移动互联网需求而诞生，但是在技术上走了弯路，全球的 3G 业务都不是太成功；而 4G 回归了正确的技术路线，目前 4G 业务蓬勃发展。</p>
<p>随着 4G 的成功商用，按照无线通信十年一代的发展规律，产业界开始了 5G 的研发。按照业界目前的一般口径，5G 在 2020 年左右开始规模商用。中国政府已经为 5G 分配了 500MHz 的频谱，三大运营商也已经在多个城市开展了商用实验，商用前的准备工作正在紧锣密鼓地进行。 很多人认为 5G 牌照会在年内（2019）发放。</p>
<p>对于 5G 的讨论，也要从技术和需求两条线来讨论。</p>
<h2 id="无线通信技术体制">无线通信技术体制</h2>
<p>无线通信产业基本上可以用“端管云”三个字进行概括。 端就是终端，包括电脑， PAD，手机等。云就是存储在网络上的内容，如新浪、百度、淘宝的数据中心，而管就是连接终端和云之间的这条通道。</p>
<h3 id="端管云">端管云</h3>
<p>这条管道可以分为两段。一段是终端到基站（或者路由器），这段是无线通信，也叫空中接口；另一段是基站到云，是有线通信。云都是挂在因特网上的，因此因特网是这条管道当中必经之路。移动通信有核心网，基站首先挂在核心网上，再连接到因特网。核心网主要是起运营支撑作用，比如身份的识别，计费等等。而另一个体系是大家都熟悉的 <code>WiFi</code>，没有核心网，路由器是直接戳到因特网的。这就构成了两大生态体系，也就是传说中的 <code>CT</code> 和 <code>IT</code>，它们之间的合作与竞争将贯穿无线通信产业的走向。</p>
<p>在无线通信产业当中，空中接口这一段的产值，包括终端和基站，占绝大部分。如果做一个类比，通信网络可以类比人体的循环系统或这神经系统。骨干网的部分可以类比中枢神经或者主动脉，虽然容量很大，但是只有几条。骨干网络的销售额不大，但是占据战略制高点；而空中接口部分相当于神经末梢或者毛细血管，数量庞大，占据无线通信产业的主要市场份额。</p>
<p>有线网络现在都光纤化了。光纤的发明是基于高锟的理论，他因此获得诺贝尔奖。光纤的容量大，成本低，彻底改变了人类通信的面貌。最早的光纤线路的速率只有 45Mbps，后来以令人乍舌的速度发展，目前一根光纤已经可以达到 1Tbps。而光纤要比同等长度面条便宜，这是真正的高科技。早期光纤只用于骨干线路（比如北京和上海之间），随着成本的降低，目前光纤已经入户了。 由于光纤的存在，有线网络的主要工作在于怎么组织和利用光纤的容量，如 <code>IPV6</code>，<code>SDN</code> 等等，基本上是逻辑性的工作，总体来说是比较简单的。</p>
<p>空中接口部分就比有线网困难多了。在有线通信当中，信号在一个精心制造的介质里面传播，无论是铜线还是光纤，信号质量非常好，随便搞搞就能达到很高的速率。而无线信号的传播环境就恶劣得多得多。无线电波在传播过程中衰减很快，还受到建筑物、山体、树木的阻挡，很多时候需要经过反射或者穿透障碍物才能达到接收机。并且，无线电波不是规规矩矩地沿着规定的路线走，会走到不希望的地方，造成对他人的干扰。但是无线通信有一个好处，就是摆脱了线的束缚，可以拿着手机随便走，这种便利性是有线通信所无法比拟的。所以尽管挑战很大，无数的研究者前仆后继，攻克无线通信当中的道道难关。</p>
<h3 id="网络分层协议">网络分层协议</h3>
<p>刚才说的这些事，背后是网络的分层结构。最底下的一层叫物理层，其他的可以和合并起来叫高层。物理层是处理物理信号的，比如电或者是光，就是如何把信息转换成可以用来传输的电信号或者光信号。物理层解决的是通信能力的问题，或者是带宽的问题。有了这么多的带宽之后，怎么组织和利用是高层要做的事。</p>
<p>这个和邮政系统非常类似。物理层相当于运送信件或者包裹的方式，可以是马车，汽车、轮船、飞机，这提供了运送的能力。但是寄信的时候，我们要在信封上写通信地址，要跑到邮局交给柜台，后然分拣打包装车，到了目的地后要有邮递员送到收信地址，这些都是高层做的事情。</p>
<p>所以大家能看出来，通信网络的核心技术在物理层。当然高层也必不可少，但相对来说可以变化的空间不大。 如果说我们的邮政系统比以前先进，主要不是体现在邮局的布置上，而是运输方式的改进，以前是马车，现在改飞机了。虽说邮局也进步了，比如装了玻璃柜台，或者信件实现了机器分拣，但不是主要的因素。</p>
<p>光纤是现代通信网络的最重要的基石，就是物理层技术。高层技术当中大家最熟悉的是 <code>IP</code> 协议。<code>IPV4</code> 获得广泛应用后，虽说存在一些问题，试图通过 <code>IPV6</code> 去解决。但是 <code>IPV6</code> 经过二三十年也没有取代 <code>IPV4</code>，就是因为高层技术相对简单，改进的空间不大。</p>
<h2 id="无线通信技术演进">无线通信技术演进</h2>
<p>同样，空中接口的核心技术也在物理层，每一代移动通信是由这些核心技术所定义的。这些核心技术，也就是《通信原理》课程里面的知识。</p>
<h3 id="3g-核心技术">3G 核心技术</h3>
<p>空中接口的核心技术可以分为 5 个大类，分别是<code>调制</code>、<code>编码</code>、<code>多址</code>、<code>组网</code>和<code>多天线</code>。比核心技术更基础的是基础理论，包括电磁理论和信息论。</p>
<p>大家都知道，高通公司开发了 <code>CDMA</code> 技术，并且成为 3G 三大标准（ <code>WCDMA</code>，<code>CDMA</code>2000 和 <code>TD-SCDMA</code>）的核心技术，从而一跃成为芯片业巨头。 上图所示的是 <code>WCDMA</code> 的核心技术。高通的贡献主要在多址和组网两个领域。</p>
<p>虽然普遍认为高通开发了 <code>CDMA</code> 技术，但是 <code>CDMA</code> 并不是高通发明的，发明人是好莱坞艳星海蒂.拉玛。<code>CDMA</code> 技术的标准接收机叫 <code>Rake 接收机</code>，也于 1950 年代由贝尔实验室发明。实际上由于当时普遍认为 <code>CDMA</code> 的保密性好，一直应用于军事通信。而高通解决的是 <code>CDMA</code> 的民用问题，这在当时是普遍不被看好的。</p>
<p>高通解决 <code>CDMA</code> 民用有三招，分别是<code>功率控制</code>（Power Ctrl）、<code>同频复用</code>（UFR）和<code>软切换</code>。功率控制解决远近效应，同频复用提升频谱效率，软切换解决切换连续性。这构成了高通 <code>CDMA</code> 的技术体系。 这里只简要介绍一下，技术人员可以参考我的书《通信之道》。因为 UFR 并不是专利，所以高通其实在 <code>CDMA</code> 上就两个核心专利，其中软切换专利获得美国专利局的授权还载入了高通发展史。</p>
<ul>
<li>
<p>3G 在编码领域的主要进展是采用了 <code>Turbo</code> 码，这是法国电信所资助的教授发明的，是通信发展史上的里程碑，因为它首次充分逼近了香农在 1948 年所提出的信道容量。</p>
</li>
<li>
<p>在多天线领域，<code>Alamouti 编码</code>应用到了广播信道多编码。因为广播信道在整个业务当中的比重并不大，所以这个编码的作用相对重要性低一些。但是这个编码是多天线技术领域的里程碑，有非常大的影响力。</p>
</li>
<li>
<p>调制是最基础的通信技术，没有之一。因为基础，所以稳定，一直到现在的 5G 都没有太大的变化。</p>
</li>
</ul>
<p>可以看出，高通在 3G 的多址和组网两个方面拥有核心技术。当然，在把核心技术工程化的过程当中也建立起由几千个专利组成的专利组合。凭着这些专利和芯片的联合运作，收取了大量的高通税。</p>
<p>其实从现在的眼光看，<code>Turbo</code> 码和 <code>Alamouti 码</code>是更重要的核心技术。但这两个核心技术在法国电信和 <code>ATT</code> 这样的大公司里面，没有进行商业化运作的机制，只是收了一些专利费，没有形成象高通这么大的商业。</p>
<h3 id="4g-核心技术">4G 核心技术</h3>
<p>到了 4G 之后，<code>CDMA</code> 技术被 <code>OFDM</code> 技术所取代。主要的原因是 <code>CDMA</code> 存在自干扰的问题。高通的功率控制和软切换试图去解决这个问题，但采取的方法是在 <code>CDMA</code> 缺陷的基础上进行补救，但是怎么补也补不彻底。</p>
<p>而 <code>OFDM</code> 从根本上克服了 <code>CDMA</code> 自干扰的缺陷，使得频谱效率得到了很大的提高，那这些补救措施也就没必要了。 所以在 4G 时代，高通的技术体系被摧毁了。 采用 <code>OFDM</code> 技术带来了新的问题，解决这些问题导致了三个创新的出现，这就是我在华为提出的 <code>sOFDM</code> 和软频率复用（SFR）以及爱立信提出的 <code>SC-FDMA</code> 技术。 我在华为还提出了随机波束赋形（random beam forming）技术，解决了非常火热的循环延时分集（Cyclic Delay Diversity）的严重缺陷。 在调制和编码领域仍然采用了 3G 的方案。</p>
<p>可以看出，华为在 4G 的核心技术上已经取代了高通。但是很可惜，由于华为公司的跟随基因，无法发挥手上的专利核武的威力，还要向高通交钱，也只是向苹果收了点小钱。但是华为因此避免了专利核武打击，加上华为在产品上的优势，所以华为日子过得很好，在 4G 时代成为第一大设备制造商。</p>
<h3 id="5g-核心技术">5G 核心技术</h3>
<p>5G 标准已经制定完成了，盖棺定论后已经可以看得很清楚了。</p>
<p>首先调制这块还是没有变，太基础了，想变也变不动。</p>
<p>因为联想投票门的事情，编码这块的故事很多人都知道。相比于 3G/4G 采用的 <code>Turbo</code> 码，5G 采用了 <code>LDPC</code> 和 <code>Polar</code> 码。 这两个码都是鼎鼎大名，是 <code>Turbo</code> 码之后通信技术发展的里程碑性的技术。 但是由于 <code>Turbo</code> 码已经比较接近香农限，虽然这两个码更接近，但是对系统容量的提升已经不大，大概是 1 ～ 2%左右。</p>
<p>多址这块，对于 5G 三大场景之一的 <code>eMBB</code> 这块没有变，还是采用了 <code>OFDM</code>。其中爱立信提出的 <code>SC-FDMA</code> 从 4G 的必选项变成了可选项，这是因为它相对于 <code>OFDM</code>A 并没有什么技术优势。</p>
<p>多址这块 <code>NOMA</code> 有很大的热度，一度被公认为 5G 的必选技术。5G 标准的早期，几乎所有的厂家都支持这个方向。 但是经过我的论证，<code>NOMA</code> 比 <code>OFDM</code> 的增益严格为零，这是用信息论严格证明的。 所以 <code>NOMA</code> 既复杂又没增益，属于技术退步。</p>
<p>另外华为还推了 <code>F-OFDM</code>，与 <code>sOFDM</code> 正好相反。<code>sOFDM</code> 的思想是所有的带宽所有的环境都用统一的参数，从而获得规模经济效应。<code>F-OFDM</code> 强调对不同的环境采用不同参数从而更好的适应环境。 这种做法并没有什么增益，反而丢失了规模效应这个大西瓜，也属于技术退步。</p>
<p>组网方面没有听到什么消息，工作假设应该还是同频复用。<code>SFR</code> 和 <code>CoMP</code> 都是组网方案。<code>SFR</code> 非常简单，不需要标准化。<code>CoMP</code> 虽然一度被认为是更先进的技术，但经历了轰轰烈烈的标准工作和产品开发之后，已经是失败了。</p>
<p>多天线这块最响亮的就是 <code>massive MIMO</code>，号称可以成百倍地提升系统容量，从媒体上看几乎可以是 5G 的代名词。 <code>MIMO</code> 这个理论 1995 年提出，已经 23 年了。它所揭示的对容量的巨大提升致使它一直是学界和工业界的热点。但是这个技术一直到 4G 都不是很成功。这个技术有个特点，一演示就成功，一实用就趴窝。记得 20 年前我还是小白的时候，在电信展上就看到厂家演示空分复用，用相同的时频资源实现两个用户的同时通信，还互不干扰。在一个选择的场景下 <code>MIMO</code> 技术是很容易演示成功的，但是在复杂的实际环境中所涉及的问题的难度，是两个数量级的差别。当然 <code>MIMO</code> 是一个有潜力的领域，但是其实用化问题仍然没有解决。</p>
<p><code>MIMO</code> 的问题还在于，虽然能够提高容量，但是要增加设备，有成本的。其实 <code>MIMO</code> 最朴素的应用就是古老的三扇区天线，一个全向小区分割成三个扇区，容量在理论上增加了三倍，这就是 <code>MIMO</code> 的原理，虽然说是古板了一点。所以粗暴一点，搞个 9 扇区，12 扇区，也就是 <code>mMIMO</code> 了，这个华为已经有产品了。这和是不是 5G 没关系。</p>
<p>综合来看，5G 相对于 4G 来说，几乎没有技术进步，在一些地方还退步了。比如说 <code>NOMA</code>，<code>F-OFDM</code>，还有为了保证短时延而采用的自包含结构。</p>
<p>还有，5G 采用了更高的频谱。在中国是 3.5GHz，还好一点。美国用了 28GHz。频率越高覆盖越小，这是无线通信的基本知识。所以同样的网络覆盖，比起 4G 的 2.6GHz，3.5GHz 的投资要高出 50%（我也是看来的，看起来合理），而 28GHz 实现覆盖就是开玩笑了，花 5 倍的银子也是正常的。
所以从技术角度看，5G 比 4G 没有进步，成本会更高。</p>
<h2 id="5g-需求">5G 需求</h2>
<p>5G 的需求，大概可以用高速率、低延迟、大连接来概括。</p>
<p>大家知道，4G 设计当初的速率目标是 100Mbps，随着技术的演进，4G Cat 11 的速率已经达到 600Mbps。5G 进一步把速率目标提高到 1Gbps 以上。为了满足一些低延迟业务的需求，5G 要求空中接口的延迟时间为 1ms，而 4G 的这一指标为 30ms 左右。4G 主要是为移动互联网设计的，强调的是人与网络之间的高速连接，而同时连接到网络的终端的数量并不是一个需要特别考虑的问题。而在蓬勃发展的物联网时代，每一件物体都有可能有联网要求，因此连接数量会有数量级的增加，5G 需要具有支持海量连接的能力。</p>
<p>5G 最抓眼球的就是它的速率。看新闻经常是比光纤还快，一秒下一个大片，快到把人脸吹成骷髅，等等。
但是有什么样的业务需要这样的速率呢？</p>
<p>虽然暂时想不出，但是有一个非常流行的观点是，先修好路，自然会有车。3G、4G 都是这样，微博、微信、抖音什么的，以前根本就想不到。等 4G 来了之后，这些应用也就有了。</p>
<p>很显然，这个观点首先在逻辑上就有很大的问题。修好了路没有车也很正常啊，你就没见过没人走的路吗？ 按照 3G、4G 的情况去推断 5G，这个也不靠谱。就像你已经活了 80 岁，不能按此推断你还能再活 80 岁。2G 和 3G 都处于带宽短缺的时代，所以形成了修好路必有车的错觉。然而到了 4G 之后，带宽已经不再短缺了。</p>
<p>还有一个流行的观点是，科技发展往往超出人的想象力，所以保守的预测往往是错误的。比如比尔盖茨当年说，计算机 640k 内存应该是够了。而现在已经是 640G 了，6 个数量级的增长。</p>
<p>必须认识到，通信和计算机有很大的不同。</p>
<p>计算机所涉及的所有零部件，<code>CPU</code>，内存，硬盘，都有一个共同的源泉就是半导体工艺。半导体集成度在近十年提高了 1000 倍，大家共同水涨船高。但是通信不一样。通信需要一个受体，以目前最广泛的 <code>eMBB</code> 为例，这个受体就是人。人是肉长的而不是沙子做的，它能够处理的最大信息速率，也就是带宽，是固定的，超过了人的带宽是没有意义的。</p>
<p>通俗一点说，我在 <code>PAD</code> 上看片，我一般看缺省的高清格式，尽管有超清格式，我一般不会主动选择。为啥？ 因为我的老花眼看不出二者的区别。当然眼睛好的人还是应该能分出来的。高清视频也就是 1 ～ 2Mbps 的速率，目前的 <code>WiFi</code>，4G 都远远地超出了我的需求。</p>
<p>当然，有人会反对。比如目前 4K/8K 视频很火热，有朋友跟我说，看了 4K 视频之后，其他的都没法看了。我天天看高清格式视频，倒是没这种感觉了。当然对于 60 寸的大电视，提高分辨率还是有必要的。但是电影院的屏幕，目前还只是 2K，我认为 4K/8K 更多的是心理上的。用户挑电视的时候会靠在跟前看屏幕上的一小块区域，一个像素一个像素地检查，4K/8K 当然要好。如果在正常观看距离上，比如 2 米，4K 和 2K 会有明显区别吗？我没试验过啊，有兴趣的朋友可以做一下双盲实验。</p>
<p>即使是 4K 视频，速率也只有 30Mbps，4G 支持也不费力啊，怎么会有 1Gbps 的需求呢？这就要说到虚拟现实 <code>VR</code> 了。 <code>VR</code> 要求有沉浸式的体验。啥叫沉浸式？在真实的场景当中，如果我们慢慢地转头，看到的景物也就连续地变化，这就是沉浸的意思。VR 要实现这种效果，不光要传给你正在看的东西，没看的东西也要传给你，转头的时候要现传新视角上的数据来不及，会出现卡顿，就不是沉浸式体验了。这样一来，数据量再增加 30 倍，差不多就到 1G 了。5G 的 1G 速率的需求就是这么来的。</p>
<p><code>VR</code> 作为一种创新的视频形式，相信能够获得一定的应用。VR 的麻烦在于需要一个专门的头盔，哪怕是手机盒做的简易型的，都是不方便携带的。这么一来 <code>VR</code> 一般发生在室内，而且一般是专门用途的场景，比如房地产或者旅游景点的体验店什么的。这些业务一般不会走移动通信，更多的是 <code>WiFi</code> 或者专线。</p>
<p>总是有很多朋友寄希望于未来可能出现的未知业务。虽然具体的业务会层出不穷，我们确实无法预测，但是只要最终的受体是人，人感受信息的通道就是眼睛和耳朵，鼻子舌头皮肤还都用不上，人类进化出新的感觉器官最少也得是 100 万年以后的事情。人眼的带宽就确定了通信的最大速率，这是一个物理瓶颈，不管什么应用出现都是无法突破的。</p>
<p>从现实的情况看，<code>WiFi</code> 的速率总是领先移动网的，即使 <code>WiFi</code> 已经提供给我们 100M 的带宽了，但是我门最多应用的速率还是 1～2M，超出 10M 以上的应用非常少，也只有下载软件的时候有时会达到。所以其实 4G 的速率已经超出需求了，5G 的高速率完全是没必要的。</p>
<p>人的感官能力对时延同样是一个决定因素。</p>
<p>时延当然越短越好，没有人会不喜欢短时延，但是信息论的基本原理决定了短时延会造成高成本。信道编码依靠的是大数定律实现可靠通信，要达到信道容量，理论上需要无穷的时延。因此这个固有原理因素就决定了时延不能非常短。这里就不说其他的处理时延、排队时延和反馈时延了。非要实现低时延也有方法，就是把效率降低，用很高的信噪比去实现很低的速率。这个成本就太高了。任总一直在说，大速率、低时延的通信技术还没有实现。其实根本就不存在这样的技术。</p>
<p>要知道人的感官时延大概是 100 毫秒左右，所以 4G 几十毫秒的时延是比较合适的，1ms 的时延对人没有意义。所以，只要有人参与的应用，就不需要低时延。比如常用的微博微信，甚至是很多人认为需要低时延的手机游戏，在 <code>WiFi</code> 上不都玩得挺好吗。</p>
<p>自动驾驶是被广泛误解为需要低时延的应用。你可以经常看到有文章说，低时延使得刹车距离更短，从而更安全。但是这要基于一个假设，就是刹车指令是通过 5G 网络从远程控制中心传送给汽车的。 显然实际的解决方案不是这样。象刹车这种对时延和可靠性要求都非常高的指令，只能由车在本地产生，采用尽量短的回路。依靠网络传输的，是路线规划和路况信息这样的对可靠性和时延没有特殊要求的信息。Google 汽车已经跑了几百万公里了，并不需要一个低时延的网络。甚至没有网络的时候，汽车也应该能跑，这是起码的要求。</p>
<p>基于同样的原因，象无人工厂这些工业应用也无法通过 5G 网络实现。5G 是一个公共网络，对经济性的要求决定了它无法达到工业级的可靠性。不是说技术上做不到工业级的可靠性，而是能做到也不做，太贵了公众用不起。所有的工业应用必须用专线。远程手术也是同样的道理。</p>
<p>对于这个话题，你经常会看到一个很高大上的技术叫<code>网络切片</code>，意思是在 5G 网络上切出一个高可靠性的通道出来，用来满足工业应用。但是这实际是不可能做到的。一个系统的可靠性取决于最薄弱的一环。如果 5G 网络采用统一的硬件设施，如果不想多花钱，就已经决定了这是一个民用级别的可靠性，是不可能在软件上做点工作使之达到工业级的可靠性。就像特朗普车队，要清道、设岗，要有探路车、开道车、救护车、通信车、陆军一号这些硬东西，要花大把的银子。单靠在大街上挂几个标志是无法保证总统安全的。</p>
<p>虽然低时延高可靠性（uRLLC）是 5G 定义的三大场景之一，但是这与 5G 作为一个公共网络的基本特征相矛盾，是绝无可能实现的。</p>
<p>刚才所说的自动驾驶和无人工厂，属于物联网的例子。接下来我们聊聊普遍意义的物联网。</p>
<p>有句非常有名的话，叫做<code>4G 改变生活，5G 改变社会</code>，说的就是物联网。5G 使我们的社会从互联网发展到万物互联的社会。</p>
<p>虽然普遍认为目前处于物联网爆发的前夕，但是有个问题，物联网未必是移动通信的菜。</p>
<p>移动通信是怎么来的呢？起初就是人要打电话，要到处跑，不光在本地跑，还要出差，还要出国。这个特点要求移动需要统一标准，全球统一。所以要有个叫 <code>3GPP</code> 的组织，几百个公司的人一起制定这个标准，扯来扯去效率是很低的。还要搞个核心网去支持运营，运营商还要养着一大票的运维人员，这些特点就决定了移动通信会比较贵。</p>
<p>所以说，除非移动，不然没有必要用移动通信。 这样移动通信的客户群就很明确，一是人，二是车，另外还有野生动物。所以 <code>eMBB</code>，车联网，野外科学考察等等，是移动通信的正经业务。</p>
<p>但是大多数东西是不动的。 在 <code>WiFi</code> 已经普及的情况下，很大的一块业务会被 <code>WiFi</code> 分流，比如智能家居。并且 <code>eMBB</code> 是 2C 的，而物联网多数是 2B 的，象油田，电力公司这些大企业更倾向于自建网络，就不用向运营商交月租了。以 <code>NB-IoT</code> 为例，一个链接每年 20 块的资费对很多应用是很大的一个负担。这就有了象 <code>Lora</code> 这样的系统的生存空间，成本比 5G 低得多。</p>
<p>所以，从 5G 的三大需求看，高速率和低时延的需求都是不存在的，物联网只有小部分落入 5G 的范围。</p>
<h2 id="移动通信与-wifi">移动通信与 WiFi</h2>
<p>5G 与 <code>WiFi</code> 的关系是无法回避的问题，这其实是本文开始就提到了 <code>CT</code> 与 <code>IT</code> 两大生态体系的关系问题。</p>
<p>首先有一个每个人都能感觉到的事实，<code>WiFi</code> 承载了 80%的流量，我们却不会为它付一分钱，而会为只承载 20% 流量的 4G 付月租。这是为什么？</p>
<p>在信息社会，手机是我们与社会连接的通道。当我们习惯了这种连接之后，丢失连接后就会感到恐慌。 很多人一有机会就查一下微信，微博，电邮，股票，彩票，生怕遗漏了重大机会，或者没能及时回复。 也就是说，随时随地与社会连接，是我们的刚需。 要满足这种刚需，需要一个广覆盖的网络，这正是移动通信的目标和功能。</p>
<p>在 <code>WiFi</code> 火热的时候，有些城市试图建设 <code>WiFi</code> 城市，用 <code>WiFi</code> 来实现覆盖，但是最终都失败了。 因为 <code>WiFi</code> 是由 IT 界设计的，生来就缺乏实现广覆盖的能力。这表现在技术方案上，就不在这里细说了。 后来 IT 界把 <code>WiFi</code> 升级到 <code>WiMax</code>，试图与 CT 竞争，但是 IT 界的基因还是导致了 <code>WiMax</code> 的失败，并且导致北电破产。</p>
<p>由于 <code>WiFi</code> 无法实现广覆盖，它被定义为固网的延伸，已经成功渗透到了多数的家庭、酒店和办公室， 目前 <code>WiFi</code> 的实测速率已经达到 300～400Mbps。 <code>WiFi</code> 提供的是特定地点的高速率通信。路由器很便宜，二百块钱一个，用户自己买一个回来自己就能搞定，想把这些路由器集中控制起来收月租显然是不可行的。</p>
<p><code>IT</code> 与 <code>CT</code> 都试图入侵对方领地。早几年的 <code>WiMax</code> 就是 <code>IT</code> 入侵 <code>CT</code> 的一次失败的尝试。 这几年，也经常听到各种消息，一会儿是小扎，一会儿是马斯克，都要建全球免费 <code>WiFi</code>，周鸿祎说他掌管中国移动，就全免费。当然都没能成功。移动通信所要求的统一标准、广域覆盖，网归网优，客户管理，都决定了运营商是一个分层的官僚体系，与互联网基因格格不入。中国移动每年营收 8000 亿，够买 6 个 360 了，说免就免了，从哪能捞回来这么些钱？用户愿意交这个钱，非不收，那叫啥呢？</p>
<p>反过来，移动通信能取代 <code>WiFi</code> 吗。<code>WiFi</code> 覆盖小，高速率，成本低，使用非许可频段，决定了其免费的必然性。移动通信要取代 <code>WiFi</code>，也必须达到如此低的成本，并且实现免费。这是否能做到呢？如果 4G 能够利用已有的规模优势，做低成本的 <code>Femto 基站</code>，理论上有可能。但是市场规模太小，菊花大厂看不上眼，现有的管理体制也不能适应。而小厂很难有这个技术能力。所以说也是比较难的。</p>
<p>所以说，移动通信和 <code>WiFi</code> 有各自的应用场景。移动通信能够实现 anytime，anywhere 的连接，能够满足用户的刚需，而 <code>WiFi</code> 便宜，无月租，满足用户高速率的应用需求，将长期共存。</p>
<h2 id="5g-之局">5G 之局</h2>
<p>移动通信经过四代的发展之后，人们得到一个似乎的规律，就是单数代不太成功，而偶数代很成功。经过我们的分析后发现，1G 和 3G，都是新的需求促成的，但是技术不太好，而 2G 和 4G 在原有的需求基础上，改进了技术，从而很成功。1G 和 3G 虽然不太成功，但也不能说是失败，毕竟他们是满足新需求的唯一技术。 但是到了 5G，需求是虚构的，技术上并没有进步，所以必然是要失败的。</p>
<p>5G 是目前最火热的话题。特别是孟晚舟事件之后，美帝组团打压华为，国人已经把 5G 看成是中美对决的战场。</p>
<p>对于 5G 的立场，任总曾经发表过一个讲话，说 5G 的需求并没有出现。我心里赞叹任总真是到了从心所欲不逾矩的境界，也不为利益所左右。后来徐直军也发表了对 5G 相对保守的观点。但是后来口风变了，任总为自己的讲话向产品线道了歉。后来华为发文表示要坚决打胜 5G 这一仗。</p>
<p>我们已经知道，移动通信的根本的价值在于实现任何时间，任何地点的连接能力，在此基础上提高网络容量。如果没有覆盖这个前提，只是在局部实现高速率是没有商业价值的。比如说大家一直谈论的可见光通信，因为覆盖小只能服务两三个人，速率太高超过了人的带宽，就没有意义了。 这个问题对毫米波、太赫兹都是如此。
虽然过高的速率没够意义，但是随着用户渗透率的提高，资费的下降，数据量每年增长 30%的情况还会持续很多年。因此移动网络还需要扩容。</p>
<p>移动通信正确对发展方向是，保证连续覆盖的情况下以低成本提高网络容量。当然，并不是我一个人才知道这是正确的方向，实际上这是通信界的常识，2G 和 4G 的成功就是这种模式。</p>
<p>5G 偏离了这种模式，走向了错误的方向。这背后的原因有三个：</p>
<ul>
<li>通信原理的创新遇到瓶颈</li>
<li>半导体工艺获得了爆炸性的发展</li>
<li>无线产业决策链条太长</li>
</ul>
<p>通信技术已经发展百年，因为其战略地位和创造财富的能力，全球最强智力投入其中，但凡简单一点的创新早就发掘完了。用于 <code>Turbo</code> 码解码的 <code>BCJR 算法</code>是 1970 年代发明的，在我历经艰辛终于看懂之后，感叹道，这只能与魔鬼做交易才能搞得出来。 到 2009 年的时候，随着 <code>Turbo</code>，<code>LDPC</code>，<code>Polar</code>，<code>OFDM</code>，<code>MIMO</code> 等领域的进展并且逼近理论极限，学术界普遍感觉到物理层已经死了，再也无法创新了。象 David Tse 这样的被公认为传承香农衣钵的大咖，也感觉无处可走，转行做生物信息去了。</p>
<p>在此同时，半导体技术得到了爆炸性的发展。大家手上的 U 盘，从 10 年前 128M 变成了现在的 128G。在通信原理无法获得突破的情况下，自然地走上利用强大的算力实现高速率的方向。 高算力使得采用更宽的频带，更多的天线成为可能，在通信原理不变的情况下，通过算力使得速率暴力提升 1000 倍是很简单的事情。华为早就整出来 115Gbps 的样机了。看报道我国启动了 6G 研究，速度比 5G 高 10 倍，看得我真是很无奈。</p>
<p>移动通信产业有着与其他产业不同的特点。一般的产业都是研发产品上市，获得反馈并逐步改进，是一个快速迭代的过程。 而移动通信要求在什么还没有之前，大家共同商定一个标准，然后按照这个标准做产品。 何时启动一代通信标准是战略决策，是由政治领导人和商业领导人来做出的。他们当然会咨询技术专家，但是专家们也未必懂，其中还有巨大的利益博弈，显然并不靠谱。行业认同的宏观规律是十年一代。时间一到，各方力量合力推动，就动手干了。大炮一响，黄金万两。即使实际上不能干，也得创造条件干。所以我们看到 5G 出现了很多奇葩的技术，如全双工，毫米波，现在可见光，太赫兹也要上场了。<code>NOMA</code> 和 <code>F-OFDM</code> 比较起来都算是好的。</p>
<p>一代移动通信标准一旦启动，到产品上市之前，所有的玩家都投入了巨大的成本。鉴于通信产业的战略地位，政府意志也为之背书。大家都绑在这个战车上，即使有问题，在碰到南墙之前是不会停下来的。</p>
<p>所以 5G 的问题，不光是华为的问题，或者是中国的问题，美国、欧洲也都是如此。很多网友看到美帝在 5G 上整华为，就觉得美帝反对的东西肯定很重要。中国长期以来落后，都以美国为灯塔。但是经过改开 40 年，中国国力日渐强盛。而通信产业整体上已经获得了领先地位。在这种竞争格局下，即使美帝也会犯错。什么铱星啊，<code>Wimax</code> 啊，不都是美帝整的吗？ 所以我们要有独立的判断，而不是被对方的判断左右。 随着商用的日益迫近，5G 的问题会逐渐暴露出来。比如最近 <code>ATT</code> 的 5G 造假，韩国 5G 被指无用，澳洲未能按计划推出 5G 服务，等等。希望本文能为各方提个醒，尽量减少损失吧。</p>
<p>因为任总的讲话，我认为华为对 5G 是有清醒的认识的，任总最新的讲话又谈到了 5G 的需求没有出现。5G 成功当然好，又能成为华为的产粮田，况且在舆论上华为 5G 已经领先友商 12 个月。但 5G 失败对华为也是有利的。因为华为有着最齐全的产品线，是行业老大，没有技术创新也就意味着现有格局的固化，华为也就能笑到最后了。当然裁员是避免不了的，这对于通信狗们来说不是个好消息。 对于二线的设备商，却是灾难性的，对 5G 的投入无法回收，现有市场份额也会被华为逐渐蚕食。 对于高通更是灭顶之灾，3G 专利过期，4G 没专利，然后 5G 没有了，怎么收专利费？早些年嫌设备和手机不赚钱甩给别人了，现在有点傻眼。趁手上还有点银子，想收个恩智浦，也被贸易战给搅黄了。这日子怕是过不下去了。</p>
<h2 id="未来之路">未来之路</h2>
<p>前面已经讲到，移动通信的发展方向是在保证覆盖的情况下，用低成本的技术提高系统容量。这背后的使能器是核心技术的突破。这也是我近二十年的通信技术研究生涯所始终追求的目标。</p>
<p>尽管学界对通信原理的发展前景很悲观，但是情况正在起变化。</p>
<p>我在 2014 年发布了<code>多级软频率复用技术</code>（multilevel soft frequency reuse，MLSFR），是 <code>SFR</code> 技术的增强版。理论表明，<code>SFR</code> 可以提升频谱效率 10%左右，<code>MLSFR</code> 可以提高 30%。 值得注意的，这是在不增加任何硬件成本的前提下。 这种幅度技术进步，在最近 30 年的通信史上，只有 <code>Turbo</code> 码可以媲美，远远超过高通在 <code>CDMA</code> 领域的技术创新。MLSFR` 将成为未来移动通信组网技术的基石。</p>
<p>影响更加深远的，我已经在信息论上获得了重大突破。大家知道，香农在 1948 年创立了信息论，其中最重要的成果是这个信道容量公式：C=log（1+S/N），是指引着通信技术研究和工业发展的灯塔。</p>
<p>但是香农只给出了最简单的 AWGN 信道的容量。无线通信的信道都是衰落信道，而衰落信道的容量香农只开了个头，后来的学者发展出了一套衰落信道容量的理论，这些可以在经典的通信原理教科书里面找到。</p>
<p>但是，目前的衰落信道容量理论是错误的。</p>
<p>这个问题我思考了 14 年，终于提出了新的衰落信道容量理论并在 2018 年 3 月份完成了论文初稿。大家可以体会一下基础研究的周期。 审稿的过程也非常艰苦。开始投稿了 Nature，但是 Nature 认为满篇都是公式的稿件不符合它们的风格，还是投到应属期刊 IEEE Transactions on Information Theory。经过 5 个月的评审被拒，原因是两个评委认为论文对信息论存在误解。想想当年 <code>Turbo</code> 码论文，评委认为存在 3dB 的误差。重大突破被误解恐怕是一个规律，创新者需要有这样的心里准备。 但是另外一位评委给予了全面的肯定。当然，所有的评审意见都很容易回答，稿件修改之后再次投稿后，评审又进行了三个月，还没有出结果。在中美贸易战的背景下，美国在整华为，也难保政治不会侵蚀学术道德。不管怎么样，大家很快就能看到了。</p>
<p>基础理论的突破预示着无线通信产业的又一次技术革命，而中国就是这次革命的源头。</p>
<p>成功的道路并不拥挤，我们砥砺前行。</p>
<p>致敬改革开放 40 周年。</p>]]></description>
</item><item>
    <title>Linux 系统信息查询</title>
    <link>https://www.techkoala.top/system_info/</link>
    <pubDate>Sun, 13 Sep 2020 22:35:06 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/system_info/</guid>
    <description><![CDATA[<blockquote>
<p>记录一些常用的 Linux 系统信息查询命令</p>
</blockquote>
<p>日常使用 Linux 过程中，偶尔会需要查询一下系统信息，特别是在对于使用云端主机时，了解必要的信息十分重要。本文总结了一些常用的信息以及相应的查询命令。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">善用 grep 类命令作为配合，高效筛选想要的信息内容。</div>
        </div>
    </div>
<h2 id="系统信息">系统信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ uname -a              <span class="c1"># 查看内核/操作系统/CPU 信息</span>
$ head -n <span class="m">1</span> /etc/issue  <span class="c1"># 查看操作系统版本</span>
$ hostname              <span class="c1"># 查看计算机名</span>
$ lspci -tv             <span class="c1"># 列出所有 PCI 设备</span>
$ lsusb -tv             <span class="c1"># 列出所有 USB 设备</span>
$ lsmod                 <span class="c1"># 列出加载的内核模块</span>
$ env                   <span class="c1"># 查看环境变量</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="系统资源">系统资源</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat /proc/cpuinfo             <span class="c1"># 查看 CPU 信息</span>
$ lscpu                         <span class="c1"># 查看 CPU 信息</span>
$ lshw -short                   <span class="c1"># 当前服务器 CPU、内存、磁盘等详细信息</span>
$ free -m                       <span class="c1"># 查看内存使用量和交换区使用量</span>
$ df -h                         <span class="c1"># 查看各分区使用情况</span>
$ du -sh                        <span class="c1"># 查看指定目录的大小</span>
$ grep MemTotal /proc/meminfo   <span class="c1"># 查看内存总量</span>
$ grep MemFree /proc/meminfo    <span class="c1"># 查看空闲内存量</span>
$ uptime                        <span class="c1"># 查看系统运行时间、用户数、负载</span>
$ cat /proc/loadavg             <span class="c1"># 查看系统负载</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="磁盘和分区">磁盘和分区</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ mount <span class="p">|</span> column -t         <span class="c1"># 查看挂接的分区状态</span>
$ fdisk -l                  <span class="c1"># 查看所有分区</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="网络信息">网络信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ip                    <span class="c1"># 查看网络相关信息，具体用法参见 man 手册</span>
$ iptables -L           <span class="c1"># 查看防火墙设置</span>
$ route -n              <span class="c1"># 查看路由表</span>
$ netstat -lntp         <span class="c1"># 查看所有监听端口</span>
$ netstat -antp         <span class="c1"># 查看所有已经建立的连接</span>
$ netstat -s            <span class="c1"># 查看网络统计信息</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="进程查询">进程查询</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ps -ef            <span class="c1"># 查看所有进程</span>
$ top               <span class="c1"># 实时显示进程状态</span>
$ htop              <span class="c1"># 实时显示进程状态，加强版 top</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="用户信息">用户信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ w                             <span class="c1"># 查看活动用户</span>
$ id &lt;用户名&gt;                    <span class="c1"># 查看指定用户信息</span>
$ last                          <span class="c1"># 查看用户登录日志</span>
$ cut -d: -f1 /etc/passwd       <span class="c1"># 查看系统所有用户</span>
$ cut -d: -f1 /etc/group        <span class="c1"># 查看系统所有组</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="服务">服务</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ crontab -l                    <span class="c1"># 查看当前用户的计划任务</span>
$ chkconfig –list               <span class="c1"># 列出所有系统服务</span>
$ chkconfig –list <span class="p">|</span> grep on     <span class="c1"># 列出所有启动的系统服务</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="软件信息">软件信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ apt list --installed          <span class="c1"># 显示 apt 安装的软件</span>
$ pacman -Qmeq                  <span class="c1"># 显示 aur 软件</span>
$ pacman -Qneq                  <span class="c1"># 显示 pacman 安装的软件</span>
$ pactree package_name          <span class="c1"># 显示软件的依赖树</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>5G NR 系列：波束赋形</title>
    <link>https://www.techkoala.top/beamforming/</link>
    <pubDate>Wed, 09 Sep 2020 16:14:29 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/beamforming/</guid>
    <description><![CDATA[<blockquote>
<p>什么是波束赋形？波束赋形的基本原理是什么？5G 怎样实现波束赋形？</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：无线深海</p>
<p>链接：https://zhuanlan.zhihu.com/p/144971077</p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="什么是波束赋形">什么是波束赋形？</h2>
<p><strong>波束赋形</strong>这个概念可以拆分成<strong>波束</strong>和<strong>赋形</strong>这两个词来理解。</p>
<ul>
<li><strong>波束</strong>里的<strong>波</strong>字可以认为是电磁波，<strong>束</strong>字的本意是“捆绑”，因此波束的含义是捆绑在一起集中传播的电磁波</li>
<li><strong>赋形</strong>可以简单地理解为“赋予一定的形状”</li>
</ul>
<p>合起来，波束赋形的意思就是<strong>赋予一定形状集中传播的电磁波</strong>。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_12.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_12.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_12.webp" data-sub-html="<h2>分散与集中的光线</h2>">
        
    </a><figcaption class="image-caption">分散与集中的光线</figcaption>
    </figure>
<p>其实，我们常见的光也是一种电磁波，灯泡作为一个点光源，发出的光没有方向性，只能不断向四周耗散；而手电筒则可以把光集中到一个方向发射，能量更为聚焦，从而照地更远。</p>
<p>无线基站也是同理，如下图所示，如果天线的信号全向发射的话，这几个手机只能收到有限的信号，大部分能量都浪费掉了。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_17.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_17.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_17.webp" data-sub-html="<h2>分散与集中的电磁波</h2>">
        
    </a><figcaption class="image-caption">分散与集中的电磁波</figcaption>
    </figure>
<p>而如果能通过波束赋形把信号聚焦成几个波束，专门指向各个手机发射的话，承载信号的电磁能量就能传播地更远，而且手机收到的信号也就会更强。</p>
<p>因此，波束赋形在无线通信中大有可为。</p>
<h2 id="波束赋形的基本原理是什么">波束赋形的基本原理是什么？</h2>
<p>波束赋形的物理学原理，其实就是波的干涉现象。</p>
<p>频率相同的两列波叠加，使某些区域的振动加强，某些区域的振动减弱，而且振动加强的区域和振动减弱的区域相互隔开。</p>
<p>想象一下，在湖边漫步时，你和女朋友在相距很近的两点激起水波，两朵涟漪不断散开，然后交叠起来，形成了下面的图样。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_10.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_10.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_10.webp" data-sub-html="<h2>波的干涉现象</h2>">
        
    </a><figcaption class="image-caption">波的干涉现象</figcaption>
    </figure>
<p>可以看出，有的地方水波增强，有的地方则减弱，并且增强和减弱的地方间隔分布，在最中间的狭窄区域最为明显。</p>
<p>如果波峰和波峰，或者波谷和波谷相遇，则能量相加，波峰更高，波谷更深。这种情况叫做相长干涉。</p>
<p>反之，如果波峰和波谷相遇，两者则相互抵消，震动归于静寂。这种情况叫做相消干涉。</p>
<p>如果把这个现象抽象一下，可以得到下图：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_07.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_07.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_07.webp" data-sub-html="<h2>波的干涉</h2>">
        
    </a><figcaption class="image-caption">波的干涉</figcaption>
    </figure>
<p>在两个馈源正中间的地方由于相长干涉，能量最强，可以认为形成了一个定向的波束，也叫做主瓣；两边则由于相消干涉能量抵消，形成了零陷，再往两边又是相长干涉，但弱于最中间，因此称作旁瓣。</p>
<p>如果我们能继续增强正中央主瓣的能量，使其宽度更窄，并抑制两边的旁瓣，就可以得到干净利落的波束了。</p>
<p>其实，普通天线一直在做这样的事情。</p>
<p>天线内部排布着一系列的电磁波源，称作振子，或者天线单元。这些天线单元也利用干涉原理来形成定向的波束。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_04.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_04.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_04.webp" data-sub-html="<h2>单列天线</h2>">
        
    </a><figcaption class="image-caption">单列天线</figcaption>
    </figure>
<p>由上图可以看出，纵向排列的天线单元越多，最中间的可集中的能量也就越多，波束也就越窄。</p>
<p>但这只是一个垂直截面而已，其实完整的波束在空间是三维的，水平和垂直的宽度可能截然不同。</p>
<p>下图是一个天线的振子排列，以及辐射能量三维分布图。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_06.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_06.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_06.webp" data-sub-html="<h2>纵向双列天线</h2>">
        
    </a><figcaption class="image-caption">纵向双列天线</figcaption>
    </figure>
<p>可以看出，上述天线内振源的排布方式为纵向，横向的数量很少，因此其波束在垂直方向的能量集中，而水平方向的角度还是比较宽的，像一个薄薄的大饼。</p>
<p>这种传统的天线水平方向的辐射角度多为 60 度，进行大面积的地面信号覆盖是一把好手，但要垂直覆盖高楼就有些力不从心了，称作“波束赋形”还是不够格。</p>
<p>如果我们把这些天线单元的排布改成矩形，电磁波辐射能量将在最中央形成一个很粗的主瓣，周边是一圈的旁瓣，这就有点波束赋形的意思了。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_01.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_01.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_01.webp" data-sub-html="<h2>矩形天线</h2>">
        
    </a><figcaption class="image-caption">矩形天线</figcaption>
    </figure>
<p>为了让波束更窄能量更集中，天线单元还需要更多更密，水平和垂直两个维度也都要兼顾，原本的天线就变成了大规模天线阵列。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_05.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_05.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_05.webp" data-sub-html="<h2>大规模矩形天线</h2>">
        
    </a><figcaption class="image-caption">大规模矩形天线</figcaption>
    </figure>
<p>这下，生成的波束就犀利多了，用大规模天线阵列来支持波束赋形，稳了！</p>
<p>但是这样还有问题，那就是这个最大波束位于正中央，且其传播方向和天线阵列垂直，而手机是一直随着用户移动的，所在的位置完全不确定，主波束虽然犀利，但照射不到手机上也是白搭。</p>
<p>那么，能不能让波束偏移一定的角度，对准手机来发射呢？</p>
<p>首先我们看看中央的主波束的形成过程：多列波的相位相同，也就是波峰和波谷在同一时间是对齐的，则它们到达手机时，就可以相长干涉，信号通过叠加得以增强。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_02.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_02.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_02.webp" data-sub-html="<h2>到达同相，相长干涉</h2>">
        
    </a><figcaption class="image-caption">到达同相，相长干涉</figcaption>
    </figure>
<p>如果手机和天线阵列有一定的夹角，则各列波到达手机时，相位难以对齐，可能是波峰和波谷相遇，也可能是在其他相位进行叠加，难以达到相长干涉，信号叠加的效果。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_15.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_15.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_15.webp" data-sub-html="<h2>到达异相，无法相长</h2>">
        
    </a><figcaption class="image-caption">到达异相，无法相长</figcaption>
    </figure>
<p>这可咋办？总不能通过旋转天线来让波束跟随手机吧？</p>
<p>其实，周期性是波最大的特点，不同的相位总是周期性的出现，错过了这个波峰，还有下一个波峰要来，因此相位是可以调整的。</p>
<p>通过调整不同天线单元发射信号的振幅和相位（权值），即使它们的传播路径各不相同，只要在到达手机的时候相位相同，就可以达到信号叠加增强的结果，相当于天线阵列把信号对准了手机。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_14.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_14.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_14.webp" data-sub-html="<h2>相位控制</h2>">
        
    </a><figcaption class="image-caption">相位控制</figcaption>
    </figure>
<p>下图是一个示例，可以看出天线阵列通过调整发射信号的相位，让波束偏移了 θ 度，从而可以精确对准手机发射信号。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_13.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_13.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_13.webp" data-sub-html="<h2>相位控制</h2>">
        
    </a><figcaption class="image-caption">相位控制</figcaption>
    </figure>
<h2 id="5g-怎样实现波束赋形">5G 怎样实现波束赋形？</h2>
<p>由此可见，波束赋形的关键在于天线单元相位的管控，也就是天线权值的处理。</p>
<p>根据波束赋形处理位置和方式的不同，可分为</p>
<ul>
<li>数字波束赋形</li>
<li>模拟波束赋形</li>
<li>混合波束赋形</li>
</ul>
<h3 id="模拟波束赋形">模拟波束赋形</h3>
<p>所谓模拟波束赋形，就是通过处理射频信号权值，通过移相器来完成天线相位的调整，处理的位置相对靠后。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_16.webp" data-sub-html="<h2>模拟波束赋形</h2>">
        
    </a><figcaption class="image-caption">模拟波束赋形</figcaption>
    </figure>
<p>模拟波束赋形的特点是基带处理的通道数量远小于天线单元的数量，因此容量上受到限制，并且天线的赋形完全是靠硬件搭建的，还会受到器件精度的影响，使性能受到一定的制约。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_08.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_08.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_08.webp" data-sub-html="<h2>模拟波束赋形框图</h2>">
        
    </a><figcaption class="image-caption">模拟波束赋形框图</figcaption>
    </figure>
<h3 id="数字波束赋形">数字波束赋形</h3>
<p>数字波束赋形则在基带模块的时候就进行了天线权值的处理，基带处理的通道数和天线单元的数量相等，因此需要为每路数据配置一套射频链路。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_11.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_11.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_11.webp" data-sub-html="<h2>数字波束赋形</h2>">
        
    </a><figcaption class="image-caption">数字波束赋形</figcaption>
    </figure>
<p>数字波束赋形的优点是</p>
<ul>
<li>赋形精度高</li>
<li>实现灵活</li>
<li>天线权值变换响应及时</li>
</ul>
<p>缺点是</p>
<ul>
<li>基带处理能力要求高</li>
<li>系统复杂</li>
<li>设备体积大</li>
<li>成本较高</li>
</ul>
<p>Sub6G 频段，作为当前 5G 容量的主力军，载波带宽可达 100MHz，一般采用采用数字波束赋形，通过 64 通道发射来实现小区内时频资源的多用户复用，下行最大可同时发射 24 路独立信号，上行独立接收 12 路数据，扛起了 5G 超高速率的大旗。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_09.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_09.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_09.webp" data-sub-html="<h2>数字波束赋形框图</h2>">
        
    </a><figcaption class="image-caption">数字波束赋形框图</figcaption>
    </figure>
<p>在毫米波 mmWave 频段，由于频谱资源非常充沛，一个 5G 载波的带宽可达 400MHz，如果单个 AAU 支持两个载波的话，带宽就达到了惊人的 800MHz！</p>
<p>如果还要像 Sub6G 频段的设备一样支持数字波束赋形的话，对基带处理能力要求太高，并且射频部分功放的数量也要数倍增加，实现成本过高，功耗更是大得吓人。</p>
<h3 id="混合波束赋形">混合波束赋形</h3>
<p>因此，业界将数字波束赋形和模拟波束赋形结合起来，使在模拟端可调幅调相的波束赋形，结合基带的数字波束赋形，称之为混合波束赋形。</p>
<p>混合波束赋形数字和模拟融合了两者的优点：</p>
<ul>
<li>基带处理的通道数目明显小于模拟天线单元的数量</li>
<li>复杂度大幅下降</li>
<li>成本降低</li>
<li>系统性能接近全数字波束赋形</li>
<li>非常适用于高频系统</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_03.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_03.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/5G/Beamforming/Beamforming_03.webp" data-sub-html="<h2>混合波束赋形框图</h2>">
        
    </a><figcaption class="image-caption">混合波束赋形框图</figcaption>
    </figure>
<p>这样一来，毫米波频段的设备基带处理的通道数较少，一般为 4T4R，但天线单元众多，可达 512 个，其容量的主要来源是超大带宽和波束赋形。</p>
<p>在波束赋形和 Massive MIMO 的加成之下，5G 在 Sub6G 频谱下单载波最多可达 7Gbps 的小区峰值速率，在毫米波频谱下单载波也最多达到了约 4.8Gbps 的小区峰值速率。</p>]]></description>
</item><item>
    <title>3GPP Releases</title>
    <link>https://www.techkoala.top/3gpp_releases/</link>
    <pubDate>Thu, 03 Sep 2020 15:16:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/3gpp_releases/</guid>
    <description><![CDATA[<blockquote>
<p>Meanings of 3GPP releases</p>
</blockquote>
<h2 id="3gpp-release-schedule-and-summary">3GPP Release schedule and summary</h2>
<table>
<thead>
<tr>
<th>3GPP RELEASE</th>
<th>RELEASE DATE</th>
<th>DETAILS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Phase 1</td>
<td>1992</td>
<td>Basic GSM</td>
</tr>
<tr>
<td>Phase 2</td>
<td>1995</td>
<td>GSM features including EFR Codec</td>
</tr>
<tr>
<td>Release 96</td>
<td>Q1 1997</td>
<td>GSM Updates, 14.4 kbps user data</td>
</tr>
<tr>
<td>Release 97</td>
<td>Q1 1998</td>
<td>GSM additional features, GPRS</td>
</tr>
<tr>
<td>Release 98</td>
<td>Q1 1999</td>
<td>GSM additional features, GPRS for PCS 1900, AMR, EDGE</td>
</tr>
<tr>
<td>Release 99</td>
<td>Q1 2000</td>
<td>3G UMTS incorporating WCDMA radio access</td>
</tr>
<tr>
<td>Release 4</td>
<td>Q2 2001</td>
<td>UMTS all-IP Core Network</td>
</tr>
<tr>
<td>Release 5</td>
<td>Q1 2002</td>
<td>IMS and HSDPA</td>
</tr>
<tr>
<td>Release 6</td>
<td>Q4 2004</td>
<td>HSUPA, MBMS, IMS enhancements, Push to Talk over Cellular, operation with WLAN</td>
</tr>
<tr>
<td>Release 7</td>
<td>Q4 2007</td>
<td>Improvements in QoS &amp; latency, VoIP, HSPA+, NFC integration, EDGE Evolution</td>
</tr>
<tr>
<td>Release 8</td>
<td>Q4 2008</td>
<td>Introduction of LTE, SAE, OFDMA, MIMO, Dual Cell HSDPA</td>
</tr>
<tr>
<td>Release 9</td>
<td>Q4 2009</td>
<td>WiMAX / LTE / UMTS interoperability, Dual Cell HSDPA with MIMO, Dual Cell HSUPA, LTE HeNB</td>
</tr>
<tr>
<td>Release 10</td>
<td>Q1 2011</td>
<td>LTE-Advanced, Backwards compatibility with Release 8 (LTE), Multi-Cell HSDPA</td>
</tr>
<tr>
<td>Release 11</td>
<td>Q3 2012</td>
<td>Heterogeneous networks (HetNet), Coordinated Multipoint (CoMP), In device Coexistence (IDC), Advanced IP interconnection of Services,</td>
</tr>
<tr>
<td>Release 12</td>
<td>March 2015</td>
<td>Enhanced Small Cells operation, Carrier Aggregation (2 uplink carriers, 3 downlink carriers, FDD/TDD carrier</td>
</tr>
<tr>
<td>Release 13</td>
<td>Q1 2016</td>
<td>LTE-U / LTE-LAA, LTE-M, Elevation beamforming / Full Dimension MIMO, Indoor positioning, LTE-M Cat 1.4MHz &amp; Cat 200kHz introduced</td>
</tr>
<tr>
<td>Release 14</td>
<td>Mid 2017</td>
<td>Elements on road to 5G</td>
</tr>
<tr>
<td>Release 15</td>
<td>End 2018</td>
<td>5G Phase 1 specification</td>
</tr>
<tr>
<td>Release 16</td>
<td>2020</td>
<td>5G Phase 2 specification</td>
</tr>
<tr>
<td>Release 17</td>
<td>~Sept 2021</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="https://www.electronics-notes.com/articles/connectivity/3gpp/standards-releases.php" target="_blank" rel="noopener noreffer">3GPP Specification Release Numbers</a></li>
</ul>]]></description>
</item></channel>
</rss>
