<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>TechKoala</title>
        <link>https://www.techkoala.top/</link>
        <description>TechKoala的自留地，分享一些笔记，包括但不限于Linux、虚拟机、软件、计算机网络等相关内容</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.top (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.top (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 30 Jul 2020 13:56:16 &#43;0800</lastBuildDate>
            <atom:link href="https://www.techkoala.top/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>HTTPS 工作原理</title>
    <link>https://www.techkoala.top/how_https_works/</link>
    <pubDate>Sun, 16 Aug 2020 21:52:26 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/how_https_works/</guid>
    <description><![CDATA[<blockquote>
<p>理解 HTTP 协议，对称和非对称加密，了解 HTTPS 协议的工作原理</p>
</blockquote>
<blockquote>
<p>注：本文系全文转载，原文信息如下：</p>
<p>作者：猫尾博客</p>
<p>链接：https://cattail.me/tech/2015/11/30/how-https-works.html</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>读完本文，你能明白</p>
<ul>
<li>什么是 HTTPS，TLS (SSL)，TLS 和 HTTPS 是什么关系</li>
<li>什么是证书和数字签名，它们是如何传递信任的</li>
<li>HTTPS 有什么样的功能，它是如何实现这样的功能的</li>
</ul>
<h2 id="简介">简介</h2>
<p>HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。本文着重描述 TLS 协议的 1.2 版本</p>
<p>下图描述了在 TCP/IP 协议栈中 TLS (各子协议）和 HTTP 的关系</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/tcp-ip-model.webp" title="/images/Network/HTTPS/tcp-ip-model.webp" data-thumbnail="/images/Network/HTTPS/tcp-ip-model.webp" data-sub-html="<h2>Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS</h2>">
        
    </a><figcaption class="image-caption">Credit: <a href="https://blogs.msdn.com/213737/ProfileUrlRedirect.ashx" target="_blank" rel="noopener noreffer">Kaushal Kumar Panday</a> From: <a href="https://blogs.msdn.com/b/kaushal/archive/2013/08/03/ssl-handshake-and-https-bindings-on-iis.aspx" target="_blank" rel="noopener noreffer">SSL Handshake and HTTPS Bindings on IIS</a></figcaption>
    </figure>
<p>其中 Handshake protocol，Change Ciper Spec protocol 和 Alert protocol 组成了 SSL Handshaking Protocols。</p>
<p>HTTPS 和 HTTP 协议相比提供了:</p>
<ol>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ol>
<p>其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。</p>
<h2 id="总览">总览</h2>
<p>使用 RSA 算法的 SSL 握手过程是这样的:</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/ssl_handshake_rsa.webp" title="/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<ol>
<li>[明文] 客户端发送随机数 client_random 和支持的加密方式列表</li>
<li>[明文] 服务器返回随机数 server_random ，选择的加密方式和服务器证书链</li>
<li>[RSA] 客户端验证服务器证书，使用证书中的公钥加密 premaster secret 发送给服务端</li>
<li>服务端使用私钥解密 premaster secret</li>
<li>两端分别通过 client_random，server_random 和 premaster secret 生成 master secret，用于对称加密后续通信内容</li>
</ol>
<h3 id="证书digital-certificate">证书（Digital certificate）</h3>
<p>那么什么是证书呢？</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/certificate.webp" title="/images/Network/HTTPS/certificate.webp" data-thumbnail="/images/Network/HTTPS/certificate.webp" data-sub-html="<h2>证书信息</h2>">
        
    </a><figcaption class="image-caption">证书信息</figcaption>
    </figure>
<h3 id="证书中包含了以下信息">证书中包含了以下信息</h3>
<ol>
<li>证书信息：过期时间和序列号</li>
<li>所有者信息：姓名等</li>
<li>所有者公钥</li>
<li>为什么服务端要发送证书给客户端</li>
</ol>
<p>互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<h3 id="客户端为什么要验证接收到的证书">客户端为什么要验证接收到的证书</h3>
<p><strong>中间人攻击</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">客户端 &lt;------------ 攻击者 &lt;------------ 服务端
        伪造证书            拦截请求
</code></pre></td></tr></table>
</div>
</div><h3 id="客户端如何验证接收到的证书">客户端如何验证接收到的证书</h3>
<p>为了回答这个问题，需要引入<code>数字签名</code> (Digital Signature)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |            +---------+              +--------+
| is a mathematical   |---- 哈希 ---&gt;| 消息摘要  |--- 私钥加密 ---&gt;| 数字签名 |
|technique used       |            +---------+              +--------+
|to validate the      |
|authenticity and     |
|integrity of a       |
|message, software    |
|or digital document. |
+---------------------+
</code></pre></td></tr></table>
</div>
</div><p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p>
<p>假设消息传递在 Bob，Susan 和 Pat 三人之间发生。Susan 将消息连同数字签名一起发送给 Bob，Bob 接收到消息后，可以这样验证接收到的消息就是 Susan 发送的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">+---------------------+
| A digital signature |
|(not to be confused  |
|with a digital       |
|certificate)         |              +---------+
| is a mathematical   |---- 哈希 ---&gt;|  消息摘要 |
|technique used       |              +---------+
|to validate the      |                 |
|authenticity and     |                 |
|integrity of a       |                 |
|message, software    |                 对
|or digital document. |                 比
+---------------------+                 |
                                        |
                                        |
        +---------+               +----------+
        | 数字签名 |--- 公钥解密 ---&gt;|  消息摘要 |
        +---------+               +----------+
</code></pre></td></tr></table>
</div>
</div><p>当然，这个前提是 Bob 知道 Susan 的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Bob。</p>
<p>此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener noreffer">证书颁发机构</a>（Certificate Authority，简称 CA），CA 数量并不多，Bob 客户端内置了所有受信任 CA 的证书。CA 对 Susan 的公钥（和其他信息）数字签名后生成证书。</p>
<p>Susan 将证书发送给 Bob 后，Bob 通过 CA 证书的公钥验证证书签名。</p>
<p>Bob 信任 CA，CA 信任 Susan 使得 Bob 信任 Susan，信任链（Chain Of Trust）就是这样形成的。</p>
<p>事实上，Bob 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<h2 id="tls-协议">TLS 协议</h2>
<p>TLS 协议包括 TLS Record Protocol 和 TLS Handshake Protocol。总览中的流程图仅涉及到 TLS Handshake Protocol。</p>
<h3 id="tls-record-protocol">TLS Record Protocol</h3>
<p>在 TLS 协议中，有四种子协议运行于 Record protocol 之上</p>
<ul>
<li>Handshake protocol</li>
<li>Alert protocol</li>
<li>Change cipher spec protocol</li>
<li>Application data protocol</li>
</ul>
<p>Record protocol 起到了这样的作用</p>
<ul>
<li>在发送端：将数据（Record）分段，压缩，增加 MAC (Message Authentication Code) 和加密</li>
<li>在接收端：将数据（Record）解密，验证 MAC，解压并重组</li>
</ul>
<blockquote>
<p>值得一提的是，Record protocol 提供了数据完整性和隐私性保证，但 Record 类型（type）和长度（length）是公开传输的</p>
</blockquote>
<p>Record Protocol 有三个连接状态 (Connection State)，连接状态定义了压缩，加密和 MAC 算法。所有的 Record 都是被当前状态（Current State）确定的算法处理的。</p>
<p><code>TLS Handshake Protocol</code> 和 <code>Change Ciper Spec Protocol</code> 会导致 <code>Record Protocol</code> 状态切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">empty state -------------------&gt; pending state ------------------&gt; current state
             Handshake Protocol                Change Cipher Spec
</code></pre></td></tr></table>
</div>
</div><p>初始当前状态（Current State）没有指定加密，压缩和 MAC 算法，因而在完成 TLS Handshaking Protocols 一系列动作之前，客户端和服务端的数据都是<strong>明文传输</strong>的；当 TLS 完成握手过程后，客户端和服务端确定了加密，压缩和 MAC 算法及其参数，数据（Record）会通过指定算法处理。</p>
<blockquote>
<p>其中，Record 首先被加密，然后添加 MAC（message authentication code）以保证数据完整性。</p>
</blockquote>
<h3 id="tls-handshaking-protocols">TLS Handshaking Protocols</h3>
<p>Handshakeing protocols 包括 Alert Protocol，Change Ciper Spec Protocol 和 Handshake protocol。本文不会详细介绍 Alert Protocol 和 Change Ciper Spec Protocol。</p>
<p>使用 RSA 算法的握手过程是这样的（已在总览中提到）</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/ssl_handshake_rsa.webp" title="/images/Network/HTTPS/ssl_handshake_rsa.webp" data-thumbnail="/images/Network/HTTPS/ssl_handshake_rsa.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<p>客户端和服务端在握手 hello 消息中明文交换了 client_random 和 server_random ，使用 RSA 公钥加密传输 premaster secret ，最后通过算法，客户端和服务端分别计算 master secret。其中，不直接使用 premaster secret 的原因是：保证 secret 的随机性不受任意一方的影响。</p>
<p>除了使用 RSA 算法在公共信道交换密钥，还可以通过 Diffie–Hellman 算法。Diffie–Hellman 算法的原理是这样的</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" title="/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-thumbnail="/images/Network/HTTPS/Diffie-Hellman_Key_Exchange.webp" data-sub-html="<h2>By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</h2>">
        
    </a><figcaption class="image-caption">By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons</figcaption>
    </figure>
<p>使用 Diffie–Hellman 算法交换 <code>premaster secret</code> 的流程</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" title="/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-thumbnail="/images/Network/HTTPS/ssl_handshake_diffie_hellman.webp" data-sub-html="<h2>Source: Keyless SSL: The Nitty Gritty Technical Details</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless SSL: The Nitty Gritty Technical Details</a></figcaption>
    </figure>
<h2 id="小结">小结</h2>
<p>TLS Handshaking Protocols 协商了 TLS Record Protocol 使用的算法和所需参数，并验证了服务端身份；</p>
<p>TLS Record Protocol 在协商后保证应用层数据的完整性和隐私性。</p>
<p>TLS Handshaking Protocol 的核心是在公开信道上传递 premaster secret。</p>
<h2 id="qa">Q&amp;A</h2>
<h3 id="为什么传输内容不直接使用非对称加密">为什么传输内容不直接使用非对称加密？</h3>
<p>因为性能限制。</p>
<h3 id="https-能保证正常连接">HTTPS 能保证正常连接？</h3>
<p>不能。</p>
<blockquote>
<p>There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support.</p>
</blockquote>
<p>攻击者甚至可以直接丢弃双方的数据包</p>
<h3 id="服务端如何验证客户端身份">服务端如何验证客户端身份？</h3>
<p>通过 Client Certificate</p>
<blockquote>
<p>This message conveys the client’s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite’s key exchange algorithm, and any negotiated extensions.</p>
</blockquote>
<h3 id="alert-protocol-有什么作用">Alert protocol 有什么作用？</h3>
<p>Closure Alerts：防止 Truncation Attack</p>
<blockquote>
<p>In a truncation attack, an attacker inserts into a message a TCP code indicating the message has finished, thus preventing the recipient picking up the rest of the message. To prevent this, SSL from version v3 onward has a closing handshake, so the recipient knows the message has not ended until this has been performed.</p>
</blockquote>
<p>Error Alerts：错误处理</p>
<h3 id="master-secret-是如何计算的">master secret 是如何计算的</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  master_secret = PRF (pre_master_secret, &#34;master secret&#34;,
                      ClientHello.random + ServerHello.random)
                      [0..47];
</code></pre></td></tr></table>
</div>
</div><h3 id="加密压缩和-mac-算法参数是如何计算的">加密，压缩和 MAC 算法参数是如何计算的</h3>
<p>Handshaking Protocols 使得客户端和服务端交换了三个参数：client_random，server_random 和 master_secret，通过以下算法生成算法所需要的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">To generate the key material, compute

  key_block = PRF (SecurityParameters.master_secret,
                  &#34;key expansion&#34;,
                  SecurityParameters.`server_random` +
                  SecurityParameters.`client_random`);

until enough output has been generated.  Then, the key_block is
partitioned as follows:

  client_write_MAC_key [SecurityParameters.mac_key_length]
  server_write_MAC_key [SecurityParameters.mac_key_length]
  client_write_key [SecurityParameters.enc_key_length]
  server_write_key [SecurityParameters.enc_key_length]
  client_write_IV [SecurityParameters.fixed_iv_length]
  server_write_IV [SecurityParameters.fixed_iv_length]
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key</p>
</blockquote>
<p>使用 Diffie-Hellman 算法的 TLS 握手细节</p>
<figure><a class="lightgallery" href="/images/Network/HTTPS/dh-detail.webp" title="/images/Network/HTTPS/dh-detail.webp" data-thumbnail="/images/Network/HTTPS/dh-detail.webp" data-sub-html="<h2>Source: https://cipherstuff.wordpress.com/</h2>">
        
    </a><figcaption class="image-caption">Source: <a href="https://cipherstuff.wordpress.com/">https://cipherstuff.wordpress.com/</a></figcaption>
    </figure>
<h2 id="拓展阅读">拓展阅读</h2>
<ul>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">Keyless</a></li>
<li><a href="https://letsencrypt.org/" target="_blank" rel="noopener noreffer">Let’s Encrypt</a></li>
<li>Session resume</li>
<li>证书Revoke</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener noreffer">TLS1.2规范</a></p>
</li>
<li>
<p>[2] <a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener noreffer">PKI规范</a></p>
</li>
<li>
<p>[3] <a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener noreffer">证书和数字签名</a></p>
</li>
<li>
<p>[4] <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener noreffer">TLS Handshake</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>如何高效搜索？</title>
    <link>https://www.techkoala.top/how_to_search/</link>
    <pubDate>Fri, 14 Aug 2020 12:50:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/how_to_search/</guid>
    <description><![CDATA[<blockquote>
<p>如何在互联网上高效地找到自己想要的东西？</p>
</blockquote>
<p>搜索引擎方便了我们搜索资料，但是由于各种垃圾内容、网站地出现，实际上，搜索过程往往是十分低效的（特别是使用中文搜索）。因此，值得学习一些提升搜索效率必要的小技巧。</p>
<p>废话不多说，直接分类讲解：</p>
<h2 id="搜索语法">搜索语法</h2>
<p>首先总结一下常用的语法表达式：</p>
<table>
<thead>
<tr>
<th>operator</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ldquo;phrase&rdquo;</td>
<td>结果必须包含 &ldquo;phrase&rdquo;</td>
</tr>
<tr>
<td>- phrase</td>
<td>结果排除 phrase</td>
</tr>
<tr>
<td>A AND B</td>
<td>A 和 B 必须同时包含</td>
</tr>
<tr>
<td>A OR B</td>
<td>必须包括 A 和 B 之一（或两者）</td>
</tr>
<tr>
<td>site:example.com</td>
<td>在网站中搜索</td>
</tr>
<tr>
<td>filetype:jpg</td>
<td>结果必须包含类型 .jpg</td>
</tr>
</tbody>
</table>
<h2 id="实例展示">实例展示</h2>
<h3 id="网页">网页</h3>
<p>查找网站内的特定页面（例如：本网站上的 <code>Trick</code> 标签）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">site:www.techkoala.top Trick
</code></pre></td></tr></table>
</div>
</div><p>查找必须在标题文本中包含短语的特定页面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">allintitle:&#34;Github&#34; site:techkoala.com
</code></pre></td></tr></table>
</div>
</div><p>查找类似网站（仅谷歌搜索）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">related:techkoala.com
</code></pre></td></tr></table>
</div>
</div><p>您可以将运算符链接在一起 （例如：在 Url 中查找具有安全性或错误赏金）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">inurl:security OR inurl:bug-bounty OR site:hackerone.com) + &#34;techkoala&#34;
</code></pre></td></tr></table>
</div>
</div><p>您可以限制为某些顶级域（例如：教师列表）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">site:.edu filetype:xls inurl:&#34;email.xls&#34;
</code></pre></td></tr></table>
</div>
</div><h3 id="email">Email</h3>
<p>查找 Gmail 帐户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">username &#34;@gmail.com&#34;
</code></pre></td></tr></table>
</div>
</div><p>查找工作帐户（您需要先找到他们的域）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">username  &#34;@techkoala.top&#34;
</code></pre></td></tr></table>
</div>
</div><p>模糊搜索的情况下，可以尝试猜测电子邮件的格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&#34;username&#34; &#34;@&#34; &#34;.com&#34;
</code></pre></td></tr></table>
</div>
</div><p>在网站上查找电子邮件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">site:gumroad.com intext:&#34;@gumroad.com&#34;
</code></pre></td></tr></table>
</div>
</div><p>在网页上查找您访问的每封电子邮件，适用于每个网站，将其注入 Chrome 开发工具</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var elems = document.body.getElementsByTagName (&#34;*&#34;);
var re = new RegExp (&#34;(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)&#34;);
for (var i = 0; i &lt; elems.length; i++) {
    if (re.test (elems [i].innerHTML)) {
        console.log (elems [i].innerHTML);
    }
}
</code></pre></td></tr></table>
</div>
</div><p>这将记录找到的每封电子邮件，而无需扫描整个页面。</p>
<h3 id="文件">文件</h3>
<p>查找电子表格</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">filetype:csv OR filetype:xlsx OR filetype:xls OR filetype:xltx OR filetype:xlt OR inurl:airtable.com/universe/
</code></pre></td></tr></table>
</div>
</div><p>查找谷歌文档和谷歌表格</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">site:docs.google.com &#34;techkoala&#34;
</code></pre></td></tr></table>
</div>
</div><h3 id="seo">SEO</h3>
<p>在锚文本中查找具有特定关键字的网站</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">inanchor:&#34;cyber security&#34;
</code></pre></td></tr></table>
</div>
</div><p>研究标题中包含特定关键字的博客帖子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">inposttitle:&#34;diy slime&#34;
</code></pre></td></tr></table>
</div>
</div><p>查找反向链接 (例如：链接到特定博客帖子的其他网站)。注意：链接运算符 <code>link</code> 现在已弃用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">intext:intercom.com/intercom-api-reference/reference
</code></pre></td></tr></table>
</div>
</div><p>使用通配符运算符查找关键字排列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">* design tools
</code></pre></td></tr></table>
</div>
</div><p>使用给定的 widget 查找公司</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">intext:&#34;Powered by Intercom&#34; -site:intercom.com
</code></pre></td></tr></table>
</div>
</div><h1 id="待更新">待更新&hellip;</h1>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://www.alec.fyi/dorking-how-to-find-anything-on-the-internet.html" target="_blank" rel="noopener noreffer">dorking (how to find anything on the Internet)</a></p>
</li>
<li>
<p>[2] <a href="https://ahrefs.com/blog/google-advanced-search-operators/" target="_blank" rel="noopener noreffer">Google Search Operators: The Complete List (42 Advanced Operators)</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>利用 Netlify 搭建 Koodo Reader</title>
    <link>https://www.techkoala.top/reader/</link>
    <pubDate>Wed, 12 Aug 2020 11:22:58 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/reader/</guid>
    <description><![CDATA[<blockquote>
<p>搭建自己的在线 EPUB 阅读器</p>
</blockquote>
<h2 id="什么是-netlify">什么是 Netlify</h2>
<p>引用 <a href="https://www.netlify.com/" target="_blank" rel="noopener noreffer">Netlify 官网</a>的介绍：</p>
<blockquote>
<p>Netlify is a unified platform that automates your code to create high-performant, easily maintainable sites and web apps.</p>
</blockquote>
<p>也就是说，Netlify 是一个提供静态网站托管的服务。它提供CI服务，能够将托管在 GitHub，GitLab 等网站上代码生成静态网站进行展示。类似于 Github Pages，不过功能更加丰富。</p>
<h2 id="koodo-reader">Koodo Reader</h2>
<p>Koodo Reader 是一个基于 React 和 Electron 开发的 Epub 阅读器。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/koodo1.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/koodo1.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/koodo1.webp" data-sub-html="<h2>Koodo Reader 首页</h2>">
        
    </a><figcaption class="image-caption">Koodo Reader 首页</figcaption>
    </figure>
<p>提供以下功能：</p>
<blockquote>
<p>📝 强大笔记和翻译功能，学习事半功倍</p>
<p>🚩 使用书架来为你的图书分类</p>
<p>🌎 支持 <strong>Windows</strong> ， <strong>MacOS</strong> 和 <strong>网页版</strong></p>
<p>🖥 绑定 <strong>OneDrive</strong>， <strong>Google Drive</strong>， <strong>Dropbox</strong> 等网盘，实现数据的多端同步</p>
<p>💻 您所有的数据都支持导入导出</p>
</blockquote>
<p>更多详情请点击 <a href="https://koodo.960960.xyz/" target="_blank" rel="noopener noreffer">Koodo Reader 官网</a> 查看。</p>
<h2 id="搭建">搭建</h2>
<ol>
<li>首先进入 <a href="https://www.netlify.com/" target="_blank" rel="noopener noreffer">Netlify 官网</a>，点击注册，这里我选择直接使用Github登录，当然，你也可以选择其他方式。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Sign_Up.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Sign_Up.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Sign_Up.webp" data-sub-html="<h2>Netlify 注册</h2>">
        
    </a><figcaption class="image-caption">Netlify 注册</figcaption>
    </figure>
<ol start="2">
<li>注册登陆后，进入首页，点击右上角的 New Site from Git ，创建一个新的站点。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site.webp" data-sub-html="<h2>创建新站点</h2>">
        
    </a><figcaption class="image-caption">创建新站点</figcaption>
    </figure>
<ol start="3">
<li>接下来，点击下方的 Github 进行授权，这里会弹出一个新的窗口，让你授权 Netlify 访问你的 Github 账户，完成授权后进去下一步。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site_github.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site_github.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site_github.webp" data-sub-html="<h2>使用Github 创建新站点</h2>">
        
    </a><figcaption class="image-caption">使用Github 创建新站点</figcaption>
    </figure>
<ol start="4">
<li>这一步会让你选择你将用于生成站点的库，这里我已经提前 Fork <a href="https://github.com/troyeguo/koodo-reader" target="_blank" rel="noopener noreffer">troyeguo 的 Koodo Reader 库</a>，所以直接选择即可。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site_Auth.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site_Auth.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/New_site_Auth.webp" data-sub-html="<h2>选择相应的 Repo</h2>">
        
    </a><figcaption class="image-caption">选择相应的 Repo</figcaption>
    </figure>
<ol start="5">
<li>接着，配置 Build 选项。在该项目的部署中，需要修改 <code>Build name &gt; yarn build</code>，<code>Publish directory &gt; build/ </code>，其他保持默认即可。（如果配置其他项目，这里的参数可能不同，请参考具体项目的指导说明）</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Site_Setting.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Site_Setting.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Site_Setting.webp" data-sub-html="<h2>配置</h2>">
        
    </a><figcaption class="image-caption">配置</figcaption>
    </figure>
<ol start="6">
<li>到这里，已经完成了整个部署工作，等待 Netlify 构建完成即刻。</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Deploying.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Deploying.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Deploying.webp" data-sub-html="<h2>配置</h2>">
        
    </a><figcaption class="image-caption">配置</figcaption>
    </figure>
<ol start="7">
<li>Netlify 会给你默认分配一个二级域名用于访问，当然也支持自定义域名，这里我绑定了自己域名。除了在此处绑定外，还需要配置 DNS 等等，这个请自行完成。（由于搭建博客时，已经完成了相应设置，因此，我直接在 Cloudfalre 新建了一个 CNAME 指向 Netlify 给我的域名就好了）</li>
</ol>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Domain_Setting.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Domain_Setting.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Web/Reader/Domain_Setting.webp" data-sub-html="<h2>配置</h2>">
        
    </a><figcaption class="image-caption">配置</figcaption>
    </figure>
<ol start="8">
<li>大功告成，来<a href="https://reader.techkoala.top/" target="_blank" rel="noopener noreffer">这里</a>看看书吧。</li>
</ol>
<h2 id="后续">后续</h2>
<p>如果需要对网站进行更新，只需要关注你的 Github Repo 即可。每次 commit 之后，Netlify 都会自动拉取更新并生成。</p>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a href="https://github.com/troyeguo/koodo-reader" target="_blank" rel="noopener noreffer">koodo-reader</a></li>
</ul>]]></description>
</item><item>
    <title>网络测试工具：iPerf</title>
    <link>https://www.techkoala.top/iperf/</link>
    <pubDate>Fri, 07 Aug 2020 17:45:55 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/iperf/</guid>
    <description><![CDATA[<blockquote>
<p>TCP、UDP 和 SCTP 的终极速度测试工具</p>
</blockquote>
<h2 id="什么是-iperf">什么是 iPerf</h2>
<p>iPerf 是一个用于测量网络最大带宽的小工具。iPerf 可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和 UDP 特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。对于每个测试，它都会报告带宽，丢包和其他参数。</p>
<p>现在的版本也称 iPerf3，这是对 NLANR/DAST 开发的原始版本的重新设计。</p>
<p><strong>注意</strong>：iPerf3 与此前版本的 iPerf 不兼容。</p>
<h2 id="安装-iperf">安装 iPerf</h2>
<p>iPerf3 官方仅支持 CentOS Linux，FreeBSD 和 macOS，但实际上，<a href="https://iperf.fr/iperf-download.php" target="_blank" rel="noopener noreffer">官网</a>提供了主流系统的预编译文件。（包括 Windows、Android、iOS、Ubuntu、Arch Linux 等）</p>
<p>类 UNIX 系统直接使用包管理进行安装即可，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo apt install iperf3
</code></pre></td></tr></table>
</div>
</div><h2 id="使用-iperf">使用 iPerf</h2>
<p>首先，介绍服务端和客户端共有的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-p, --port n      服务器用于侦听和客户端连接的服务器端口，两者应该相同，默认值为 <span class="m">5201</span>
--cport n         指定客户端端口
-f, --format      用于指定单位显示格式，支持 <span class="s1">&#39;k&#39;</span> <span class="o">=</span> Kbits/sec <span class="s1">&#39;K&#39;</span> <span class="o">=</span> KBytes/sec <span class="s1">&#39;m&#39;</span> <span class="o">=</span> Mbits/sec <span class="s1">&#39;M&#39;</span> <span class="o">=</span> MBytes/sec，默认为自适应格式
-i, --interval n  设置测试信息报告之间的间隔时间（以秒为单位）。如果为零，则不打印任何定期报告。默认值为零。
-F, --file name   客户端：从文件读取并写入网络，而不是使用随机数据；服务器端：从网络读取并写入文件，而不是丢弃数据。
-A, --affinity    如果可以，设置 CPU 关联（仅限 Linux 和 FreeBSD）。
-B, --bind host   绑定到主机。对于客户端，这将设置出站接口。对于服务器，这将设置传入接口。这只适用于具有多个网络接口的多宿主主机。
-V, --verbose     提供更详细的输出
-J, --json        以 JSON 格式输出
--logfile file    输出到日志文件
--d, --debug      发出调试输出
-v, --version     输出版本信息
-h, --help        输出帮助信息
</code></pre></td></tr></table>
</div>
</div><p>服务端特有参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-s, --server      在服务器模式下运行 iPerf（一次只允许一个 iPerf 连接）
-D, --daemon      将服务器作为守护进程在后台运行
-I, --pidfilefile 使用进程ID编写文件，这在作为守护进程运行时非常有用
</code></pre></td></tr></table>
</div>
</div><p>客户端特有参数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-c, --client host	    在客户端模式下运行 iPerf
--sctp	                使用 SCTP 而不是 TCP
-u, --udp	            使用 UDP 而不是 TCP
-b, --bandwidth      	将目标带宽设置为 nbits/sec（对于 UDP 默认为 <span class="m">1</span> Mbit/sec，对于 TCP 为无限制）。如果有多个流（-P 标志），则带宽限制将分别应用于每个流。您还可以在带宽说明符中添加一个 “/” 和一个数字。这称为 “突发模式”。 它会发送给定数量的数据包而不会暂停，即使该数据包暂时超过了指定的带宽限制
-t, --time  	        传输的时间（以秒为单位）。iPerf 通常通过在 t 时间内重复发送 len 长度的字节数组来工作。默认值为 <span class="m">10</span> 秒
-n, --num 	            要传输的缓冲区数量。通常，iPerf 只会发送 <span class="m">10</span> 秒。-n 选项覆盖此设置，并发送 len 长度字节数组 n 次，无论需要多长时间
-k, --blockcount    	要传输的块（数据包）数
-l, --length     	    读取或写入的缓冲区的长度，iPerf 通过多次写入 len 个字节的数组来工作。TCP 的默认值为 <span class="m">128</span> KB，UDP 的默认值为 <span class="m">8</span> KB。 
-P, --parallel  	    与服务器同时建立的连接数，默认值为 <span class="m">1</span>
-R, --reverse	        以反向模式运行（服务器发送，客户端接收）
-w, --window    	    将套接字缓冲区大小设置为指定值。对于 TCP，这将设置 TCP 窗口大小（这将发送到服务器并在该侧使用）
-M, --set-mss  	        尝试设置 TCP 最大段大小（MSS）。MSS 通常是 MTU-TCP/IP 标头的 <span class="m">40</span> 个字节。对于以太网，MSS 为 <span class="m">1460</span> 字节（1500 字节 MTU）
-N, --no-delay	        设置 “TCP no delay” 选项，禁用 Nagle 的算法。通常，仅对交互式应用程序（如 telnet）禁用此功能
-4, --version4	        仅使用 IPv4.
-6, --version4	        仅使用 IPv6.
-S, --tos               传出数据包的服务类型。<span class="o">(</span>许多路由器会忽略TOS字段。）可以使用十六进制值（0x）作为前缀，使用八进制数（0）作为前缀，或者使用十进制来指定值。 例如，<span class="s1">&#39;0x10&#39;</span><span class="nv">十六进制</span><span class="o">=</span><span class="s1">&#39;020&#39;</span><span class="nv">八进制</span><span class="o">=</span><span class="s1">&#39;16&#39;</span>十进制。RFC 1349中指定的TOS编号为：
                        IPTOS_LOWDELAY     minimize delay        0x10
                        IPTOS_THROUGHPUT   maximize throughput   0x08
                        IPTOS_RELIABILITY  maximize reliability  0x04
                        IPTOS_LOWCOST      minimize cost         0x02
-L, --flowlabel  	    设置 IPv6 流标签（当前仅在 Linux 上受支持）
-Z, --zerocopy	        使用 “零拷贝” 方法发送数据，如 sendfile（2），而不是通常的 write（2）。这样可以占用更少的 CPU
-O, --omit  	        省略测试的前 n 秒，以跳过 TCP TCP 慢启动周期
-T, --title             为每个输出行添加此字符串前缀
-C, --linux-congestion  设置拥塞控制算法 <span class="o">(</span>仅适用于 iPerf 3.1 的 Linux 和 FreeBSD<span class="o">)</span>。
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>注意：</strong> 从客户端专有选项可以看出，iPerf 默认测试的是从客户端发送到服务端，相对于客户端来说，测试就是上行链路的带宽，对于一般参考意义更大的下行链路需要加上 <code>-R</code> 选项。</p>
</blockquote>
<p>常用启用参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">服务端
$ iperf3 -s -p <span class="m">12345</span> -i <span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">客户端
$ iperf3 -c 192.168.1.43 -p <span class="m">12345</span> -i <span class="m">1</span> -t <span class="m">20</span> -w 100k
</code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/iperf/iperf.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/iperf/iperf.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Network/iperf/iperf.webp" data-sub-html="<h2>iPerf 使用实例</h2>">
        
    </a><figcaption class="image-caption">iPerf 使用实例</figcaption>
    </figure>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://iperf.fr/iperf-doc.php" target="_blank" rel="noopener noreffer">iPerf user docs</a></p>
</li>
<li>
<p>[2] <a href="https://github.com/esnet/iperf" target="_blank" rel="noopener noreffer">iPerf Github</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>文件传输 3：SFTP</title>
    <link>https://www.techkoala.top/sftp/</link>
    <pubDate>Thu, 06 Aug 2020 14:07:53 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/sftp/</guid>
    <description><![CDATA[<blockquote>
<p>SCP 的继承者</p>
</blockquote>
<h2 id="什么是-sftp">什么是 SFTP</h2>
<p>首先需要明确的是，SFTP（SSH File Transfer Protocol）不是运行在 SSH 上的 FTP，而是由 IETF（Internet Engineering Task Force）工作组设计的新协议，将其作为 SSH 2.0 版的扩展，提供安全的文件传输功能。因此，没有单独的 SFTP 端口，而是使用普通的 SSH 端口。协议本身不提供身份验证和安全性，而是期望底层协议提供。</p>
<p>与仅允许文件传输的 SCP 协议相比，SFTP 协议允许对远程文件进行一系列操作，这使其更像远程文件系统协议。SFTP 客户端还支持包括恢复中断的传输，目录列表和远程文件删除等功能。此外，上传的文件可以与它们的基本属性相关联，例如时间戳。相比普通 FTP 协议，这是一项优势。</p>
<p>尽管 SFTP 最常在 Unix 平台上实现，但 SFTP 在主流平台都可用。</p>
<blockquote>
<p>有关 SFTP 详细草案参见 <a href="https://assets.ctfassets.net/0lvk5dbamxpi/6jBxT5LDgMqutNK4mPTGKd/4fa27cb4a130bca3b48a10c9045b0497/draft-ietf-secsh-filexfer-02" target="_blank" rel="noopener noreffer">draft-ietf-secsh-filexfer-02</a></p>
</blockquote>
<h2 id="使用-sftp">使用 SFTP</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sftp 选项 参数
</code></pre></td></tr></table>
</div>
</div><h3 id="选项">选项</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">-B：指定传输文件时缓冲区的大小；
-l：使用 ssh 协议版本 1；
-b：指定批处理文件；
-C：使用压缩；
-o：指定 ssh 选项；
-F：指定 ssh 配置文件；
-R：指定一次可以容忍多少请求数；
-v：升高日志等级。
</code></pre></td></tr></table>
</div>
</div><h3 id="参数">参数</h3>
<p>目标主机：指定 SFTP 服务器 IP 地址或者主机名。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol" target="_blank" rel="noopener noreffer">SSH File Transfer Protocol</a></p>
</li>
<li>
<p>[2] <a href="https://jaywcjlove.gitee.io/linux-command/c/sftp.html" target="_blank" rel="noopener noreffer">SFTP Command</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>文件传输 2：rsync</title>
    <link>https://www.techkoala.top/rsync/</link>
    <pubDate>Wed, 05 Aug 2020 20:58:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/rsync/</guid>
    <description><![CDATA[<blockquote>
<p>SCP 的另一个绝佳替选</p>
</blockquote>
<h2 id="什么是-rsync">什么是 rsync</h2>
<p>rsync (remote synchronize) 是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。</p>
<p>rsync 是<code>类 Unix</code> 系统下的数据镜像备份工具。它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。 rsync 中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync 可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。</p>
<p>rsync 默认监听 <code>TCP</code> 端口 873，以原生 rsync 传输协议或者透过<code>远程 shell</code> 如 <code>RSH</code> 或者 <code>SSH</code> 提供文件。<code>SSH</code> 模式下，rsync 客户端运行程序必须同时在本地和远程机器上安装。</p>
<h2 id="rsync-算法">rsync 算法</h2>
<blockquote>
<p>此部分内容转载 <a href="https://coolshell.cn/articles/7425.html" target="_blank" rel="noopener noreffer">RSYNC 的核心算法</a></p>
</blockquote>
<p>rsync 的算法如下：（假设源文件名为 <code>fileSrc</code>，目的文件叫 <code>fileDst</code>）</p>
<h3 id="分块-checksum-算法">分块 Checksum 算法</h3>
<p>首先，我们会把 <code>fileDst</code> 的文件平均切分成若干个小块，比如每块 512 个字节，然后对<strong>每块</strong>计算<strong>两个</strong> <code>checksum</code>，一个叫 <code>rolling checksum</code>，是<code>弱 checksum</code>，32 位的 <code>checksum</code>，其使用的是 Mark Adler 发明的 <code>adler-32</code> 算法，另一个是<code>强 checksum</code>，128 位的，以前用 <code>md4</code>，现在用 <code>md5</code>。为什么要这样？因为若干年前的硬件上跑 <code>md4</code> 的算法太慢了，所以，需要一个快算法来鉴别文件块的不同，但是弱的 <code>adler-32</code> 算法碰撞概率太高了，所以我们还要引入强的 <code>checksum</code> 算法以保证两文件块是相同的。也就是说，弱的 <code>checksum</code> 是用来区别不同，而强的是用来确认相同。</p>
<h3 id="传输算法">传输算法</h3>
<p>同步目标端会把 <code>fileDst</code> 的一个 <code>checksum</code> 列表传给同步源，这个列表里包括了三个东西，<code>rolling checksum</code> (32bits)，<code>md5 checksume</code> (128bits)，<code>文件块编号</code>。同步源机器拿到了这个列表后，会对 <code>fileSrc</code> 做同样的 <code>checksum</code>，然后和 <code>fileDst</code> 的 <code>checksum</code> 做对比，这样就知道哪些文件块改变了。</p>
<p><strong>但是</strong></p>
<p>如果我 <code>fileSrc</code> 这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和 <code>fileDst</code> 这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？
如果这个 <code>checksum</code> 列表特别长，而两边相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？</p>
<h3 id="checksum-查找算法">Checksum 查找算法</h3>
<p>同步源端拿到 <code>fileDst</code> 的 <code>checksum</code> 数组后，会把这个数据存到一个 <code>hash table</code> 中，用 <code>rolling checksum</code> 做 <code>hash</code>，以便获得 <code>O(1)</code> 时间复杂度的查找性能。这个 <code>hash table</code> 是 16 bits 的，所以，<code>hash table</code> 的尺寸是 2 的 16 次方，对 <code>rolling checksum</code> 的 <code>hash</code> 会被散列到 0 到 $ 2^{16} – 1 $ 中的某个整数值。</p>
<h3 id="比对算法">比对算法</h3>
<ol>
<li>
<p>取 <code>fileSrc</code> 的第一个文件块（我们假设的是 512 个长度），也就是从 <code>fileSrc</code> 的第 1 个字节到第 512 个字节，取出来后做 <code>rolling checksum</code> 计算。计算好的值到 <code>hash</code> 表中查询。</p>
</li>
<li>
<p>如果查到了，说明发现在 <code>fileDst</code> 中有潜在相同的文件块，于是就再比较 · 的 <code>checksum</code>，因为 <code>rolling checksume</code> 太弱了，可能发生碰撞。于是还要算 <code>md5</code> 的 128 bits 的 <code>checksum</code>，这样一来，我们就有 $2^{-(32+128)} = 2^{-160} $ 的概率发生碰撞，这小到可以忽略。如果 <code>rolling checksum</code> 和 <code>md5 checksum</code> 都相同，那就可以说明在 <code>fileDst</code> 中有相同的块，记下这一块在 <code>fileDst</code> 下的文件编号。</p>
</li>
<li>
<p>如果 <code>fileSrc</code> 的 <code>rolling checksum</code> 没有在 <code>hash table</code> 中找到，那就不用算 <code>md5 checksum</code> 了。表示这一块中有不同的信息。总之，只要 <code>rolling checksum</code> 或 <code>md5 checksum</code> 其中有一个在 <code>fileDst</code> 的 <code>checksum hash</code> 表中找不到匹配项，那么就会触发算法对 <code>fileSrc</code> 的 rolling 动作。于是，算法会住后 step 1 个字节，取 <code>fileSrc</code> 中字节 2-513 的文件块要做 <code>checksum</code>，然后继续第一步 – 这就是为什么叫 <code>rolling checksum</code> 。</p>
</li>
<li>
<p>这样，我们就可以找出 <code>fileSrc</code> 相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。</p>
</li>
</ol>
<h2 id="rolling-checksum-算法">Rolling Checksum 算法</h2>
<p>rolling checksum 算法也叫 <code>Rabin-Karp</code> 算法，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它用来解决多模式串匹配问题。其最大的精髓是，当往后面 step 1 个字符的时候，不用全部重新计算所有的 <code>checksum</code>，也就是说，从 [0, 512] rolling 到 [1, 513] 时，不需要重新计算从 1 到 513 的 <code>checksum</code>，而是重用 [0，512] 的 <code>checksum</code> 直接算出来。</p>
<p>其公式可以表示为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0
</code></pre></td></tr></table>
</div>
</div><p>其中的 b 是一个常数基数，在 Rabin-Karp 算法中，一般取值为 256。</p>
<p>于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1)  + t[m] * b ^0
</code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg" data-sub-html="<h2>rsync 算法示意</h2>">
        
    </a><figcaption class="image-caption">rsync 算法示意</figcaption>
    </figure>
<p>最终，得到的数据组可以想象为 BT 协议下载 torrent ：一些文件块已下载（匹配上），其他的文件块还未下载（未匹配上）。然后，同步端将这些未匹配上的文件打上标号发送，目的端根据标号重组文件就完成了同步。</p>
<h2 id="使用-rsync">使用 rsync</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">rsync <span class="o">[</span>OPTION<span class="o">]</span>... SRC DEST
rsync <span class="o">[</span>OPTION<span class="o">]</span>... SRC <span class="o">[</span>USER@<span class="o">]</span> host:DEST
rsync <span class="o">[</span>OPTION<span class="o">]</span>... <span class="o">[</span>USER@<span class="o">]</span> HOST:SRC DEST
rsync <span class="o">[</span>OPTION<span class="o">]</span>... <span class="o">[</span>USER@<span class="o">]</span> HOST::SRC DEST
rsync <span class="o">[</span>OPTION<span class="o">]</span>... SRC <span class="o">[</span>USER@<span class="o">]</span> HOST::DEST
rsync <span class="o">[</span>OPTION<span class="o">]</span>... rsync://<span class="o">[</span>USER@<span class="o">]</span> HOST <span class="o">[</span>:PORT<span class="o">]</span>/SRC <span class="o">[</span>DEST<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>对应于以上六种命令格式，<code>rsync</code> 有六种不同的工作模式：</p>
<ul>
<li>
<p>拷贝本地文件。当 <code>SRC</code> 和 <code>DES</code> 路径信息都<strong>不包含</strong>有单个冒号 &ldquo;:&rdquo; 分隔符时就启动这种工作模式。如：<code>rsync -a /data/backup</code></p>
</li>
<li>
<p>使用一个远程 <code>shell</code> 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 <code>DST</code> 路径地址<strong>包含单个</strong>冒号 &ldquo;:&rdquo; 分隔符时启动该模式。如：<code>rsync -avz *.c foo:src</code></p>
</li>
<li>
<p>使用一个远程 <code>shell</code> 程序 (如 <code>rsh</code>、<code>ssh</code>) 来实现将远程机器的内容拷贝到本地机器。当 <code>SRC</code> 地址路径<strong>包含单个</strong>冒号 &ldquo;:&rdquo; 分隔符时启动该模式。如：<code>rsync -avz foo:src/bar/data</code></p>
</li>
<li>
<p>从远程 <code>rsync</code> 服务器中拷贝文件到本地机。当 <code>SRC</code> 路径信息包含 &ldquo;::&rdquo; 分隔符时启动该模式。如：<code>rsync -av root@192.168.78.192::www /databack</code></p>
</li>
<li>
<p>从本地机器拷贝文件到远程 <code>rsync</code> 服务器中。当 <code>DST</code> 路径信息包含 &ldquo;::&rdquo; 分隔符时启动该模式。如：<code>rsync -av /databack root@192.168.78.192::www</code></p>
</li>
<li>
<p>列出远程主机的文件列表。这类似于 <code>rsync</code> 传输，不过只要在命令中省略掉本地机信息即可。如：<code>rsync -v rsync://192.168.78.192/www</code></p>
</li>
</ul>
<p>可用选项如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-v, --verbose 详细模式输出。
-q, --quiet 精简输出模式。
-C, --cvs-exclude 使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。
-c, --checksum 打开校验开关，强制对文件传输进行校验。
-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 - rlptgoD。
-r, --recursive 对子目录以递归模式处理。
-R, --relative 使用相对路径信息。
-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为～filename。可以使用 --suffix 选项来指定不同的备份文件前缀。
-u, --update 仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。
-l, --links 保留软链结。
-L, --copy-links 想对待常规文件一样处理软链结。
-H, --hard-links 保留硬链结。
-I, --ignore-times 不跳过那些有同样的时间和长度的文件。
-p, --perms 保持文件权限。
-o, --owner 保持文件属主信息。
-g, --group 保持文件属组信息。
-D, --devices 保持设备文件信息。
-t, --times 保持文件时间信息。
-S, --sparse 对稀疏文件进行特殊处理以节省 DST 的空间。
-T --temp-dir<span class="o">=</span>DIR 在 DIR 中创建临时文件。
-n, --dry-run 现实哪些文件将被传输。
-w, --whole-file 拷贝文件，不进行增量检测。
-x, --one-file-system 不要跨越文件系统边界。
-B, --block-size<span class="o">=</span>SIZE 检验算法使用的块尺寸，默认是 <span class="m">700</span> 字节。
-e, --rsh<span class="o">=</span><span class="nb">command</span> 指定使用 rsh、ssh 方式进行数据同步。
-P 等同于 --partial。
-z, --compress 对备份的文件在传输时进行压缩处理。
-h, --help 显示帮助信息。
--backup-dir 将备份文件 <span class="o">(</span>如～filename<span class="o">)</span> 存放在在目录下。
-suffix<span class="o">=</span>SUFFIX 定义备份文件前缀。
--copy-unsafe-links 仅仅拷贝指向 SRC 路径目录树以外的链结。
--safe-links 忽略指向 SRC 路径目录树以外的链结。
--rsync-path<span class="o">=</span>PATH 指定远程服务器上的 rsync 命令所在路径信息。
--existing 仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。
--delete 删除那些 DST 中 SRC 没有的文件。
--delete-excluded 同样删除接收端那些被该选项指定排除的文件。
--delete-after 传输结束以后再删除。
--ignore-errors 及时出现 IO 错误也进行删除。
--max-delete<span class="o">=</span>NUM 最多删除 NUM 个文件。
--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。
--force 强制删除目录，即使不为空。
--numeric-ids 不将数字的用户和组 id 匹配为用户名和组名。
--timeout<span class="o">=</span><span class="nb">time</span> ip 超时时间，单位为秒。
--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。
--modify-window<span class="o">=</span>NUM 决定文件是否时间相同时使用的时间戳窗口，默认为 0。
--compare-dest<span class="o">=</span>DIR 同样比较 DIR 中的文件来决定是否需要备份。
--progress 显示备份过程。
--exclude<span class="o">=</span>PATTERN 指定排除不需要传输的文件模式。
--include<span class="o">=</span>PATTERN 指定不排除而需要传输的文件模式。
--exclude-from<span class="o">=</span>FILE 排除 FILE 中指定模式的文件。
--include-from<span class="o">=</span>FILE 不排除 FILE 指定模式匹配的文件。
--version 打印版本信息。
--address 绑定到特定的地址。
--config<span class="o">=</span>FILE 指定其他的配置文件，不使用默认的 rsyncd.conf 文件。
--port<span class="o">=</span>PORT 指定其他的 rsync 服务端口。
--blocking-io 对远程 shell 使用阻塞 IO。
-stats 给出某些文件的传输状态。
--progress 在传输时现实传输过程。
--log-format<span class="o">=</span>formAT 指定日志文件格式。
--password-file<span class="o">=</span>FILE 从 FILE 中得到密码。
--bwlimit<span class="o">=</span>KBPS 限制 I/O 带宽，KBytes per second。
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://rsync.samba.org/tech_report/tech_report.html" target="_blank" rel="noopener noreffer">The rsync algorithm</a></p>
</li>
<li>
<p>[2] <a href="https://coolshell.cn/articles/7425.html" target="_blank" rel="noopener noreffer">RSYNC 的核心算法</a></p>
</li>
<li>
<p>[3] <a href="https://zh.wikipedia.org/wiki/Rsync" target="_blank" rel="noopener noreffer">rsync wikipedia</a></p>
</li>
<li>
<p>[4] <a href="https://ningyu1.github.io/linux-command/c/rsync.html" target="_blank" rel="noopener noreffer">rsync command</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>Git Log 使用技巧</title>
    <link>https://www.techkoala.top/git_log/</link>
    <pubDate>Sat, 01 Aug 2020 22:30:52 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/git_log/</guid>
    <description><![CDATA[<blockquote>
<p>最常用的 Git Log 技巧令总结</p>
</blockquote>
<h2 id="概览提交历史">概览提交历史</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log —oneline
</code></pre></td></tr></table>
</div>
</div><p>该命令帮助您以更清晰的方式查看提交。每个提交仅显示为一行，并且只有最少量的信息，比如提交哈希、提交消息。</p>
<h2 id="显示详细更改信息">显示详细更改信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log -p
</code></pre></td></tr></table>
</div>
</div><p>此命令会显示更新的详细更改信息，方便查阅。</p>
<h2 id="根据时间筛选">根据时间筛选</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --after<span class="o">=</span><span class="s2">&#34;2020-15-05&#34;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --after<span class="o">=</span><span class="s2">&#34;2020-15-05&#34;</span> --before<span class="o">=</span><span class="s2">&#34;2020-25-05&#34;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --after<span class="o">=</span><span class="s2">&#34;yesterday&#34;</span> // 显示昨天的提交

$ git log --after<span class="o">=</span><span class="s2">&#34;today&#34;</span> // 显示今天的提交

$ git log --before<span class="o">=</span><span class="s2">&#34;10 day ago&#34;</span> // 显示最近十天的提交

$ git log --after<span class="o">=</span><span class="s2">&#34;1 week ago&#34;</span> // 显示上周以来的提交

$ git log --after<span class="o">=</span><span class="s2">&#34;2 month ago&#34;</span> // 显示近两个月的提交
</code></pre></td></tr></table>
</div>
</div><p>上述命令将按给定的时间段过滤出提交。 例如，<code>--after</code> 将仅筛选给定时间段之后的提交，而 <code>--before</code> 将仅筛选给定时间段之前的提交。</p>
<h2 id="根据作者筛选">根据作者筛选</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --author<span class="o">=</span><span class="s2">&#34;techkoala&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>该命令会显示由 techkoala 提交的更改。当然，可以结合上面介绍的命令，进行更加精确的筛选，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --after<span class="o">=</span><span class="s2">&#34;1 week ago&#34;</span> --author<span class="o">=</span><span class="s2">&#34;techkoala&#34;</span> -p
</code></pre></td></tr></table>
</div>
</div><h2 id="根据-log-信息筛选">根据 log 信息筛选</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --grep<span class="o">=</span><span class="s2">&#34;ISSUE-43560&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>需要注意的是，上述筛选字段区分大小写，如果需要不区分，请加上 <code>-i</code> 选项。</p>
<p>此外，还支持正则表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log -i --grep<span class="o">=</span><span class="s2">&#34;issue-43560\|issue-89786&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="根据文件筛选">根据文件筛选</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log Git_Log.md
</code></pre></td></tr></table>
</div>
</div><p>该命令显示针对特定文件的的提交历史。</p>
<p>当然，可以传入多个文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log Git_Log.md Github_Issue.md
</code></pre></td></tr></table>
</div>
</div><p>同样的，结合别的命令可以做出更精确的筛选，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log -i --grep<span class="o">=</span><span class="s2">&#34;fix &#34;</span> Git_Log.md Github_Issue.md
</code></pre></td></tr></table>
</div>
</div><h2 id="根据文件内容筛选">根据文件内容筛选</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log -S<span class="s2">&#34;function login()&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>上述命令帮你在源代码中搜索已添加到提交历史记录中的特定字符串。同样的，加上 <code>-i</code> 可以不区分大小写。</p>
<h2 id="仅显示合并提交">仅显示合并提交</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --merges
</code></pre></td></tr></table>
</div>
</div><p>该命令显示当前分支上合并的提交。</p>
<h2 id="显示不同分支间的区别">显示不同分支间的区别</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log master..develop
</code></pre></td></tr></table>
</div>
</div><p>该命令将显示所有来自 <code>develop</code> 但不在 <code>master</code> 分支的提交。</p>
<h2 id="自定义-log-信息格式">自定义 log 信息格式</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ git log --pretty<span class="o">=</span>format:<span class="s2">&#34;%Cred%an - %ar%n %Cblue %h -%Cgreen %s %n&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Git提供了用于自定义日志消息格式的选项，你可以查看自定义漂亮选项（custom pretty options ）以获得更多选项。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://hackernoon.com/ten-useful-git-log-tricks-7nt3yxy" target="_blank" rel="noopener noreffer">Ten Useful Git Log Tricks</a></p>
</li>
<li>
<p>[2] <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener noreffer">Git 基础 - 查看提交历史</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>逐步详解 SHA-2 算法（以 SHA-256 为例）</title>
    <link>https://www.techkoala.top/learn_sha_2_step_by_step/</link>
    <pubDate>Tue, 28 Jul 2020 16:19:03 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/learn_sha_2_step_by_step/</guid>
    <description><![CDATA[<blockquote>
<p>最常见的 SHA-2 算法是如何实现的？本文逐步为你讲解。</p>
</blockquote>
<p><code>SHA-2</code> (Secure Hash Algorithm 2)，是最流行的哈希算法之一，包括了：<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>、<code>SHA-512</code>、<code>SHA-512/224</code>、<code>SHA-512/256</code>。这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。</p>
<p><code>SHA-2</code> 以安全和速度著称，在未生成密钥的情况下（例如挖掘比特币），像 <code>SHA-2</code> 这样的快速哈希算法通常占据上风。</p>
<h2 id="哈希函数hash-function">哈希函数（Hash Function）</h2>
<p>如果，你还不清楚哈希是什么，可以参见我的<a href="http://techkoala.top/hash_functions/" target="_blank" rel="noopener noreffer">另外一篇文章</a></p>
<p>简单来说，哈希函数的拥有如下三个重要特性：</p>
<ul>
<li>
<p>哈希函数对数据进行确定性加扰。</p>
</li>
<li>
<p>无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。</p>
</li>
<li>
<p>无法从加扰数据中检索原始数据（单向函数）。</p>
</li>
</ul>
<h2 id="sha-2-vs-sha-256">SHA-2 vs SHA-256</h2>
<p>有人可能会困惑：欸？我平时看到的都是 <code>SHA-128</code>、<code>SHA-256</code> 等等，这个 <code>SHA-2</code> 又是什么？</p>
<p><code>SHA-2</code> 是一种算法，一种关于如何哈希数据的广义思想。<code>SHA-256</code> 设置了定义 <code>SHA-2</code> 算法行为的附加常量。其中一个常量是输出大小，“256” 和 “512” 是指它们各自的输出摘要大小（以位为单位）。</p>
<h2 id="逐步详解-sha-256">逐步详解 SHA-256</h2>
<p>接下来举例说明 SHA-256 如何工作:</p>
<h3 id="第一步消息预处理">第一步：消息预处理</h3>
<ol>
<li>
<p>将 <code>hello world</code> 转换为二进制</p>
<blockquote>
<p>01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100</p>
</blockquote>
</li>
<li>
<p>尾部追加单独的 <code>1</code></p>
<blockquote>
<p>01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 <strong>1</strong></p>
</blockquote>
</li>
<li>
<p>填充 0 直到数据为 512 的整数倍，再减去 64 位（在本例中剩下 448 位）：</p>
<blockquote>
<p>01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111</p>
<p>01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
</blockquote>
</li>
<li>
<p>在末尾附加新的 64 位，这 64 位是一个大端整数，用于表示原始二进制输入的长度。在本文的例子中，是 <code>88</code>，或者二进制，<code>1011000</code>。</p>
<blockquote>
<p>01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111</p>
<p>01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000000 00000000 00000000 00000000 01011000</p>
</blockquote>
</li>
</ol>
<p>现在，得到了初始的输入值（通过对消息进行补位处理，最终的长度应该是 512 位的倍数）。</p>
<h3 id="第二步初始化哈希值h">第二步：初始化哈希值（h）</h3>
<p>现在，初始化 8 个哈希值。这些是硬编码的常数，分别代表前 8 个素数（2、3、5、7、11、13、17、19）的平方根的小数部分的前 32 位：</p>
<blockquote>
<p>h0 := 0x6a09e667</p>
<p>h1 := 0xbb67ae85</p>
<p>h2 := 0x3c6ef372</p>
<p>h3 := 0xa54ff53a</p>
<p>h4 := 0x510e527f</p>
<p>h5 := 0x9b05688c</p>
<p>h6 := 0x1f83d9ab</p>
<p>h7 := 0x5be0cd19</p>
</blockquote>
<h3 id="第三步初始化圆常数k">第三步：初始化圆常数(k)</h3>
<p>与步骤 2 类似，初始化一些常量，一共有 64 个。每个值（0-63）是前 64 个素数（2-311）的立方根分数部分的前 32 位。</p>
<blockquote>
<p>0x428a2f98 0x71374491 0xb5c0fbcf 0xe9b5dba5 0x3956c25b 0x59f111f1</p>
<p>0x923f82a4 0xab1c5ed5 0xd807aa98 0x12835b01 0x243185be 0x550c7dc3</p>
<p>0x72be5d74 0x80deb1fe 0x9bdc06a7 0xc19bf174 0xe49b69c1 0xefbe4786</p>
<p>0x0fc19dc6 0x240ca1cc 0x2de92c6f 0x4a7484aa 0x5cb0a9dc 0x76f988da</p>
<p>0x983e5152 0xa831c66d 0xb00327c8 0xbf597fc7 0xc6e00bf3 0xd5a79147</p>
<p>0x06ca6351 0x14292967 0x27b70a85 0x2e1b2138 0x4d2c6dfc 0x53380d13</p>
<p>0x650a7354 0x766a0abb 0x81c2c92e 0x92722c85 0xa2bfe8a1 0xa81a664b</p>
<p>0xc24b8b70 0xc76c51a3 0xd192e819 0xd6990624 0xf40e3585 0x106aa070</p>
<p>0x19a4c116 0x1e376c08 0x2748774c 0x34b0bcb5 0x391c0cb3 0x4ed8aa4a</p>
<p>0x5b9cca4f 0x682e6ff3 0x748f82ee 0x78a5636f 0x84c87814 0x8cc70208</p>
<p>0x90befffa 0xa4506ceb 0xbef9a3f7 0xc67178f2</p>
</blockquote>
<h3 id="第四步块循环">第四步：块循环</h3>
<p>对输入的每 512 位分为一块，执行以下步骤：</p>
<p><strong>注：</strong> 在本文的例子中，因为 “hello world” 太短了，所以只有一个块。在循环的每一次迭代中，都将对哈希值 h0-h7 进行变更，最终作为结果输出。</p>
<h3 id="第五步重组信息数组w">第五步：重组信息数组（w）</h3>
<ol>
<li>
<p>将步骤 1 中的输入数据重新排列到新数组中，其中每个条目都是一个 32 位字：</p>
<blockquote>
<p>01101000011001010110110001101100 01101111001000000111011101101111</p>
<p>01110010011011000110010010000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000001011000</p>
</blockquote>
</li>
<li>
<p>再加上 48 个初始化为零的字，这样就有了一个数组 <strong>w [0…63]</strong></p>
<blockquote>
<p>01101000011001010110110001101100 01101111001000000111011101101111</p>
<p>01110010011011000110010010000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000001011000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>&hellip; &hellip;</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
</blockquote>
</li>
<li>
<p>使用以下算法修改数组末尾的零索引：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">For i from w[16…63]:
    s0 = (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)

    s1 = (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10)

    w[i] = w[i-16] + s0 + w[i-7] + s1
</code></pre></td></tr></table>
</div>
</div><p>以 w[16] 举例说明：</p>
<blockquote>
<p>w[1] rightrotate 7:</p>
<p>01101111001000000111011101101111 -&gt; 11011110110111100100000011101110</p>
</blockquote>
<blockquote>
<p>w[1] rightrotate 18:</p>
<p>01101111001000000111011101101111 -&gt; 00011101110110111101101111001000</p>
</blockquote>
<blockquote>
<p>w[1] rightshift 3:</p>
<p>01101111001000000111011101101111 -&gt; 00001101111001000000111011101101</p>
</blockquote>
<blockquote>
<p>s0 = 11011110110111100100000011101110</p>
<p><strong>XOR</strong> 00011101110110111101101111001000</p>
<p><strong>XOR</strong> 00001101111001000000111011101101</p>
<p>= 11001110111000011001010111001011</p>
</blockquote>
<blockquote>
<p>w[14] rightrotate 17:</p>
<p>00000000000000000000000000000000 -&gt; 00000000000000000000000000000000</p>
</blockquote>
<blockquote>
<p>w[14] rightrotate19:</p>
<p>00000000000000000000000000000000 -&gt; 00000000000000000000000000000000</p>
</blockquote>
<blockquote>
<p>w[14] rightshift 10:</p>
<p>00000000000000000000000000000000 -&gt; 00000000000000000000000000000000</p>
</blockquote>
<blockquote>
<p>s1 = 00000000000000000000000000000000</p>
<p><strong>XOR</strong> 00000000000000000000000000000000</p>
<p><strong>XOR</strong> 00000000000000000000000000000000</p>
<p>= 00000000000000000000000000000000</p>
</blockquote>
<blockquote>
<p>w[16] = w[0] + s0 + w[9] + s1</p>
<p>= 01101000011001010110110001101100 <br>
+ 11001110111000011001010111001011 <br>
+ 00000000000000000000000000000000 <br>
+ 00000000000000000000000000000000 <br>
= 00110111010001110000001000110111</p>
<p>// addition is calculated modulo $ 2^{32} $</p>
</blockquote>
<p>总的结果就是：</p>
<blockquote>
<p>01101000011001010110110001101100 01101111001000000111011101101111</p>
<p>01110010011011000110010010000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000000000000</p>
<p>00000000000000000000000000000000 00000000000000000000000001011000</p>
<p>00110111010001110000001000110111 10000110110100001100000000110001</p>
<p>11010011101111010001000100001011 01111000001111110100011110000010</p>
<p>00101010100100000111110011101101 01001011001011110111110011001001</p>
<p>00110001111000011001010001011101 10001001001101100100100101100100</p>
<p>01111111011110100000011011011010 11000001011110011010100100111010</p>
<p>10111011111010001111011001010101 00001100000110101110001111100110</p>
<p>10110000111111100000110101111101 01011111011011100101010110010011</p>
<p>00000000100010011001101101010010 00000111111100011100101010010100</p>
<p>00111011010111111110010111010110 01101000011001010110001011100110</p>
<p>11001000010011100000101010011110 00000110101011111001101100100101</p>
<p>10010010111011110110010011010111 01100011111110010101111001011010</p>
<p>11100011000101100110011111010111 10000100001110111101111000010110</p>
<p>11101110111011001010100001011011 10100000010011111111001000100001</p>
<p>11111001000110001010110110111000 00010100101010001001001000011001</p>
<p>00010000100001000101001100011101 01100000100100111110000011001101</p>
<p>10000011000000110101111111101001 11010101101011100111100100111000</p>
<p>00111001001111110000010110101101 11111011010010110001101111101111</p>
<p>11101011011101011111111100101001 01101010001101101001010100110100</p>
<p>00100010111111001001110011011000 10101001011101000000110100101011</p>
<p>01100000110011110011100010000101 11000100101011001001100000111010</p>
<p>00010001010000101111110110101101 10110000101100000001110111011001</p>
<p>10011000111100001100001101101111 01110010000101111011100000011110</p>
<p>10100010110101000110011110011010 00000001000011111001100101111011</p>
<p>11111100000101110100111100001010 11000010110000101110101100010110</p>
</blockquote>
</li>
</ol>
<h3 id="第六步压缩">第六步：压缩</h3>
<ol>
<li>
<p>初始化变量 a，b，c，d，e，f，g，h，并将它们分别设置为等于当前的哈希值：h0，h1，h2，h3，h4，h5，h6，h7</p>
</li>
<li>
<p>进行压缩循环。 压缩循环将改变 a…h 的值。压缩循环如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">for i from 0 to 63:
    S1 = (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
    ch = (e and f) xor ((not e) and g)
    temp1 = h + S1 + ch + k[i] + w[i]
    S0 = (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
    maj = (a and b) xor (a and c) xor (b and c)
    temp2 := S0 + maj
    h = g
    g = f
    e = d + temp1
    d = c
    c = b
    b = a
    a = temp1 + temp2
</code></pre></td></tr></table>
</div>
</div><p>下面演示第一次迭代，所有加法都是以 $ 2^{32} $ 为模的：</p>
<blockquote>
<p>a = 0x6a09e667 = 01101010000010011110011001100111</p>
<p>b = 0xbb67ae85 = 10111011011001111010111010000101</p>
<p>c = 0x3c6ef372 = 00111100011011101111001101110010</p>
<p>d = 0xa54ff53a = 10100101010011111111010100111010</p>
<p>e = 0x510e527f = 01010001000011100101001001111111</p>
<p>f = 0x9b05688c = 10011011000001010110100010001100</p>
<p>g = 0x1f83d9ab = 00011111100000111101100110101011</p>
<p>h = 0x5be0cd19 = 01011011111000001100110100011001</p>
</blockquote>
<blockquote>
<p>e rightrotate 6:</p>
<p>01010001000011100101001001111111 -&gt; 11111101010001000011100101001001</p>
</blockquote>
<blockquote>
<p>e rightrotate 11:</p>
<p>01010001000011100101001001111111 -&gt; 01001111111010100010000111001010</p>
</blockquote>
<blockquote>
<p>e rightrotate 25:</p>
<p>01010001000011100101001001111111 -&gt; 10000111001010010011111110101000</p>
</blockquote>
<blockquote>
<p>S1 = 11111101010001000011100101001001</p>
<p><strong>XOR</strong> 01001111111010100010000111001010</p>
<p><strong>XOR</strong> 10000111001010010011111110101000</p>
<p>= 00110101100001110010011100101011</p>
</blockquote>
<blockquote>
<p>e and f:</p>
<p>01010001000011100101001001111111
&amp; 10011011000001010110100010001100 =
00010001000001000100000000001100</p>
</blockquote>
<blockquote>
<p>not e:</p>
<p>01010001000011100101001001111111 -&gt; 10101110111100011010110110000000</p>
</blockquote>
<blockquote>
<p>(not e) and g:</p>
<p>10101110111100011010110110000000
&amp; 00011111100000111101100110101011
= 00001110100000011000100110000000</p>
</blockquote>
<blockquote>
<p>ch = (e and f) xor ((not e) and g)</p>
<p>= 00010001000001000100000000001100</p>
<p><strong>XOR</strong> 00001110100000011000100110000000</p>
<p>= 00011111100001011100100110001100</p>
</blockquote>
<blockquote>
<p>// k[i] 是圆常数</p>
<p>// w[i] 信息数组</p>
</blockquote>
<blockquote>
<p>temp1 = h + S1 + ch + k[i] + w[i]</p>
<p>= 01011011111000001100110100011001
+ 00110101100001110010011100101011
+ 00011111100001011100100110001100
+ 1000010100010100010111110011000
+ 01101000011001010110110001101100
= 01011011110111010101100111010100</p>
</blockquote>
<blockquote>
<p>a rightrotate 2:</p>
<p>01101010000010011110011001100111 -&gt; 11011010100000100111100110011001</p>
</blockquote>
<blockquote>
<p>a rightrotate 13:</p>
<p>01101010000010011110011001100111 -&gt; 00110011001110110101000001001111</p>
</blockquote>
<blockquote>
<p>a rightrotate 22:</p>
<p>01101010000010011110011001100111 -&gt; 00100111100110011001110110101000</p>
</blockquote>
<blockquote>
<p>S0 = 11011010100000100111100110011001</p>
<p><strong>XOR</strong> 00110011001110110101000001001111</p>
<p><strong>XOR</strong> 00100111100110011001110110101000</p>
<p>= 11001110001000001011010001111110</p>
</blockquote>
<blockquote>
<p>a and b:</p>
<p>01101010000010011110011001100111
&amp; 10111011011001111010111010000101 =
00101010000000011010011000000101</p>
</blockquote>
<blockquote>
<p>a and c:</p>
<p>01101010000010011110011001100111
&amp; 00111100011011101111001101110010 =
00101000000010001110001001100010</p>
</blockquote>
<blockquote>
<p>b and c:</p>
<p>10111011011001111010111010000101
&amp; 00111100011011101111001101110010 =
00111000011001101010001000000000</p>
</blockquote>
<blockquote>
<p>maj = (a and b) xor (a and c) xor (b and c)</p>
<p>= 00101010000000011010011000000101</p>
<p><strong>XOR</strong> 00101000000010001110001001100010</p>
<p><strong>XOR</strong> 00111000011001101010001000000000</p>
<p>= 00111010011011111110011001100111</p>
</blockquote>
<blockquote>
<p>temp2 = S0 + maj
= 11001110001000001011010001111110 + 00111010011011111110011001100111
= 00001000100100001001101011100101</p>
</blockquote>
<blockquote>
<p>h = 00011111100000111101100110101011</p>
<p>g = 10011011000001010110100010001100</p>
<p>f = 01010001000011100101001001111111</p>
<p>e = 10100101010011111111010100111010 + 01011011110111010101100111010100
= 00000001001011010100111100001110</p>
<p>d = 00111100011011101111001101110010</p>
<p>c = 10111011011001111010111010000101</p>
<p>b = 01101010000010011110011001100111</p>
<p>a = 01011011110111010101100111010100 + 00001000100100001001101011100101
= 01100100011011011111010010111001</p>
</blockquote>
<p>整个计算会继续循环进行了 63 次，期间不断修改了变量 a-h 的值。最终结果为：</p>
<blockquote>
<p>a = 4F434152 = 001001111010000110100000101010010</p>
<p>b = D7E58F83 = 011010111111001011000111110000011</p>
<p>c = 68BF5F65 = 001101000101111110101111101100101</p>
<p>d = 352DB6C0 = 000110101001011011011011011000000</p>
<p>e = 73769D64 = 001110011011101101001110101100100</p>
<p>f = DF4E1862 = 011011111010011100001100001100010</p>
<p>g = 71051E01 = 001110001000001010001111000000001</p>
<p>h = 870F00D0 = 010000111000011110000000011010000</p>
</blockquote>
</li>
</ol>
<h3 id="第七步修改最终值">第七步：修改最终值</h3>
<p>压缩循环完成后，仍然处于在块循环中，通过向哈希值中添加它们各自的变量 a-h 来修改哈希值。同样的，所有的加法都是模 $ 2^{32} $。</p>
<blockquote>
<p>h0 = h0 + a = 10111001010011010010011110111001</p>
<p>h1 = h1 + b = 10010011010011010011111000001000</p>
<p>h2 = h2 + c = 10100101001011100101001011010111</p>
<p>h3 = h3 + d = 11011010011111011010101111111010</p>
<p>h4 = h4 + e = 11000100100001001110111111100011</p>
<p>h5 = h5 + f = 01111010010100111000000011101110</p>
<p>h6 = h6 + g = 10010000100010001111011110101100</p>
<p>h7 = h7 + h = 11100010111011111100110111101001</p>
</blockquote>
<h3 id="第八步-组成最终的哈希值">第八步: 组成最终的哈希值</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">digest = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7
       = B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9
</code></pre></td></tr></table>
</div>
</div><p>搞定！至此，本文非常详细地实现了 SHA-256 中的每一步🙂。</p>
<h2 id="附录">附录</h2>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Algorithm/SHA-2/SHA-2.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Algorithm/SHA-2/SHA-2.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Algorithm/SHA-2/SHA-2.png" data-sub-html="<h2>SHA-2 的第 t 个加密循环</h2>">
        
    </a><figcaption class="image-caption">SHA-2 的第 t 个加密循环</figcaption>
    </figure>
<p>下面这段<strong>伪代码</strong>总结了上面执行的所有步骤：</p>
<blockquote>
<p>注 1：所有变量均为 32 位无符号整数，加法以 $ 2^{32} $ 为模</p>
<p>注 2：对于每一轮，在消息调度数组 w [i]，0≤i≤63 中有一个循环常数 k [i] 和一个条目。</p>
<p>注 3：压缩函数使用 8 个工作变量，a 到 h。</p>
<p>注 4：在此伪代码中表示常量时使用大端约定，并且当将消息块数据从字节解析到字时，例如，填充后的输入消息 “abc” 的第一个字是 0x61626380</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Initialize hash values:
(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
h0 := 0x6a09e667
h1 := 0xbb67ae85
h2 := 0x3c6ef372
h3 := 0xa54ff53a
h4 := 0x510e527f
h5 := 0x9b05688c
h6 := 0x1f83d9ab
h7 := 0x5be0cd19

Initialize array of round constants:
(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):
k[0..63] :=
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2

Pre-processing (Padding):
begin with the original message of length L bits
append a single &#39;1&#39; bit
append K &#39;0&#39; bits, where K is the minimum number &gt;= 0 such that L + 1 + K + 64 is a multiple of 512
append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits

Process the message in successive 512-bit chunks:
break message into 512-bit chunks
for each chunk
    create a 64-entry message schedule array w[0..63] of 32-bit words
    (The initial values in w[0..63] don&#39;t matter, so many implementations zero them here)
    copy chunk into first 16 words w[0..15] of the message schedule array

    Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
    for i from 16 to 63
        s0 := (w[i-15] rightrotate  7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift  3)
        s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10)
        w[i] := w[i-16] + s0 + w[i-7] + s1

    Initialize working variables to current hash value:
    a := h0
    b := h1
    c := h2
    d := h3
    e := h4
    f := h5
    g := h6
    h := h7

    Compression function main loop:
    for i from 0 to 63
        S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
        ch := (e and f) xor ((not e) and g)
        temp1 := h + S1 + ch + k[i] + w[i]
        S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
        maj := (a and b) xor (a and c) xor (b and c)
        temp2 := S0 + maj
 
        h := g
        g := f
        f := e
        e := d + temp1
        d := c
        c := b
        b := a
        a := temp1 + temp2

    Add the compressed chunk to the current hash value:
    h0 := h0 + a
    h1 := h1 + b
    h2 := h2 + c
    h3 := h3 + d
    h4 := h4 + e
    h5 := h5 + f
    h6 := h6 + g
    h7 := h7 + h

Produce the final hash value (big-endian):
digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://qvault.io/2020/07/08/how-sha-2-works-step-by-step-sha-256/" target="_blank" rel="noopener noreffer">How SHA-2 Works Step-By-Step (SHA-256)</a></p>
</li>
<li>
<p>[2] <a href="https://en.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener noreffer">SHA-2</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>哈希函数简介</title>
    <link>https://www.techkoala.top/hash_functions/</link>
    <pubDate>Sat, 25 Jul 2020 16:30:31 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/hash_functions/</guid>
    <description><![CDATA[<blockquote>
<p>哈希函数入门介绍。</p>
</blockquote>
<h2 id="哈希函数hash-function用来做什么">哈希函数（Hash Function）用来做什么？</h2>
<p>哈希函数，又称散列函数，广泛应用于互联网的各处，包括但不限于安全地存储密码、查找重复记录、快速存储和检索数据等。例如，Qvault 应用使用哈希将主密码扩展为私人加密密钥。你还可以 <a href="https://en.wikipedia.org/wiki/Hash_function#Uses" target="_blank" rel="noopener noreffer">点击这里</a> 查看哈希函数用于何处。</p>
<h2 id="重要特性">重要特性</h2>
<p>哈希函数的拥有如下三个重要特性，这些特性可以说是最重要的特性：</p>
<ul>
<li>
<p>哈希函数对数据进行确定性加扰。</p>
</li>
<li>
<p>无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。</p>
</li>
<li>
<p>无法从加扰数据中检索原始数据（单向函数）。</p>
</li>
</ul>
<h3 id="确定性加扰">确定性加扰</h3>
<p>想象一下，如果随机扭动一个魔方，到最后会得到一些和开始时不一样的东西。但是，如果重新开始，并做完全相同的一系列动作，那么将能够反复得到完全相同的结果。尽管结果可能看起来是随机的，但它其实是严格按照一定的规则进行变幻地，这就是<strong>确定性加扰</strong>的含义。</p>
<p>确定性对于安全存储密码很重要。例如，假设我的密码是 <code>iLoveBitcoin</code>，我可以使用哈希函数对其进行加扰：</p>
<blockquote>
<p>iLoveBitcoin → &ldquo;2f5sfsdfs5s1fsfsdf98ss4f84sfs6d5fs2d1fdf15&rdquo;</p>
</blockquote>
<p>现在，任何人看到加扰后的版本，他们都不会知道我的原始密码！这一点很重要，因为这意味着作为一个网站开发人员，我只需要存储我用户密码的哈希(加扰数据)就可以验证它们。当用户注册时，我将用户密码进行哈希运算然后将其存储在我的数据库中。当用户登录时，我只是对他们输入的内容再次进行哈希运算，并比较两个哈希值。因为给定的输入总是生成相同的哈希值，所以能够很方便地进行验证。</p>
<h3 id="输出定长">输出定长</h3>
<p>如果对<strong>单个单词</strong>进行哈希处理，则输出将具有一定的大小（对于 <code>SHA-256</code>，则为特定的哈希函数，大小为 256 位）。即便我对<strong>一本书</strong>进行哈希处理，输出同样将是相同的大小。</p>
<p>这是另一个重要的功能，因为它可以节省我们的计算时间。 一个典型的例子是使用哈希作为数据映射中的键。 数据映射是计算机科学中用来存储数据的一种简单结构。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Algorithm/Hash/key-map.webp" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Algorithm/Hash/key-map.webp" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Algorithm/Hash/key-map.webp" data-sub-html="<h2>数据映射</h2>">
        
    </a><figcaption class="image-caption">数据映射</figcaption>
    </figure>
<p>当程序在映射中存储数据时，会为映射指定一个键和值。当程序想要访问该值时，它只要提供适当的键就能接收相应的值。数据映射很好，因为它们可以立即找到数据。计算机通过键可以立即找到对应的值，而不是花费数小时在数百万条记录中搜索。</p>
<p>因为键类似于地址，所以它们不能太大。如果我想将图书存储在数据映射中，我可以对图书的内容进行哈希，并使用该哈希作为键。</p>
<h2 id="哈希处理如何进行">哈希处理如何进行？</h2>
<p>接下来，以 <code>LANEHASH</code> 算法为例，简要讲解哈希处理是如何完成的。</p>
<ol>
<li>
<p>首先，选取下面的数据进行哈希处理</p>
<blockquote>
<p>iLoveBitcoin</p>
</blockquote>
</li>
<li>
<p>将字母转换成二进制</p>
<blockquote>
<p>iLoveBitcoin→ 100010100000101111</p>
</blockquote>
<p><strong>注:</strong> 在这一步中，我们通过各种预定的步骤来转换我们的原始数据。转换方式可以采用各种方式，但重要的是，每当我们使用 LANEHASH 时，都需要使用相同的步骤，以便我们的算法是确定性的。</p>
</li>
<li>
<p>将比特前四位从左移到右边</p>
<blockquote>
<p><strong>1000</strong>10100000101111 → 10100000101111<strong>1000</strong></p>
</blockquote>
</li>
<li>
<p>奇偶分离比特</p>
<blockquote>
<p><strong>1</strong>0<strong>1</strong>0<strong>0</strong>0<strong>0</strong>0<strong>1</strong>0<strong>1</strong>1<strong>1</strong>1<strong>1</strong>0<strong>0</strong>0 → 110011110 &amp; 000001100</p>
</blockquote>
</li>
<li>
<p>分别转化为十进制数</p>
<blockquote>
<p>110011110 → 414</p>
</blockquote>
<blockquote>
<p>000001100→ 12</p>
</blockquote>
</li>
<li>
<p>两数相乘</p>
<blockquote>
<p>414 *12 = 4968</p>
</blockquote>
</li>
<li>
<p>乘积平方</p>
<blockquote>
<p>4968 ^ 2 = 24681024</p>
</blockquote>
</li>
<li>
<p>再次转换为二进制</p>
<blockquote>
<p>24681024 →1011110001001101001000000</p>
</blockquote>
</li>
<li>
<p>剥离右边的9个比特以得到16位比特</p>
<blockquote>
<p>1011110001001101<strong>001000000</strong> → 1011110001001101</p>
</blockquote>
</li>
<li>
<p>转换回字母/数字</p>
<blockquote>
<p>1011110001001101 → &ldquo;8sj209dsns02k2&rdquo;</p>
</blockquote>
</li>
</ol>
<p>正如你所看到的，如果在开始时使用相同的单词，则在结束时将始终得到相同的输出。然而，即使你改了一个字母，结果也会发生很大的变化。</p>
<h2 id="注意">注意</h2>
<p>本文中英文和二进制之间的相互转换并没有遵循任何模式，请读者不要纠结于这一点。当然，实际中，有很多方法用于将我们熟知的字符（例如中文、英语等）转换为二进制（十六进制），如果感兴趣，可以点击下面的参考中的内容</p>
<h2 id="总结">总结</h2>
<p>哈希函数实际上就是按照特定的规则将数据进行一系列转换，最后得到一串键值用来代替/指代原始数据，但是需要注意的是，哈希函数需要满足确定性、定长性、不可逆性。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://qvault.io/2020/01/01/very-basic-intro-to-hash-functions-sha-256-md-5-etc/" target="_blank" rel="noopener noreffer">(Very) Basic Intro to Hash Functions (SHA-256, MD5, etc)</a></p>
</li>
<li>
<p>[2] <a href="https://en.wikipedia.org/wiki/Hash_function#Uses" target="_blank" rel="noopener noreffer">Hash Function</a></p>
</li>
<li>
<p>[3] <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener noreffer">ASCII</a></p>
</li>
<li>
<p>[4] <a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener noreffer">Unicode</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>文件传输 1：SCP</title>
    <link>https://www.techkoala.top/scp/</link>
    <pubDate>Sat, 18 Jul 2020 10:28:05 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/scp/</guid>
    <description><![CDATA[<blockquote>
<p>SCP 就是 SSH 协议的文件传输功能吗？</p>
</blockquote>
<h2 id="什么是-scp">什么是 SCP</h2>
<p>SCP（Secure Copy Protocol，安全复制协议）允许我们在两台计算机之间复制文件（和目录）。</p>
<p>使用起来特别方便：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Shell" data-lang="Shell">$ scp local_file remote_host:/home
</code></pre></td></tr></table>
</div>
</div><p>这将把本地文件 <code>localfile</code> 复制到远程主机的 <code>/home</code> 文件之下。</p>
<p><code>SCP</code> 使用起来特别便利，因为他能工作在几乎所有的 <code>Unix-like</code> 的系统中，并且 <code>Windows</code> 下拥有许多客户端。但是仅仅复制文件并不是关键。<code>SCP</code> 真正的价值是对 <strong>计算机的身份进行验证</strong> 以及对 <strong>传输文件进行加密</strong>（也就是 S 代表的含义）。</p>
<p>使用前需要首先配置到远程主机的 <code>SSH</code> 连接权限。<code>SCP</code> 的验证提示和 SSH 看起很像，因为 <code>SCP</code> 跑在 <code>SSH</code> 的上层，仅仅把它作为文件数据的管道。事实上，<code>SSH</code> 负责处理所有安全相关的任务，<code>SCP</code> 只是将一些文件扔到 <code>SSH</code> 连接上。</p>
<p>维基百科上的条目讲述了 <code>SCP</code> 的历史，简而言之：在旧的 <code>BSD</code> 系统上曾经有一个叫 <code>RCP</code> 的工具，可以在电脑之间移动文件。在当时受信任的网络时代，每个人都是别人的朋友。后来人们意识到，也许并不是每个人在他们的网络上都是这么好的朋友。于是有人把 <code>RCP</code> 的实现复制到 <code>OpenSSH</code> 的前身上，然后简单地在 <code>SSH</code> 会话上运行它，以保护文件不被非好友发现。问题解决了！从此以后，它就留在了 <code>OpenSSH</code> 中。</p>
<h2 id="scp-工作原理">SCP 工作原理</h2>
<p><code>SCP</code> 并不是一个标准协议，并没有一个 <code>RFC</code> 或者任何官方描述如何实现它。<code>OpenSSH</code> 实现是一个事实上的规范。此实现有两个部分：连接建立和之后的传输协议。</p>
<h3 id="建立连接">建立连接</h3>
<p>实际上，这并不是真正的连接。因为它只是利用 <code>SSH</code> 执行命令后的 <code>STDIN/STDOUT</code> ，有点类似 <code>Unix</code> 管道。<code>OpenSSH</code> 中包含两个程序来完成:<code>sshd</code> 和 <code>scp</code>。<code>sshd</code> 是始终运行的服务器守护进程，接受新的 <code>SSH</code> 连接。<code>SCP</code> 是伪装成 <code>SSH</code> 的客户端程序，发送和接受文件。</p>
<p>当 <code>SCP</code> 运行时，他将开启一个新的 <code>SSH</code> 连接。在该连接上，它会在服务端执行另一个带有特殊标志的 <code>SCP</code> 程序。你可以认为是 <code>ssh exec scp [flags]</code>。主要的标志包含 <code>-t</code>（&ldquo;to&rdquo;）和 <code>-f</code>（&ldquo;from&rdquo;）用于代表接受和发送，而 <code>-d</code> 表示文件夹，<code>-r</code> 表示递归。</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png" data-sub-html="<h2>建立连接</h2>">
        
    </a><figcaption class="image-caption">建立连接</figcaption>
    </figure>
<p>值得注意的是，<code>SCP</code> 协议是单向的，一端发送文件，另一端接收文件。在远程端 <code>SCP</code> 开始运行后，实际的 <code>SCP</code> 协议命令开始通过 <code>STDIN</code> 和 <code>STDOUT</code> 运行。</p>
<h3 id="传输协议">传输协议</h3>
<p>现在，安全的 I/O 通道建立起来，并且已经有效地切换到 <code>RCP</code> 协议上。该协议是 <strong>顺序</strong>（一次一个操作）和 <strong>同步</strong>（每个命令执行完后才执行下一个命令）执行的。</p>
<p>命令格式大致为（不带括号或空格）：<code>[command type][arguments]\n [optional data]</code></p>
<ul>
<li>
<p>[command type] 通常是一个 ASCII 字符：</p>
<ul>
<li>&lsquo;C&rsquo;- 写入文件</li>
<li>&lsquo;D&rsquo;- 输入目录</li>
<li>&lsquo;E&rsquo;- 退出最后一个目录</li>
<li>&lsquo;T&rsquo;- 设置下一个文件或目录的创建 / 更新时间戳</li>
</ul>
</li>
<li>
<p>[arguments] 是特定于命令的，如文件 / 目录名称、文件大小或时间戳。&ldquo;E&rdquo; 命令没有参数。</p>
</li>
<li>
<p>[optional data] 在上一个命令为 &ldquo;C&rdquo;（创建文件）时发送。数据的大小指定为 &ldquo;C&rdquo; 的参数。</p>
</li>
</ul>
<p>此外，还有控制字节，这些字节是在没有新行的情况下自己发送的：</p>
<ul>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;OK&rdquo;，确认完成最后一个命令（如编写本地文件）。接收方也会在启动时发送此消息，让发送方知道它已准备好接收命令。</p>
</li>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;警告&rdquo;，后面是要向用户显示的行（由新行终止）。</p>
</li>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;错误&rdquo; 后跟随可选消息（和警告相同），但连接随后终止。</p>
</li>
</ul>
<p>下面这个带有注释的图片实例，详细讲述了这个过程：</p>
<figure><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png" title="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png" data-thumbnail="https://cdn.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png" data-sub-html="<h2>传输过程</h2>">
        
    </a><figcaption class="image-caption">传输过程</figcaption>
    </figure>
<h2 id="使用-scp">使用 SCP</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ scp 选项 参数
</code></pre></td></tr></table>
</div>
</div><p>其中选项如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">-1：使用ssh协议版本1；
-2：使用ssh协议版本2；
-4：使用ipv4；
-6：使用ipv6；
-B：以批处理模式运行；
-C：使用压缩；
-F：指定ssh配置文件；
-l：指定宽带限制；
-o：指定使用的ssh选项；
-P：指定远程主机的端口号；
-p：保留文件的最后修改时间，最后访问时间和权限模式；
-q：不显示复制进度；
-r：以递归方式复制。
</code></pre></td></tr></table>
</div>
</div><p>参数分别为：</p>
<ul>
<li>源文件：指定要复制的源文件。</li>
<li>目标文件：格式为user@host：filename（文件名为目标文件的名称）。</li>
</ul>
<h2 id="scp-的问题">SCP 的问题</h2>
<p>看起来，<code>SCP</code> 听起来似乎没什么问题。它是一个简单易用的工具，然而存在一些现实问题。</p>
<h3 id="性能">性能</h3>
<p>传输协议的顺序性：每个命令的强制确认都会增加大量开销。例如，如果沿途丢弃单个确认数据包，则整个连接将暂停，直到重新传输开始。最重要的是，发送所有数据而不压缩或询问接收方是否已经拥有该文件并不理想。</p>
<p>有经验的系统管理员可以告诉您，使用 <code>tar</code> 归档文件并发送比使用 <code>scp</code> 递归命令传输要快得多。事实上，这样的话你甚至无需使用 SCP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Shell" data-lang="Shell"><span class="c1"># Copy a local folder with 10000 files</span>
$ find /tmp/big_folder/-type f <span class="p">|</span> wc -l
<span class="m">10000</span>

<span class="c1"># Using scp</span>
$ <span class="nb">time</span> scp -r -q /tmp/big_folder/server:/tmp/big_folder

________________________________________________________
Executed in  882.99 millis	fish       	external
   usr <span class="nb">time</span>  114.09 millis	0.00 micros  114.09 millis
   sys <span class="nb">time</span>  278.46 millis  949.00 micros  277.51 millis

<span class="c1"># Using tar over ssh</span>
$ <span class="nb">time</span> sh -c <span class="s2">&#34;tar cf - /tmp/big_folder | ssh server &#39;tar xC /tmp/-f -&#39;&#34;</span>
tar: Removing leading <span class="s1">&#39;/&#39;</span> from member names

________________________________________________________
Executed in  215.68 millis	fish       	external
   usr <span class="nb">time</span>   93.22 millis	0.00 micros   93.22 millis
   sys <span class="nb">time</span>   66.51 millis  897.00 micros   65.62 millis
</code></pre></td></tr></table>
</div>
</div><p>在这种比较糟糕的情况下，<code>tar&amp;ssh</code> 的 215.68ms 对比 <code>SCP</code> 的 882.99ms，足足有四倍的速度提升。</p>
<h3 id="安全">安全</h3>
<p>我们已经知道，<code>SCP</code> 靠 <code>SSH</code> 负担安全工作，因此它完全安全&hellip; 吗？</p>
<p><code>OpenSSH</code> 的发行说明提到：</p>
<blockquote>
<p>scp 协议已经过时、不灵活且不容易修复。我们建议使用更现代的协议，如 sftp 和 rsync 来传输文件。</p>
</blockquote>
<p>如果远程端的 <code>shell</code> 打印出任何非交互式会话，则本地 <code>SCP</code> 进程将愉快地将该输出解释为 <code>SCP</code> 命令。好的话，这仅仅是打破 <code>SCP</code> 协议中模糊的错误。但在最坏的情况下，远程 <code>shell</code> 启动脚本是恶意的，并向你发送恶意文件，而不是所需的文件。</p>
<p>此外，早在 2018 年，Harry Sintonen 就发现了流行的 <code>SCP</code> 实现（包括 <code>OpenSSH</code>）中的一堆漏洞。包括从修改目录的权限到覆盖任意文件（由于 <code>～/.ssh/authorized_keys</code> 或 <code>～/.bashrc</code>）、有效地执行代码，以及注入终端转义序列来隐藏任何追踪。这些漏洞对于任何构建网络 <code>CLI</code> 应用程序的人来说都是一个很好的教训。</p>
<h2 id="scp-的替代方案">SCP 的替代方案</h2>
<p><code>SFTP</code> 被广泛认为是 <code>SCP</code> 的继承者。为了传输层安全性，它仍然在 <code>SSH</code> 上运行，并且不需要单独设置访问。它可以为您提供一个自定义交互式提示来探索远程文件系统，或者您可以使用预先编写的一系列命令编写脚本。
缺点是，您需要学习 <code>SFTP</code> 提示命令，协议本身尚未完全标准化（有很多 <code>RFC</code> 草稿，但作者最终放弃了）。</p>
<p><code>Rsync</code> 是另一个很好的选择。使用与 <code>SCP</code> 命令完全相同 - 它也利用 <code>SSH</code>。<code>Rsync</code> 着重优化性能 - 它执行大量的复杂本地计算从而通过网络发送尽可能少的数据。从技术上讲，它致力于数据同步而不是纯传输文件 - 如果远程和本地内容相似，则只会发送增量。</p>
<p>同样，它也有其自身的缺点：发送方使用大量的 CPU 资源来计算要发送什么，并且接收方使用大量磁盘 IO 将数据按正确的顺序放在一起。与 <code>OpenSSH</code> 不同，<code>Rsync</code> 在大多数系统上并不预安装。</p>
<h2 id="结论">结论</h2>
<p><code>SCP</code> 是一个简单的工具，它在复制文件方面做得很好，但较新的软件在很多方面都优于它。对于您信任的计算机之间的个人简单使用，<code>SCP</code> 仍然适合。</p>
<p>但是，如果您遇到性能问题或需要满足更高的安全标准，则上面列出的任何备选方案都比 <code>SCP</code> 更可取。选择最适合您需求的，然后试着开始使用。</p>
<h2 id="另见">另见</h2>
<ul>
<li><a href="https://www.techkoala.top/rsync/" target="_blank" rel="noopener noreffer">rsync</a></li>
<li><a href="https://www.techkoala.top/sftp/" target="_blank" rel="noopener noreffer">SFTP</a></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://gravitational.com/blog/scp-familiar-simple-insecure-slow/" target="_blank" rel="noopener noreffer">SCP - Familiar, Simple, Insecure, and Slow</a></p>
</li>
<li>
<p>[2] <a href="https://en.wikipedia.org/wiki/Secure_copy" target="_blank" rel="noopener noreffer">Wikipedia Secure copy</a></p>
</li>
<li>
<p>[3] <a href="https://lists.mindrot.org/pipermail/openssh-unix-dev/2019-March/037672.html" target="_blank" rel="noopener noreffer">Call for testing: OpenSSH 8.0</a></p>
</li>
<li>
<p>[4] <a href="https://ningyu1.github.io/linux-command/c/scp.html" target="_blank" rel="noopener noreffer">Scp</a></p>
</li>
</ul>]]></description>
</item></channel>
</rss>
