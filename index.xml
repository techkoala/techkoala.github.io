<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>TechKoala</title>
        <link>https://www.techkoala.top/</link>
        <description>TechKoala&#39;s自留地，分享一些笔记，包括但不限于Linux、虚拟机、软件、计算机网络等相关内容</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 30 Dec 2019 16:53:54 &#43;0800</lastBuildDate>
            <atom:link href="https://www.techkoala.top/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>NAT 系列 2：NAT 引发的问题以及解决方法</title>
    <link>https://www.techkoala.top/nat_issues_solutions/</link>
    <pubDate>Wed, 15 Jul 2020 14:19:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat_issues_solutions/</guid>
    <description><![CDATA[<pre><code>NAT 引发的问题以及解决方法
</code></pre>
<h2 id="问题">问题</h2>
<p>对称型 NAT（Symmetric NAT）常常在游玩联机游戏（尤其是 P2P 联机方式）时候给我们造成困扰。如果 Xbox、PS、switch 或者 PC 上的应用程序报告 NAT 是严格、类型 3、类型 D、对称这样的字样，那么就意味着你将会出现联机问题。</p>
<p>理解这个问题之前，首先要认识到，这些设备及软件是无法感知它们是否被 NAT 化的。但是，在 Internet 上与之通信的任何设备都应该使用公共 IP 地址，例如 1.1.1.1。在进行任何连接尝试时，都必须知道目标公共 IP 地址和端口。在上面的所有示例中，你应该发现了网站 IP 地址和端口均已知，这些地址是固定的，并且未曾发生更改。但是，某些程序会使用一系列动态端口。在运行游戏时，你的主机选择一个随机端口来进行游戏。由于其他主机不知道你的 IP 地址或端口，因此必须在连接之前以某种方式了解它。你的主机会将游戏的 IP 地址和端口发送到 Xbox Live 或 PS 网络，这样其他主机便可以在其中检索它，然后直接与你连接。但问题是，它发送的是内部 IP 地址 192.168.0.1 和端口 54324，而不是 Nat 后的公共 IP。它应该发送的是（例如）1.1.1.1 的公共 IP 地址和端口 54324。而且当处于对称型 NAT 时，该端口也会发生更改，因此它必须发送经过 NAT 处理的端口，例如 54254，而不是主机本身的内部端口（54324）。</p>
<p>** 这不仅仅是游戏面对的问题，这一直是 NAT 的问题。**</p>
<p>那么，主机如何得知它位于 NAT 之后，并告诉其他主机将数据发送到 NAT 后的 IP 地址和端口而不是其自身的内部 IP 地址和端口？</p>
<h2 id="解决办法">解决办法</h2>
<h3 id="stunsession-traversal-utilities">STUN（Session Traversal Utilities）</h3>
<p>Stun 是 NAT 的 Session Traversal Utilities 的缩写，你可能已经猜到了它的名字，它是一个实用工具的集合，以帮助 NAT 设备穿越内网。简单地说，STUN 允许你的主机 / PC 或内部设备了解它的公共 NAT 的 IP 地址和端口是什么。一旦实现了这一点，你的设备现在可以发送正确的 IP 和端口，其他设备也可以连接到你。但是，它在对称型 NAT 下无法工作，在对称型 NAT 中，你的主机可以得知它的公共 IP 地址，但无法得知它的公共端口（因为，端口是 NAT 随机生成的）。</p>
<p>STUN 的工作原理很简单。你连接到一个运行 STUN 协议的服务器 (Xbox Live Servers)，它从接收的数据包中读取源 IP 地址和源端口，这些当然会是 NAT 后的（这是我们需要的）。然后 STUN 将这些信息返回给客户端，它的工作就完成了。你的主机现在知道了它的 NAT 后的 IP 和端口，并且会把这些信息发送到其他设备上。</p>
<figure><a class="lightgallery" href="/images/Network/NAT/STUN_Algorithm.png" title="/images/Network/NAT/STUN_Algorithm.png" data-thumbnail="/images/Network/NAT/STUN_Algorithm.png" data-sub-html="<h2>STUN 算法</h2>">
        
    </a><figcaption class="image-caption">STUN 算法</figcaption>
    </figure>
<p>如果你还记得，除了对称型 NAT 之外，所有其他类型的 NAT 都不会改变源端口。这意味着当我的主机创建一个 NAT 映射时，它将对所有这种类型的连接使用它，当向互联网上的个设备发送和接收数据包时，它使用同一个映射，因此它使用相同的公共 IP 地址和端口；</p>
<p>但在对称型 NAT 的情况下，每一个连接都有一个不同的映射，有一个不同的（随机生成的）端口，意味着连接到 STUN 服务器也将有它自己独特的映射，表现的就像一个新的设备接入一样。这意味着每个映射都有不同的端口，在这种情况下，STUN 检测到的端口现在已经没有用了，因为这个映射是 STUN 服务器独有的。无论映射到其他设备的端口是什么，都是未知的，STUN 也没有办法检测到它。由于你的主机无法得知每个映射到每个主机的公共 NAT 化端口，因此无法将这些信息传递给你，也就意味着没有设备可以连接到你的游戏，这就是对称型 NAT 导致如此多游戏联机问题的原因。</p>
<h3 id="dmzdemilitarized-zone">DMZ（Demilitarized zone)</h3>
<p>路由器上的外围网络（也称 DMZ）功能用于消除对 Internet 的限制。它主要是将你的设备移到你的网络防火墙之外的区域，将部分用于提供对外服务的服务器主机划分到一个特定的子网 ——DMZ 内，在 DMZ 的主机能与同处 DMZ 内的主机和外部网络的主机通信，而同内部网络主机的通信会被受到限制。这使 DMZ 的主机能被内部网络和外部网络所访问，而内部网络又能避免外部网络所得知。</p>
<p><strong>注意</strong> 当你设置外围网络时在主机上使用静态 IP 地址十分重要。要设置静态 IP 地址，请使用路由器的 DHCP 预留功能（如果可用）。如果该功能不可用，你将需要在你的设备 上配置手动 IP 设置。</p>
<h3 id="upnpuniversal-plug-and-play">UPnP（Universal Plug and Play）</h3>
<p>UPnP（Universal Plug and Play）是帮助路由器有效通信的一个标准。如果路由器或网关支持 UPnP，则它在默认情况下可能已启用。开启 UPnP 功能后，局域网中的计算机可以请求路由器自动进行端口转换。这样，互联网上的计算机就能在需要时访问局域网计算机上的资源（如 MSN Messenger 或迅雷、BT、PPLive 等支持 UPnP 协议的应用程序）。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="www.think-like-a-computer.com/2011/09/19/symmetric-nat/" rel="">Symmetric NAT and It’s Problems | Think Like A Computer</a></p>
</li>
<li>
<p>[2] <a href="https://zh.wikipedia.org/wiki/STUN" target="_blank" rel="noopener noreffer">Wikipedia STUN</a></p>
</li>
<li>
<p>[3] <a href="https://zh.wikipedia.org/wiki/DMZ" target="_blank" rel="noopener noreffer">Wikipedia DMZ</a></p>
</li>
<li>
<p>[4] <a href="https://support.xbox.com/help/Hardware-Network/connect-network/xbox-one-nat-error" target="_blank" rel="noopener noreffer">解决 NAT 错误和多人游戏问题</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>NAT 系列 1：认识 NAT</title>
    <link>https://www.techkoala.top/nat/</link>
    <pubDate>Tue, 14 Jul 2020 23:25:54 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/nat/</guid>
    <description><![CDATA[<pre><code>一文概览 NAT
</code></pre>
<h2 id="nat">NAT</h2>
<p>NAT（Network Address Translation，网络地址转换）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。</p>
<p>NAT 从大类上都可以分为两类：<code>静态 NAT</code> 和 <code>动态 NAT</code>。</p>
<p><code>静态 NAT</code> 是管理员手动创建和维护映射，通常与 NAT 的入站类型相关联。</p>
<p><code>动态 NAT</code> 是路由器根据需要自动创建和维护映射，通常与 NAT 的出站类型相关联。</p>
<p>每个 TCP/IP 数据包都包含一个 <code>源 IP 地址</code>、<code>源端口</code>、<code>目的 IP 地址</code> 和 <code>目的端口</code>。所有类型的 NAT 都会使用这些值创建 NAT 映射。</p>
<pre><code>例如，一个 IP 为 `192.168.0.1` 的内部客户机使用端口 `56876`，经过 NAT 转
变后 IP 变为 3.3.3.3（翻译后的源 IP）和端口 56876（源端口）连接到 IP 
2.2.2.2（目的 IP 地址）的 80 端口（目的端口）。NAT 使用原始内部 IP 和端口、
翻译后 IP 和端口这 4 个值创建一个映射。当数据包从网站返回到路由器时，使用与该
映射相关值，NAT 将数据包转发到内部客户端。
</code></pre>
<h2 id="nat-的四种类型">NAT 的四种类型</h2>
<h3 id="全锥型-natfull-cone-nat">全锥型 NAT（Full Cone NAT)</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Full_Cone_NAT.png" title="/images/Network/NAT/Full_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Full_Cone_NAT.png" data-sub-html="<h2>全锥型 NAT</h2>">
        
    </a><figcaption class="image-caption">全锥型 NAT</figcaption>
    </figure>
<p>全锥型 NAT 是静态 NAT，也是唯一一种永久开放端口的 NAT，允许从 ** 任何外部主机 ** 进行入站连接。全锥型 NAT 将一个公共 IP 地址和端口映射到 LAN IP 和端口。任何外部主机都可以通过映射的 NAT IP 和端口向 LAN IP 发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的 NAT 也被称为端口转发。这是受限制最少的 NAT 类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。</p>
<pre><code>例如，我的电脑有一个网站在 80 端口上运行，我创建了一个一对一的规则，将路由器的
WAN IP 1.1.1.1 映射到 192.168.0.1，端口 80 映射到 80 端口。凡是在 80 端
口向 1.1.1.1 发送数据的外部主机都会被 NAT 转发到 192.168.0.1 80 端口。
</code></pre>
<p>** 注意：** 端口号不必相同；我可以在 56456 端口上运行我的网站，但创建 NAT 映射，将 80 端口转发到 56456 端口。这样，外部客户端就会认为我的网站在 80 端口上，而在任何其他端口上的连接尝试都会被丢弃。</p>
<h3 id="受限锥形-natrestricted-cone-nat">受限锥形 NAT（Restricted Cone NAT）</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Restricted_Cone_NAT.png" title="/images/Network/NAT/Restricted_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Restricted_Cone_NAT.png" data-sub-html="<h2>受限锥形 NAT</h2>">
        
    </a><figcaption class="image-caption">受限锥形 NAT</figcaption>
    </figure>
<p>受限锥体 NAT 是动态 NAT，它的工作方式与全锥型 NAT 相同，但会对进站的 IP 地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的 IP 地址。** 亦即需要内部主机首先发起连接的外部主机，才能被接受入站。**</p>
<pre><code>例如，我的电脑与一个网站 (56.45.34.78) 进行外向连接，源 IP 为 192.168.0.1，
源端口为 56723。NAT 使用源端口 56723 创建一个（动态）映射到我的电脑。使用目
的端口 56723（这是出站 NAT 的源端口）到达的源 IP 为 56.45.34.78（网站 IP）
的数据包将被接受，接着网站返回数据至我的 PC。任何其他 IP 即使使用正确的 56723 
端口进行连接尝试将被丢弃。同样，即使正确的 IP 使用 56723 以外的目的端口进行的
连接尝试也将被丢弃。
</code></pre>
<h3 id="端口受限锥型-natport-restricted-cone-nat">端口受限锥型 NAT（Port Restricted Cone NAT)</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Port_Restricted_Cone_NAT.png" title="/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-thumbnail="/images/Network/NAT/Port_Restricted_Cone_NAT.png" data-sub-html="<h2>端口受限锥型 NAT</h2>">
        
    </a><figcaption class="image-caption">端口受限锥型 NAT</figcaption>
    </figure>
<p>端口受限锥型 NAT 是动态 NAT，它的作用与受限锥形 NAT 完全相同，但同时对端口进行限制。受限锥形 NAT 接受来自外部主机任何源端口的连接，而端口受限锥型 NAT 则进一步要求外部主机的源端口是固定的。</p>
<pre><code>例如，我的电脑在 80 端口（目标端口）上向网站 IP 217.87.69.8 建立了一个外向连
接。NAT 将我的源 IP 192.168.0.1 映射到 WAN IP 1.1.1.1 和源端口 56723。当
网站发回数据包时，它的源 IP 必须是 217.87.69.8，目的端口是 56723（就像一个
受限锥型 NAT），但除此之外，还要求源端口必须是 80。如果这三者中的任何一个不一
样，端口受限锥型 NAT 就会放弃连接。
</code></pre>
<h3 id="对称型-natsymmetric-nat">对称型 NAT（Symmetric NAT）</h3>
<figure><a class="lightgallery" href="/images/Network/NAT/Symmetric_NAT.png" title="/images/Network/NAT/Symmetric_NAT.png" data-thumbnail="/images/Network/NAT/Symmetric_NAT.png" data-sub-html="<h2>对称型 NAT</h2>">
        
    </a><figcaption class="image-caption">对称型 NAT</figcaption>
    </figure>
<p>对称型 NAT 是动态 NAT，它限制的方式与端口受限锥型 NAT 完全相同，但处理 NAT 转换的方式不同。目前讨论的所有类型的 NAT 在 NAT 连接时都 ** 不会改变源端口 **。</p>
<pre><code>例如，当客户端使用 IP 192.168.0.1 和源端口 56723 访问互联网时，NAT 将源 IP 
改变为 56.35.67.35，但保持端口号不变，这被称为端口保留。
</code></pre>
<p>而对称型 NAT 会将端口改为 ** 随机生成的新端口 <strong>，甚至是同一客户端到不同目的地的连接也会发生。</strong> 亦即为每个连接创建唯一的映射 **</p>
<pre><code>例如，在端口受限锥型 NAT 的例子上进行扩展，我的 PC 向网站 IP 217.87.69.8 和
56.76.87.98 建立两个出站连接。我的电脑使用源 IP 192.168.0.1 和源端口 56723 进行
两个连接。到目前为止，在所有类型的 NAT 上，这两个连接都会被 NAT 化，只改变源 IP 地址
而保持源端口不变。然而这次，对称型 NAT 没有将源端口保留为 56723，而是将其中一个连
接的源端口改为 45765，另一个连接的源端口改为 53132（随机）。这就为每个连接创建了
唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以 217.87.69.8 必须将
数据包发送到目的端口 45765，56.76.87.98 必须将数据包发送到端口 53132，此外还需
要遵循端口受限锥型 NAT 的要求。
</code></pre>
<h2 id="对-nat-的正面评价">对 NAT 的正面评价</h2>
<ol>
<li>
<p>NAT 在一定程度上缓解了 IPv4 地址短缺的问题，让更多的设备（间接）接入了互联网。</p>
</li>
<li>
<p>NAT 全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT 依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为 UDP 的跨局域网的传输提供了方便。</p>
</li>
</ol>
<h2 id="对-nat-的批评">对 NAT 的批评</h2>
<ol>
<li>
<p>在一个具有 NAT 功能的路由器下的主机并没有获得真正的 IP 地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的 TCP 连接和无状态协议（比如 UDP）无法实现。除非 NAT 路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。</p>
</li>
<li>
<p>端对端连接是被 IAB 委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为 NAT 是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地 IP 地址，所以他们必须通过 NAT 来访问 ISP 网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。</p>
</li>
<li>
<p>NAT 使得 IP 协议从面向无连接变成立面向连接。NAT 必须维护专用 IP 地址与公用 IP 地址以及端口号的映射关系。在 TCP/IP 协议体系中，如果一个路由器出现故障，不会影响到 TCP 协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在 NAT 时，最初设计的 TCP/IP 协议过程将发生变化，Internet 可能变得非常脆弱。</p>
</li>
<li>
<p>NAT 违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第 N 层是不能修改第 N+1 层的报头内容的。NAT 破坏了这种各层独立的原则。</p>
</li>
<li>
<p>NAT 同时存在对高层协议和安全性的影响问题。RFC 对 NAT 存在的问题进行了讨论。NAT 的反对者认为这种临时性的缓解 IP 地址短缺的方案推迟了 IPv6 迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener noreffer">Wikipedia NAT</a></p>
</li>
<li>
<p>[2] <a href="https://think-like-a-computer.com/2011/09/19/symmetric-nat/" target="_blank" rel="noopener noreffer">What you need to know about symmetric NAT | Think Like A Computer</a></p>
</li>
<li>
<p>[3] <a href="https://portforward.com/nat-types/" target="_blank" rel="noopener noreffer">NAT Types Defined</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>深入浅出 DNS 解析</title>
    <link>https://www.techkoala.top/dns_update/</link>
    <pubDate>Thu, 02 Jul 2020 15:48:24 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/dns_update/</guid>
    <description><![CDATA[<pre><code>DNS 如何工作？当我们更新网站的 DNS 记录的时候到底发生了什么？更新后必须等待 48 小时才能生效吗？
为什么有的人看到的是新 IP，有的人看到的是旧 IP？
</code></pre>
<h2 id="dns-分类">DNS 分类</h2>
<p>我们知道，DNS 服务器有两种：权威服务器（authoritative）和递归服务器（recursive）</p>
<p><code>权威 DNS 服务器（也称为名称服务器，NS，nameserver）</code> 具有其所负责的每个域的 IP 地址数据库。</p>
<p>例如，<code>github.com</code> 的权威 DNS 服务器是 <code>NS-421.awsdNS-52.com</code></p>
<p>您可以像这样要求它提供 <code>github.com</code> 的 IP:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dig @NS-421.awsdNS-52.com github.com
</code></pre></td></tr></table>
</div>
</div><p><code>递归 DNS 服务器</code>，本身并不知道谁拥有什么 IP 地址。它们通过询问正确的权威 DNS 服务器，找出域名的 IP 地址，然后缓存这个 IP 地址，以备再次询问。8.8.8.8 是一个递归 DNS 服务器。</p>
<p>当人们访问你的网站时，他们可能会向递归 DNS 服务器进行 DNS 查询。那么，递归 DNS 服务器是如何工作的呢？</p>
<h3 id="递归-dns-服务器如何工作">递归 DNS 服务器如何工作</h3>
<p>以 <code>8.8.8.8</code> 为例，如果我们向其请求 <code>github.com</code> 的 IP 地址（A 记录），如果它存在缓存，那么就直接返回缓存结果。然而，缓存是有期限的，如果所有缓存都过期了呢？那么情况是这样的：</p>
<ol>
<li>
<p>递归服务器内部硬编码（hardcoded）有根 DNS 服务器 <code>.</code> 的 IP 地址（参见 [2][3]），选择一个根 DNS 服务器，例如 <code>198.41.0.4</code></p>
</li>
<li>
<p>询问根 DNS 服务器有关 <code>com.</code> 的 NS</p>
<p>此步可以使用如下方法模拟：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @198.41.0.4 github.com

...
com.			172800	IN	NS	a.gtld-servers.net.
...
a.gtld-servers.net.	172800	IN	A	192.5.6.30
...
</code></pre></td></tr></table>
</div>
</div><p>可以看到，这里我们得到一个 <code>com.</code> 的权威 NS<code>a.gtld-servers.net.</code> 及其 IP 地址 <code>192.5.6.30</code></p>
<p><strong>注</strong>：实际上，99.99% 的情况下，此步我们就将得到 <code>github.com</code> 的 A 记录，但为了展示 DNS 解析进程，我们假设这里没有得到。</p>
</li>
<li>
<p>询问该权威 NS 有关 <code>github.com</code> 的 NS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @192.5.6.30 github.com

...
github.com.		172800	IN	NS	NS-421.awsdNS-52.com.
NS-421.awsdNS-52.com.	172800	IN	A	205.251.193.165
... 
</code></pre></td></tr></table>
</div>
</div><p>这里，我们得到的 <code>github.com.</code>NS<code>NS-421.awsdNS-52.com.</code> 及其 IP 地址 <code>205.251.193.165</code></p>
</li>
<li>
<p>询问该 NS 有关 <code>github.com</code> 的 A 记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @205.251.193.165 github.com

github.com.		60	IN	A	140.82.112.4
</code></pre></td></tr></table>
</div>
</div><p>至此，在假设没有缓存的情况下，我们通过完整的流程（实际上绝大多数情况不需要完整进行）获得了 <code>github.com</code> 的 IP 地址。</p>
</li>
</ol>
<p>此外，使用 <code>$ dig @8.8.8.8 +trace github.com</code> 可以一次性显示上述所有步骤。</p>
<h2 id="更新-dns-记录">更新 DNS 记录</h2>
<p>更新 DNS 记录时，有两种情况：</p>
<ol>
<li>
<p>保持相同的 NS</p>
</li>
<li>
<p>变更 NS</p>
</li>
</ol>
<h3 id="首先谈谈生存时间ttlstime-to-live">首先谈谈生存时间（TTLs，time to live）</h3>
<p>上面已经说到，DNS 服务器一般存有缓存，而控制缓存是否过期的参数就是 TTL。</p>
<p>我们假设得到一个查询结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @205.251.193.165 github.com

github.com.		60	IN	A	140.82.112.4
</code></pre></td></tr></table>
</div>
</div><p>这里的 60（秒）即表示 TTL，这是一个很短的 TTL。理论上，如果每个用户都遵循 DNS 标准，那么 <code>github.com</code> 在更改了 IP 地址后，每个用户都应该在 60 秒内得到这个新的地址。但实际上呢？</p>
<h3 id="更新同一-ns-上的-dns-记录">更新同一 NS 上的 DNS 记录</h3>
<p>假设我们已经在域名商处更新了新的 DNS 记录 <code>test.jvNS.ca</code>&ndash;&gt;<code>1.2.3.4</code>，试着查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 test.jvNS.ca

test.jvNS.ca.		299	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p>如果此前没有设置过 DNS 记录，因为没有缓存，所以立刻生效了。这里可以看到 TTL 是 299。那么，修改 IP 为 <code>5.6.7.8</code> 呢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 test.jvNS.ca

test.jvNS.ca.		144	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p>可以看到，IP 并没有发生改变且 TTL 表示缓存还将存在 144 秒。而且，多次查询，你可能会发现，有时候可以得到新的 IP，但有的时候又是旧的 IP。</p>
<p>这里是因为像 <code>8.8.8.8</code> 这样的 DNS 服务器采用了负载均衡，每次查询可能被分配到不同的后端服务器，而他们的缓存不尽相同。</p>
<p>等待 5 分钟后，所有的缓存都更新了，再次查询，将会始终返回新 IP。</p>
<h3 id="ttl-并非总是可靠">TTL 并非总是可靠</h3>
<p>与大多数互联网协议一样，并不是所有的终端都服从 DNS 规范（包括 <code>8.8.8.8</code> 这样的大型 DNS 也不尊重 TTL）。一些 ISP 的 DNS 服务器会将缓存记录的时间比 TTL 规定的时间长，比如可能是 2 天而不是 5 分钟。而且人们总是可以在他们的 /etc/hosts 中硬编码旧的 IP 地址。</p>
<p>此外，应用程序（例如浏览器）都内置了自己的 DNS 缓存，或者本地网关也存在缓存。</p>
<p>这也是为什么，即便正确地设置了对应的 TTL（大部分 DNS 将会在短时间内更新缓存），有些 DNS 服务器仍然需要更长时间生效，这也导致我们的查询也并不总是会得到新的 IP 地址。</p>
<h3 id="连同-ns-一起更新">连同 NS 一起更新</h3>
<p>假设此前的 NS 为 <code>dNS1.p01.NSone.net</code>，现在我们把他修改为谷歌的 NS<code>NS-cloud-b1.googledomaiNS.com</code>。</p>
<p>通常，当你修改完成后，你的域名商会提示你：“修改将在 48 小时内生效”。</p>
<p>然后设置一个新的 A 记录指向 <code>1.2.3.4</code></p>
<p>dig 看看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @8.8.8.8 examplecat.com

examplecat.com.		17	IN	A	104.248.50.87
</code></pre></td></tr></table>
</div>
</div><p><code>8.8.8.8</code> 没有变化，询问别的 DNS：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @1.1.1.1 examplecat.com

examplecat.com.		299	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><p><code>1.1.1.1</code> 更新了。</p>
<p>造成这样不同结果的原因，可能是此前并没有人询问过 <code>1.1.1.1</code>，所以他没有缓存，能立刻得到新的 IP。</p>
<p>而如果我们向新的 NS 查询，肯定会得到新的 IP 记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @NS-cloud-b1.googledomaiNS.com examplecat.com

examplecat.com.		300	IN	A	1.2.3.4
</code></pre></td></tr></table>
</div>
</div><h3 id="ns-的-ttl-要长很多">NS 的 TTL 要长很多</h3>
<p>域名商提示：“修改将在 48 小时内生效” 的原因是 NS 记录（告诉递归 NS 应该向哪个 NS 查询）的 TTL 要长的多。</p>
<p>回到上一节中，我们的查询结果显示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig @192.5.6.30 github.com

...
github.com.		172800	IN	NS	NS-421.awsdNS-52.com.
NS-421.awsdNS-52.com.	172800	IN	A	205.251.193.165
...
</code></pre></td></tr></table>
</div>
</div><p>172800 秒是 48 小时！这就是为什么更改 NS 后需要更长的时间来生效。</p>
<h3 id="ns-如何得到更新">NS 如何得到更新？</h3>
<p>更新 NS 后，我们向根服务器查询的话就会到得到这样的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ dig NS @j.gtld-servers.net examplecat.com

examplecat.com.		172800	IN	NS	NS-cloud-b1.googledomaiNS.com
</code></pre></td></tr></table>
</div>
</div><p>你可能会疑惑，新的 NS 记录是如何在根服务器处更新的呢？是因为当你在域名商那里更改你域名的 NS 后，他们会负责将这个给更改告知根服务器。</p>
<p>通常这个更新将在几分钟内就生效，但是对于其他一些顶级域名（TLD）（非.com）可能速度稍微慢一些。</p>
<h2 id="总结">总结</h2>
<p>本文展示了 DNS 的解析过程以及我们更新 DNS 记录时发送了什么，希望有助于你理解这一过程。</p>
<h2 id="说明">说明</h2>
<p><strong>说明：<strong>本文属于 <code>Translation</code> 系列文章，本系列文章</strong>主要内容</strong>来源于博主对优秀外文文章地翻译和校对，这里并不一定遵循原文的叙述逻辑，内容上也会有一定的增删，原文请见参考。</p>
<p>译文的目的一方面是加深自己学习的印象，另外一方面是希望能够共享优质的内容。</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://jvNS.ca/blog/how-updating-dNS-works/" target="_blank" rel="noopener noreffer">What happeNS when you update your DNS?</a></p>
</li>
<li>
<p>[2] <a href="https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131" target="_blank" rel="noopener noreffer">unbound’s source code</a></p>
</li>
<li>
<p>[3] <a href="https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131" target="_blank" rel="noopener noreffer">iana root files</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>Nagle 算法</title>
    <link>https://www.techkoala.top/turn_off_nagle/</link>
    <pubDate>Sun, 28 Jun 2020 10:44:16 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/turn_off_nagle/</guid>
    <description><![CDATA[<pre><code>简要介绍 Nagle 算法
</code></pre>
<h2 id="nagle-算法">Nagle 算法</h2>
<p>Nagle 算法通过减少网络发包频率从而提高 TCP/IP 网络的效率。</p>
<p>主要解决由于 TCP 包头大小，导致频繁发送小数据包有效数据内容太少，开销过大段的问题。</p>
<p>Nagle 算法是将大量等待发送的小数据包合并起来，然后一次性全部发送出去。具体地说，只要有一个发送方没有收到任何确认的数据包，发送方就应该一直缓冲它的输出，直到它有一个完整的数据包的输出，这样就允许一次发送所有的输出。</p>
<p>其思路可以由下面的步骤所描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">if there is new data to send then
    if the window size ≥ MSS and available data is ≥ MSS then
        send complete MSS segment now
    else
        if there is unconfirmed data still in the pipe then
            enqueue data in the buffer until an acknowledge is received
        else
            send data immediately
        end if
    end if
end if
</code></pre></td></tr></table>
</div>
</div><p>Nagle 算法可能导致期望实时响应和低延迟的应用程序体验不佳。</p>
<p>诸如网络多人视频游戏或鼠标在远程控制的操作系统中移动等应用程序，期望立即发送操作，而算法故意延迟传输，以牺牲延迟为代价提高带宽效率。因此，具有低带宽时间敏感传输的应用程序通常用于绕过 Nagle 延迟的 ACK 延迟。</p>
<h2 id="windows-下关闭-nagle-算法">Windows 下关闭 Nagle 算法</h2>
<ol>
<li>
<p>打开注册表编辑器</p>
</li>
<li>
<p>打开如下路径 <code>计算机 \HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces</code></p>
<a class="lightgallery" href="/images/Network/regedit.png" title="/images/Network/regedit.png" data-thumbnail="/images/Network/regedit.png">
        
    </a>
</li>
<li>
<p>依次点击下方注册表项，检查右窗格中是否包含 <code>DhcpIPAddress</code> 值；</p>
</li>
<li>
<p>在包含有 <code>DhcpIPAddress</code> 的子项下，分别建立两个 <code>DWORD (32)</code> 值，依次命名为 <code>TcpAckFrequency</code> 和 <code>TCPNoDelay</code>，键值全部设为 <code>1</code>。</p>
<p><strong>注意</strong> 包含 <code>DhcpIPAddress</code> 的子项可能不只一个，所有的都要添加。</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank" rel="noopener noreffer">Nagel 算法维基百科</a></p>
</li>
<li>
<p>[2] <a href="https://www.ietf.org/rfc/rfc896.txt" target="_blank" rel="noopener noreffer">RFC896</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>Linux 安全分析与加固</title>
    <link>https://www.techkoala.top/linux_security/</link>
    <pubDate>Sun, 07 Jun 2020 23:22:43 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/linux_security/</guid>
    <description><![CDATA[<a class="lightgallery" href="/images/Linux/linux.png" title="/images/Linux/linux.png" data-thumbnail="/images/Linux/linux.png">
        
    </a>
<pre><code>记录一些常见的 Linux 服务器安全问题分析以及防护措施
</code></pre>
<h2 id="日志分析">日志分析</h2>
<h3 id="常用日志文件">常用日志文件</h3>
<p><strong>Debian</strong> 以及 <strong>RHEL</strong> 系的系统日志是由一个名为 syslog 的服务管理的，如以下日志文件都是由 syslog 日志服务驱动的：</p>
<p><code>/var/log/boot.log</code>：记录了系统在引导过程中发生的事件，就是 Linux 系统开机自检过程显示的信息</p>
<p><code>/var/log/lastlog</code> ：记录最后一次用户成功登陆的时间、登陆 IP 等信息</p>
<p><code>/var/log/messages</code> ：记录 Linux 操作系统常见的系统和服务错误信息</p>
<p><code>/var/log/secure</code> ：Linux 系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况</p>
<p><code>/var/log/syslog</code>：只记录警告信息，常常是系统出问题的信息，使用 lastlog 查看</p>
<p><code>/var/log/wtmp</code>：该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，使用 last 命令查看</p>
<p><code>/var/run/utmp</code>：该日志文件记录有关当前登录的每个用户的信息。如 who、w、users、finger 等就需要访问这个文件</p>
<p><strong><code>/var/log/btmp</code>：记录 Linux 登陆失败的用户、时间以及远程 IP 地址</strong></p>
<p><strong><code>/var/log/auth.log</code> 或 <code>/var/log/secure</code> 存储来自可插拔认证模块 (PAM) 的日志，包括成功的登录，失败的登录尝试和认证方式。</strong></p>
<pre><code>注：**Debian** 系在 /var/log/auth.log 中存储认证信息而 **RHEL** 系则在 /var/log/secure 中存储。
</code></pre>
<p><strong>Archlinux</strong> 使用 <code>systemd</code> 提供的日志系统（logging system），称为 <code>journal</code>。使用 systemd 日志，无需额外安装日志服务（syslog）。</p>
<h3 id="相关日志查看命令">相关日志查看命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat /var/log/secure <span class="p">|</span> awk <span class="s1">&#39;/Failed/{print $(NF-3)}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> awk <span class="s1">&#39;{print $2&#34;=&#34;$1;}&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>查看尝试暴力登录 root 的 IP 及次数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep <span class="s2">&#34;Failed password for root&#34;</span> /var/log/auth.log <span class="p">|</span> awk <span class="s1">&#39;{print $11}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort -nr <span class="p">|</span> more
</code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="常见防护措施">常见防护措施</h2>
<h3 id="ssh">SSH</h3>
<h4 id="编辑-ssh-配置文件">编辑 SSH 配置文件</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ vim /etc/ssh/sshd_config
</code></pre></td></tr></table>
</div>
</div><p><strong>1、修改端口</strong></p>
<p><code>#Port 22 —&gt; Port xxxx</code></p>
<p><strong>2、关闭 root 登录</strong></p>
<p><code>PermitRootLogin yes -&gt; PermitRootLogin no</code></p>
<p><strong>3、使用证书登录</strong></p>
<ul>
<li>
<p><strong>若不存在证书首先执行下面步骤</strong></p>
<p>在客户端生成密钥:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa
</code></pre></td></tr></table>
</div>
</div><p>把公钥拷贝至服务器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ssh-copy-id -i .ssh/id_rsa.pub server
</code></pre></td></tr></table>
</div>
</div><p>或手动将 id_rsa.pub 拷贝至服务器用户目录的.ssh 中，并修改访问权限：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ scp .shh/id_rsa.pub server:~/.ssh
</code></pre></td></tr></table>
</div>
</div><p>服务器中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ chmod <span class="m">400</span> authorized_keys
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>打开证书登录：</p>
<p><code>RSAAuthentication yes</code></p>
<p>开启公钥验证：</p>
<p><code>PubkeyAuthentication yes</code></p>
<p>验证文件路径：</p>
<p><code>AuthorizedKeysFile    .ssh/authorized_keys</code></p>
<p>禁止密码认证：</p>
<p><code>PasswordAuthentication no</code></p>
<p>禁止空密码：</p>
<p><code>PermitEmptyPasswords no</code></p>
<p><strong>最后，重启 SSHD 服务</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ systemctl restart sshd
</code></pre></td></tr></table>
</div>
</div><h3 id="用户以及用户组管理">用户以及用户组管理</h3>
<h4 id="无用用户用户组">无用用户、用户组</h4>
<p><strong>Linux 系统中可以删除的默认用户和组大致有如下这些：</strong></p>
<p>可删除的用户，如 <code>adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher</code> 等。</p>
<p>可删除的组，如 <code>adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers</code> 等。</p>
<h4 id="空口令账户">空口令账户</h4>
<p>使用如下命令检测空口令账户：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ awk -F: <span class="s1">&#39;$2==&#34;!!&#34; {print $1}&#39;</span> /etc/shadow
</code></pre></td></tr></table>
</div>
</div><p>然后查看 <code>/etc/passwd</code> 确认空口令用户是否可以登录，选择是否加固密码。</p>
<h4 id="登录失败后强制延时">登录失败后强制延时</h4>
<p>在 <code>/etc/pam.d/system-login</code> 中添加 <code>auth optional pam_faildelay.so delay=4000000</code>，表示延时 4 秒（单位微秒）</p>
<h4 id="限制-root-权限">限制 root 权限</h4>
<p>可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限：</p>
<p>编辑 <code>/etc/sudoers</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ visudo
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>若要指定 visudo 的默认编辑器，最好是修改 <code>/etc/sudoers</code> 中的 <code>Defaults editor=xxxx</code></p>
<p>而不是使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nv">EDITOR</span><span class="o">=</span>nano visudo
</code></pre></td></tr></table>
</div>
</div><p>因为任何程序都可以通过该命令指定作为编辑器，存在风险。</p>
</li>
</ul>
<p>添加：</p>
<p><code>alice ALL = NOPASSWD: /path/to/program</code></p>
<h3 id="关闭不必要的服务">关闭不必要的服务</h3>
<p><strong>例如</strong> 某台 Linux 服务器用于 www 应用，那么除了 httpd 服务和系统运行是必须的服务外，其他服务都可以关闭。下面这些服务一般情况下是不需要的，可以选择关闭：</p>
<p><code>anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv</code></p>
<h3 id="文件系统安全">文件系统安全</h3>
<p><strong>文件权限检查和修改</strong></p>
<p><strong>（1）查找系统中任何用户都有写权限的文件或目录</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">查找文件：$ find /-type f -perm -2 -o -perm -20 <span class="p">|</span>xargs ls -al
查找目录：$ find /-type d -perm -2 -o -perm -20 <span class="p">|</span>xargs ls –ld
</code></pre></td></tr></table>
</div>
</div><p><strong>（2）查找系统中所有含 “s” 位的程序</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">find /-type f -perm -4000 -o -perm -2000 -print <span class="p">|</span> xargs ls –al
</code></pre></td></tr></table>
</div>
</div><p>含有 “s” 位权限的程序对系统安全威胁很大，通过查找系统中所有具有 “s” 位权限的程序，可以把某些不必要的 “s” 位程序去掉，这样可以防止用户滥用权限或提升权限的可能性。</p>
<p><strong>（3）检查系统中所有 suid 及 sgid 文件</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find /-user root -perm -2000 -print -exec md5sum <span class="o">{}</span> <span class="p">;</span>
$ find /-user root -perm -4000 -print -exec md5sum <span class="o">{}</span> <span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>将检查的结果保存到文件中，可在以后的系统检查中作为参考。</p>
<p><strong>（4）检查系统中没有属主的文件</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find /-nouser -o –nogroup
</code></pre></td></tr></table>
</div>
</div><p>没有属主的孤儿文件比较危险，因此找到这些文件后，要么删除掉，要么修改文件的属主，使其处于安全状态。</p>
<h2 id="检测工具">检测工具</h2>
<h2 id="参考">参考</h2>
<ul>
<li>
<p>[1] Linux 服务器为什么被黑？</p>
</li>
<li>
<p>[2] <a href="https://www.cnblogs.com/doublexi/p/9636506.html" target="_blank" rel="noopener noreffer">linux 系统安全加固 &ndash; 账号相关</a></p>
</li>
<li>
<p>[3] <a href="https://wiki.archlinux.org/index.php/Security" target="_blank" rel="noopener noreffer">Security - Archlinux Wiki</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>Huginn（Docker）数据备份与恢复</title>
    <link>https://www.techkoala.top/huginn_backup/</link>
    <pubDate>Wed, 27 May 2020 23:06:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/huginn_backup/</guid>
    <description><![CDATA[<a class="lightgallery" href="/images/Huginn/Huginn.png" title="/images/Huginn/Huginn.png" data-thumbnail="/images/Huginn/Huginn.png">
        
    </a>
<pre><code>简单介绍使用 Docker 运行的 Huginn 数据的备份与恢复
</code></pre>
<h3 id="备份数据">备份数据</h3>
<p>使用命令在容器中生成备份：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it huginn mysqldump --single-transaction --opt -u root -ppassword huginn_production &gt; huginn_backupfile.sql
</code></pre></td></tr></table>
</div>
</div><p>或直接拷贝数据到容器外：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it  huginn mysqldump -u root -ppassword huginn_production &gt; /root/test_db.sql
</code></pre></td></tr></table>
</div>
</div><h3 id="恢复数据">恢复数据</h3>
<p>首先复制文件到 daocker 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker cp /home/xxxx/huginn_backupfile.sql huginn: /app/xxxxx/huginn_backupfile.sql
</code></pre></td></tr></table>
</div>
</div><p>然后进入 docker：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -ti huginn bash
</code></pre></td></tr></table>
</div>
</div><p>接下来恢复数据库:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mysql -u root -ppassword huginn_production &lt; huginn_backupfile.sql
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>PVE 安装 Q&amp;A</title>
    <link>https://www.techkoala.top/pve_q_a/</link>
    <pubDate>Tue, 19 May 2020 15:31:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/pve_q_a/</guid>
    <description><![CDATA[<pre><code>PVE 安装过程中遇到的问题以及解决方法
</code></pre>
<h1 id="pve-安装-qa">PVE 安装 Q&amp;A</h1>
<p>近期将家里的服务器从 Hyper-V 迁移到 PVE 上。</p>
<p>目前安装有黑群晖、Openwrt、Ubuntu 18.09LTS</p>
<p>目前的网络拓扑图如下：</p>
<figure><a class="lightgallery" href="/images/PVE/%20%e6%8b%93%e6%89%91.png" title="/images/PVE/ 拓扑.png" data-thumbnail="/images/PVE/ 拓扑.png" data-sub-html="<h2>网络拓扑图</h2>">
        
    </a><figcaption class="image-caption">网络拓扑图</figcaption>
    </figure>
<p>将安装过程中遇到的问题以及解决方法整理如下：</p>
<h3 id="1-temporary-failure-in-name-resolution">1. Temporary failure in name resolution：</h3>
<p>由于开始使用路由器拨号，因此初次安装设置的 DNS 服务器为路由器地址，安装软路由后更改了地址，所以导致 DNS 服务器设置错误 192.168.1.190&gt;192.168.1.1</p>
<h3 id="2-群晖挂载硬盘">2. 群晖挂载硬盘：</h3>
<p>PVE 正确识别到了 NTFS 的一硬盘，但是群晖不能自动挂载。需要关机后，在 PVE 虚拟机管理界面，添加，然后重启才能识别。(否则显示为红色，同样的，移除硬件需要同样的操作)</p>
<h3 id="3-pve-节点监视图不显示时间为-1970-1-1">3. PVE 节点监视图不显示，时间为 1970-1-1：</h3>
<p>删除界面缓存文件即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Shell" data-lang="Shell">rm /var/lib/rrdcached/db/pve2-node
</code></pre></td></tr></table>
</div>
</div><h3 id="4-群晖-socks-代理">4. 群晖 socks 代理</h3>
<p>Openwrt 安装 luci-app-Privoxy，设置转发规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Shell" data-lang="Shell">/ip:port .
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>Hugo搭配LoveIt使用问题</title>
    <link>https://www.techkoala.top/hugo_loveit_q_a/</link>
    <pubDate>Tue, 12 May 2020 21:54:02 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/hugo_loveit_q_a/</guid>
    <description><![CDATA[<pre><code>使用 hugo 以及 LoveIt 搭建本博客遇到的问题以及解决方案
</code></pre>
<h3 id="1-虚拟机中-hugo-server-无法远程访问">1. 虚拟机中 Hugo server 无法远程访问</h3>
<p>hugo server 默认只会 bind localhost</p>
<p>使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ Hugo server --bind xxx.xxx.xxx.xxx
</code></pre></td></tr></table>
</div>
</div><p>指定虚拟机 IP，即可通过同网域机器访问该 web 服务</p>
<h3 id="2-使用-git-信息生成文章上一次修改时间">2. 使用 git 信息生成文章上一次修改时间</h3>
<p>首先，启用 git 信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">enableGitInfo = true
</code></pre></td></tr></table>
</div>
</div><p>然后，启用 gitRepo 参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">gitRepo = &#34;/xxx/xxxx/.git/&#34;
</code></pre></td></tr></table>
</div>
</div><p>需要注意的是：</p>
<ul>
<li>
<p>这里.git 应该 init 在 hugo 生成的项目根目录中</p>
</li>
<li>
<p>但是这样，如果只 push public 文件夹到 Github 上部署的话，网页上无法正确跳转对应的 commit 详情页。</p>
</li>
</ul>
<h3 id="3-页面出现-extra-stringxxxx">3. 页面出现 %!(EXTRA string=xxxx)</h3>
<p>LoveIt Github Issue 提到该问题的<a href="https://github.com/dillonzq/LoveIt/issues/197" title="%!(EXTRA string=Text) in some text" target="_blank" rel="noopener noreffer">解决方案</a></p>
<p>但实际通过修改 config.toml 中的<code>defaultContentLanguage = &quot;zh&quot;</code>为<code>defaultContentLanguage = &quot;zh-cn&quot;</code>即可解决。</p>]]></description>
</item><item>
    <title>改变世界的条形码</title>
    <link>https://www.techkoala.top/brief_history_of_qrcode/</link>
    <pubDate>Tue, 12 May 2020 17:59:52 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/brief_history_of_qrcode/</guid>
    <description><![CDATA[<pre><code>条形码以及二维码的过去与将来
</code></pre>
<p>注：本文是最早以 TechKoala 的名字所写的文章，发布于电脑爱好者 2013 年第 06 期。
说来当时以邮汇方式发的稿费至今没有收到，2333</p>
<p>   面对我们随时可以看见的条形码，说出来你也许会不信，如果没有这个家伙，整个世界的经济都无法正常运行。这些黑白条码不但能让机场不弄丢你的行李，能对快件的包裹进行跟踪，而且还能在网上对各种信件进行查询。它们既可以用在食品包装上，也可以用在图书的扉页。这个时候看看手上的《电脑爱好者》杂志，你发现了吗？</p>
<h3 id="条形码的由来">条形码的由来</h3>
<p>   三十多年前的一天，一位名叫道森的购物者走进马什超市，购买了一包箭牌口香糖，扫扫条形码然后付钱。这在今天稀疏平常的事，当时却是标志性事件 — 由此，条形码迎来了它的里程碑，从此走到你我的眼前。</p>
<figure><a class="lightgallery" href="/images/Brief_history_of_QRCode/wood.jpg" title="/images/Brief_history_of_QRCode/wood.jpg" data-thumbnail="/images/Brief_history_of_QRCode/wood.jpg" data-sub-html="<h2>伍德蓝德</h2>">
        
    </a><figcaption class="image-caption">伍德蓝德</figcaption>
    </figure>
<p>   说到条形码，就不得不说它的发明者 —— 伍德蓝德。他出生于新泽西州，从小便对技术发明具有浓厚的兴趣，具备非凡的动手能力。他生长在二战前后，战争期间，他不得不中断学业，参与研发原子弹的曼哈顿工程，这个看似八竿子打不着边的事，却使他对发明愈发迷恋。二战之后，美国经济快速发展，规模宏大的超市面临着一个巨大的问题，他们无法精确掌握库存情况，唯一的办法是手工清理，但耗时又费力。于是他们向德雷赛尔大学求助，恰巧伍德蓝德得知，于是，伍德蓝德开始与自己的朋友苏沃一起研究这个解决方案。蓝德本来是出于商业目的，但随着研究的深入，这项工作彻底改变了他的人生。类似历史上的诸多发明，开始时，蓝德遇到了许多次失败，但他没有放弃。他毅然辍学全心投入，坚信成功不远，但总差那么一层窗户纸。后来，他去了迈阿密的住所放松，那里有优美的居住环境、安静的思考空间，他期待能有灵感迸发。</p>
<p>   老天不负有心人。有一天，他在沙滩坐定，苦苦思索：“如何才能给每件物品分类呢？编号？对！莫尔斯电码？可是这样太复杂了，一般人也没办法分辨。” 想到此，他开始无聊地在沙滩上用手画沙子，一条一条，突然，一个神奇的图案出现在蓝德脑海 — 如果用粗细、间距不同的竖线构成图案，那就可以实现对商品编码。就这样，条码的原型在沙滩上诞生了。待到出现文章开头的一幕时，已经过去了三十多年，可喜的是，我们的主人公是一位有耐心的人。</p>
<h3 id="条形码的标准与应用">条形码的标准与应用</h3>
<p>   与现在的条形码不同，蓝德发明的第一条条形码不是由线条构成，而是一组同心圆，通过照片扫描器读取。它形如箭靶，美国人称其为 “公牛眼”。遗憾的是，以美国当时的工艺和经济水平，他们还没有能力印制出这种编码。</p>
<figure><a class="lightgallery" href="/images/Brief_history_of_QRCode/first_code.png" title="/images/Brief_history_of_QRCode/first_code.png" data-thumbnail="/images/Brief_history_of_QRCode/first_code.png" data-sub-html="<h2>公牛眼</h2>">
        
    </a><figcaption class="image-caption">公牛眼</figcaption>
    </figure>
<p>   后来，伍德蓝德加入了 IBM 公司，并把自己的专利卖给了 IBM。然而，伟大的成果却并非属于 IBM，几经转手，机遇来到了 RCA 公司。直到条形码大展宏图时，IBM 公司里的人才知道：“哦，原来发明条形码的人就在我们公司。”</p>
<p>   我们目前所知的第一个商用条形码出现于 1966 年，但人们很快就意识到应该为其制定出一个行业标准。</p>
<p>   两年后的夏天，应国家食物连锁协会要求，Logicon 公司开发出了食品工业统一码（UGPIC）。随后，美国统一编码协会建立了 UPC 码系统，并且实现了该码制的标准化。UPC 码首先在杂货零售业中试用，俄亥俄州的 Marsh 超级市场安装了由 NCR（IBM 公司的前身）制造的第一台 UPC 扫描器，而第一个被收银员扫描的便是文章开头所说的标价 69 美分的十片装箭牌口香糖。</p>
<p>   直到现在，我们都不可否认的是，正是零售业的成功应用才促进了条形码技术的发展。</p>
<p>   目前，全球每天大约要扫描 80 亿次条形码。而普华永道公司的一项研究报告表明，条形码每年仅在超市和大众零售领域就能为客户、零售商和制造商节约 300 亿美元的成本。令人感到遗憾的是，伍德兰德的朋友，条形码联合发明人苏沃并没有亲眼看到条形码的商业化应用，他在自己 38 岁的时候（1962 年）英年早逝。而伍德蓝德则在 1992 年被当时的美国总统布什授予了国家科技奖章。</p>
<p>   令人遗憾的是，前不久，伍德蓝也不幸地告别了人世。据《纽约时代》报道，他于美国当地时间 2012 年 12 月 9 日在自己新泽西的家中逝世，享年 91 岁。蓝德的女儿苏珊评价父亲说：“他参与了整个系统的设计，从使用者的站立方式、激光扫描仪高度到如何保护人们的眼睛不受激光刺激，他是一个绝对的完美主义者。”</p>
<h3 id="条形码的未来">条形码的未来</h3>
<p>   今天，条形码已经占据我们生活的每个角落，从超市购买的食品到手中握住的杂志，我们依靠条形码管理我们的生活，条形码技术也在不断进步。</p>
<p>   其实，如今风生水起的二维码也属于条形码，作为后起之秀，它比它的前辈更进一步。自从它出现以来，得到了人们的广泛关注，发展十分迅速。</p>
<p>   二维条形码最早发明于日本，它是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的，在代码编制上巧妙地利用构成计算机内部逻辑基础的 “0”、“1” 比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信息自动处理。它具有条形码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、处理图形旋转变化等特点。</p>
<p>   一维条形码虽然提高了资料收集与资料处理的速度，但由于受到资料容量的限制，一维条形码仅能标识商品，而不能描述商品，因此相当依赖电脑网络和资料库。在没有资料库或不便连网的地方，一维条形码很难派上用场。此外一维条形码有一个明显的缺点，即垂直方向不携带资料，故资料密度偏低。当初这样设计有二个目的：（1）为了保证局部损坏的条形码仍可正确辨识；（2）使扫描容易完成。</p>
<p>   要提高资料密度，又要在一个固定面积上印出所需资料，可用二种方法来解决：（1）在一维条形码的基础上向二维条形码方向扩展；（2）利用图像识别原理，采用新的几何形体和结构设计出二维条形码。前者发展出堆叠式（Stacked）二维条形码，后者则有矩阵式（Matrix）二维条形码之发展，构成现今二维条形码的两大类型：</p>
<p><code>堆叠式二维条形码的编码原理是建立在一维条形码的基础上，将一维条形码的高度变窄，再依需要堆成多行，其在编码设计、检查原理、识读方式等方面都继承了一维条形码的特点，但由于行数增加，对行的辨别、解码算法及软件则与一维条形码有所不同。较具代表性的堆叠式二维条形码有 PDF417、Code16K、Supercode、Code49 等。</code></p>
<p><code>矩阵式二维条形码是以矩阵的形式组成，在矩阵相应元素位置上，用点的出现表示二进制的 “1”，不出现表示二进制的 “0”，点的排列组合确定了矩阵码所代表的意义。其中点可以是方点、圆点或其他形状的点。矩阵码是建立在电脑图像处理技术、组合编码原理等基础上的图形符号自动辨识的码制，已较不适合用 “条形码” 称之。具有代表性的矩阵式二维条形码有 Datamatrix、Maxicode、Vericode、Softstrip、Code1、Philips Dot Code 等。</code></p>
<p>   二维条形码的新技术在 1980 年代晚期逐渐被重视，在 “资料储存量大”、“资讯随着产品走”、“可以传真影印”、“错误纠正能力高” 等特性下，二维条形码在 1990 年代初期已逐渐被使用。现在，几乎所有的社交软件都具备扫一扫的功能，对着抽象的图案一扫，迎来一个多彩的世界已经成为许多人的习惯。</p>
<p>   马化腾在去年九月开幕的互联网大会的演讲中便说到：“从微信强化扫二维码的功能之后，我们希望把这个行为定义成更加普及，老百姓一看到码就去扫的概念。我们前几天还在网上看到一个新的名词，就是扫墓，看到墓碑有那个二维码，一扫描就看到这个墓碑的主人过去的生平介绍等等，这些都是非常典型的应用。”</p>
<p>   或许，墓碑的例子有些夸张，但是，你不能否认，条形码越来越贴近我们的生活，不再只是局限于购物。也许未来，我们的一切都涵盖在那小小的方寸之间。</p>
<hr>
<p>   碰巧，时隔多年把这篇文章重新整理出来的时候，回形针正好发布了一期关于二维码的视频：</p>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1Y54y1D7cT&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<p>   放在这里，作为补充。</p>]]></description>
</item><item>
    <title>Symbian 的前世今生</title>
    <link>https://www.techkoala.top/brief_history_of_symbian/</link>
    <pubDate>Mon, 11 May 2020 22:57:01 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://www.techkoala.top/brief_history_of_symbian/</guid>
    <description><![CDATA[<a class="lightgallery" href="/images/symbian/symbian.jpg" title="/images/symbian/symbian.jpg" data-thumbnail="/images/symbian/symbian.jpg">
        
    </a>
<pre><code>聊聊 Symbian 的过去
</code></pre>
<p>注：这是一篇写于 2013 年的文章，时过境迁，仅表怀念。</p>
<p>   毫不夸张的说，今天我们所拥有的一切，都是建立在它的肩膀上。无论多少人咒骂它的臃肿，嫌弃它的卡顿，都无法改变它作为手机智能操作系统鼻祖的地位。当山寨机还在襁褓中时，当伪智能还在浪费人们的时间时，作为先驱的它便已上路。大多数人接触的第一款真正的智能手机系统，它把软件下载，游戏安装，刷机破解等诸多名词第一次带到了大众视野。它叫 Symbian，也曾辉煌。三十年河东，三十年河西，科技领域本就没有常青树。虽然如今已经沦落，但不妨碍我们一起回味它曾经的辉煌。</p>
<h3 id="混沌之初symbian-伊始">混沌之初，Symbian 伊始</h3>
<p>​  Symbian，源自一家充满梦想的公司。</p>
<p>  1980 年，potter 在伦敦成立了 Psion 公司，这家以数字产品开发和研究为目的，为率先使用电子设备的大公司服务的小公司便是 Symbian 的生母。随着公司的发展，Psion 开始浸淫移动终端市场，他们生产的各类移动设备不仅皮实耐用还能按需求定制，凭借这种 “开放移动” 的理念，Psion 在上世纪 90 年代 成为了欧洲较成功的 PDA 生产商，进而促进了 EPOC 的诞生。在 potter 看来，EPOC 是一种面向普通大众的便携系统。正如他的全称 “A new epoch of personal convenience.”（一个人人方便使用电子产品的新时代），他被 Psion 给予了对于人机交互未来的憧憬。</p>
<p>   犹如一代闪电，EPOC 划开了混沌的天空，不过真正的风暴才刚来临。</p>
<p>  1991 年到 1998 年，Psion 发布了几款给予 EPOC 16 的的设备，作为早期产品，免不了简陋无比，它们充其量只能算是 PDA 模块，只是方便了厂商研发新品。</p>
<p>   真正让 EPOC 走向成熟的是一位叫做 Nicholas Myers 的程序设计师。1994 年，他在构思下一代 EPOC 时，设定了开发适应 21 世纪技术性能的系统的目标。正是这样的思路。让他把握住了市场脉搏。1997 年，他成为 Psion 旗下 Symbian 软件公司的 CEO，其上任后发布的 EPOC 32 操作系统，比起前辈，已有了翻天覆地的变化。吸引了人们以及投资者的兴趣。今天我们吧 Myers 成为 “Symbian 之父”。</p>
<p>  EPOC 32 与 windows 极为相似，它是一套 32 位的系统，支持多任务，拥有图形化美观的界面。鉴于当时几乎没有可以直接用于手机的操作系统，它的问世，一下子汇聚了厂商的目光。不过，任何一项新技术新产品的诞生都需要时间的推敲，智能手机系统作为新兴事物，没有哪家厂商敢冒险直接挺近。一番商榷之后，1998 年，爱立信、诺基亚、摩托罗拉和 Psion 共同成立了一家公司，目的是推进手机和 PDA 的智能化，它就是我们今天熟知的 “Symbian”。</p>
<h3 id="拉帮结派飞速发展">拉帮结派，飞速发展</h3>
<p>   联盟的成立不仅吸引了大量手机厂商，一些上有配件商，例如 ARM 和德州仪器都加入了合作计划。</p>
<p>  Symbian 从一成立便秉持着开放的理念，任何组织和个人都能为其开发软件。但刚成立那几年，公司都未能推出一款真真意义上的产品，巨头们也只是作为附属项目在发展。直到 1999 年，Symbian OS v5 平台作为第一款成熟的产品被设计出来，为了争夺 “谁是世界上第一台智能手机”，爱立信没有经过完成的 DEBUG，就匆忙的把他推向市场，生产出 Erisson R380。同时期，摩托也推迟了自己的天拓 A6188。可实际上，两者中无论哪个都不能算严格意义上的智能手机，它们连软件都不能自由安装，真正算起来，搭载了 os v5.1 的诺基亚 9210 才符合智能机最基本的定义，由此，诺基亚开始领先于其他厂商并保持到了最后。</p>
<p>   众所周知，利益面前必有纠纷。诺基亚的崛起必然伴随了很多厂商的陨落，同时，它的存在也让联盟中其他有实力的厂商感到了危机，这为后来阵营的割分埋下了导火索。</p>
<p>  Symbian 成立之初提出了著名的三分法：Pearl (珍珠）、Quartz (石英）和 Crystal（水晶）。分别对应手机的三大发展趋势：标砖键盘、触摸屏以及全键盘。诺基亚依靠 Pearl 迅速赢得了市场，逼迫索尼爱立信和摩托罗拉只能另寻他路 &ndash;Quartz。于是，联盟分为了两大派系，一是以诺基亚牵头的 S 系列平台，再者便是索尼爱立信主打 UIQ。诺基亚凭借标准键盘占据了大半江山，而后者则主攻触摸屏。这种同床异梦的现象愈演愈烈，直接导致了联盟崩溃的迫近。</p>
<p>   当然，上述现象只是苗头，整个联盟正处于高速发展阶段。2002 年，微软的 WM 系统进入市场，这个原本被人们誉为 “Symbian 终结者” 的系统，却远没有它的大哥一般占据市场，反而被后者打的满地找牙。与此同时，诺基亚更是凭借 Pearl 进一步扩展帝国的领土，N70、N73、N95 的横空出世，为诺基亚扎实了自己的实力，待到 Symbian 王朝最鼎盛时，这个姓塞的家族占据了 72% 的智能手机市场，其中更是有九成乃至如日中天的诺基亚。直到现在，都没有哪一家厂商甚至哪一个操作系统打破这个纪录。</p>
<h3 id="兄弟反目联盟瓦解">兄弟反目，联盟瓦解</h3>
<p>   正如上文所说，一家独大必然引发隐患。而事实证明那一天来了。2008 年，UIQ 宣布倒闭。究其原因，一方面是由于它自身定位与市场的极大反差，而另一方面便是来自于诺基亚的压力。相比 S60，开发者在这个平台上的收益远不及前者。应用程序的短缺自然局限了消费者的购买欲，如此一来，倒闭似乎只是时间问题了。诺基亚的持续壮大，扼杀了其他厂商的利润，长此以往，天平的过分了倾斜让别的厂商不得不退出 Symbian 的纷争。UIQ 的倒闭，标志着诺基亚对于 Symbian 掌控的最大化，后者从此只有一个主人了。</p>
<p>   联盟名存实亡，但诺基亚为了避嫌，标榜着 “开放” 而成立了 Symbian 基金会，继续推向面向所有开发者开放的原则，明则共享资源，暗则染指一统智能市场。不幸的是，这是 iPhone 和 Android 问世了。后来的结果，各位看官一定也都清楚。诺基亚的美梦做早了，自大的它快走到了末路。</p>
<p>   多年以后，关于那个一统江湖的传说，早已沦为笑谈罢了。</p>
<h3 id="成也-symbian败也-symbian">成也 Symbian，败也 Symbian</h3>
<p>   船大难掉头。巨头对于市场末端的变化总是慢半拍。身处多年王位的诺基亚早已麻痹了大意。UIQ 的倒闭，让其认为触摸屏不被市场接受，继续推进 S60 这个老迈的系统被诺基亚看做唯一路线。iPhone 的面市彻底颠覆了人们对于智能手机的认识，一度让人们认为 iPhone 重新定义了智能手机。市场的反应也确实印证了这一点，我们的双手确实是最适合操作的工具。但固守己见的诺基亚貌似看不到这一变化，迟迟不肯跳出键盘的定式思维。虽然后来确实推出了几款诸如 5800 这样销量很不错的触屏手机，当一切来的太晚，苹果做大了，随后的绿皮机器人也成熟了，Symbian 王朝彻底步入了晚年。</p>
<p>   失去市场号召力的诺基亚此时的地位一落千丈，对于 Symbian 的态度也是一日三变。曾一度把源代码挂在网站上任人下载，随后又宣布只面向企业用户开源。这时的诺基亚真的急了。不愿投奔机器人阵营沦落为硬件制作商的他，竟甘心跪倒在昔日手下败将的裙下。2011 年 12 月，Symbian Belle 正式更名为诺基亚 Belle。诺基亚连名字都不行再见的 Symbian 从此已经不复存在。</p>
<p>   然而，这并不意味着 Symbian 彻底的灭亡。名字虽然没有了，但产品依旧没有改变，与其说它灭亡不如说它失去了原来那般强大的市场号召力。毕竟，凭借 S40 在低端市场的畅销，诺基亚还能在手机市场分的一杯羹。</p>
<h3 id="未来未来">未来？未来！</h3>
<p>   向微软投怀送抱之后，诺基亚在 Symbian 的建树彻底才枯思竭。以至于不得不推出 808 这样依靠单一买点为噱头吸引市场关注的 “帐篷手机”。Symbian 的今生今世已经无话可说。而未来又在何方？原本打算有所期盼的笔者，本来打算对它的未来有所展望和揣测，不幸的是，本文截稿前的 1 月 24 日，诺基亚公布了 2012 年第四季度最新的财政业绩报告显示，该季度诺基亚实现净利润 2.02 亿欧元，告别 6 连亏，但同时诺基亚官方宣称去年在巴塞罗那发布的 808PureView 将会是最后一款塞班手机，这也意味着塞班这一已经被使用了 15 年之久的智能手机操作系统终于将告别市场，而诺基亚在智能手机领域也终于百分之百微软化。 诺基亚 CEO 斯蒂芬・埃洛普表示：“2012 财年上半年相对艰难，但第四财季表现强劲，设备和服务部门的运营利润率得到了改善。我们将继续执行既定的转移战略，包括继续提升产品竞争力，加速运营，管理成本等。”</p>
<p>   因此，至少在看得见的未来，Symbian 已经没有了未来！</p>
<h3 id="末了">末了</h3>
<p>   无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。</p>
<pre><code>P.S. 谨以此文献给那些成长路上的人和事，Symbian 没了，坛子没有了，但我们都还在。
    这些有关我们青春的事逝去也就随他去了，至少我们还有彼此。</code></pre>]]></description>
</item></channel>
</rss>
